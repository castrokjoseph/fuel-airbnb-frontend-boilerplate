'use strict';

let wasm$1;

const cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); }
let cachedUint8Memory0 = null;

function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm$1.memory.buffer);
    }
    return cachedUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}
/**
* Construct a `GM` instruction from its arguments.
* @param {number} ra
* @param {GMArgs} args
* @returns {Instruction}
*/
function gm_args(ra, args) {
    const ret = wasm$1.gm_args(ra, args);
    return Instruction.__wrap(ret);
}

/**
* Construct a `GM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {GTFArgs} args
* @returns {Instruction}
*/
function gtf_args(ra, rb, args) {
    const ret = wasm$1.gtf_args(ra, rb, args);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDCM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {CompareArgs} args
* @returns {Instruction}
*/
function wdcm_args(ra, rb, rc, args) {
    _assertClass(args, CompareArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdcm_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQCM` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {CompareArgs} args
* @returns {Instruction}
*/
function wqcm_args(ra, rb, rc, args) {
    _assertClass(args, CompareArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqcm_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDOP` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MathArgs} args
* @returns {Instruction}
*/
function wdop_args(ra, rb, rc, args) {
    _assertClass(args, MathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQOP` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MathArgs} args
* @returns {Instruction}
*/
function wqop_args(ra, rb, rc, args) {
    _assertClass(args, MathArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqop_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDML` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MulArgs} args
* @returns {Instruction}
*/
function wdml_args(ra, rb, rc, args) {
    _assertClass(args, MulArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wdml_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQML` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {MulArgs} args
* @returns {Instruction}
*/
function wqml_args(ra, rb, rc, args) {
    _assertClass(args, MulArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqml_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WDDV` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {DivArgs} args
* @returns {Instruction}
*/
function wddv_args(ra, rb, rc, args) {
    _assertClass(args, DivArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wddv_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
* Construct a `WQDV` instruction from its arguments.
* @param {number} ra
* @param {number} rb
* @param {number} rc
* @param {DivArgs} args
* @returns {Instruction}
*/
function wqdv_args(ra, rb, rc, args) {
    _assertClass(args, DivArgs);
    var ptr0 = args.__destroy_into_raw();
    const ret = wasm$1.wqdv_args(ra, rb, rc, ptr0);
    return Instruction.__wrap(ret);
}

/**
*Adds two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function add(dst, lhs, rhs) {
    const ret = wasm$1.add(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ANDs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function and(dst, lhs, rhs) {
    const ret = wasm$1.and(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Divides two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function div(dst, lhs, rhs) {
    const ret = wasm$1.div(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Compares two registers for equality.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function eq(dst, lhs, rhs) {
    const ret = wasm$1.eq(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Raises one register to the power of another.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function exp(dst, lhs, rhs) {
    const ret = wasm$1.exp(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Compares two registers for greater-than.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function gt(dst, lhs, rhs) {
    const ret = wasm$1.gt(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Compares two registers for less-than.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function lt(dst, lhs, rhs) {
    const ret = wasm$1.lt(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*The integer logarithm of a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mlog(dst, lhs, rhs) {
    const ret = wasm$1.mlog(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*The integer root of a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mroo(dst, lhs, rhs) {
    const ret = wasm$1.mroo(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Modulo remainder of two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mod_(dst, lhs, rhs) {
    const ret = wasm$1.mod_(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Copy from one register to another.
* @param {number} dst
* @param {number} src
* @returns {Instruction}
*/
function move_(dst, src) {
    const ret = wasm$1.move_(dst, src);
    return Instruction.__wrap(ret);
}

/**
*Multiplies two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function mul(dst, lhs, rhs) {
    const ret = wasm$1.mul(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise NOT a register.
* @param {number} dst
* @param {number} arg
* @returns {Instruction}
*/
function not(dst, arg) {
    const ret = wasm$1.not(dst, arg);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ORs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function or(dst, lhs, rhs) {
    const ret = wasm$1.or(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Left shifts a register by a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function sll(dst, lhs, rhs) {
    const ret = wasm$1.sll(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Right shifts a register by a register.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function srl(dst, lhs, rhs) {
    const ret = wasm$1.srl(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Subtracts two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function sub(dst, lhs, rhs) {
    const ret = wasm$1.sub(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise XORs two registers.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function xor(dst, lhs, rhs) {
    const ret = wasm$1.xor(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Fused multiply-divide with arbitrary precision intermediate step.
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
function mldv(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.mldv(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
*Return from context.
* @param {number} value
* @returns {Instruction}
*/
function ret(value) {
    const ret = wasm$1.ret(value);
    return Instruction.__wrap(ret);
}

/**
*Return from context with data.
* @param {number} addr
* @param {number} len
* @returns {Instruction}
*/
function retd(addr, len) {
    const ret = wasm$1.retd(addr, len);
    return Instruction.__wrap(ret);
}

/**
*Allocate a number of bytes from the heap.
* @param {number} bytes
* @returns {Instruction}
*/
function aloc(bytes) {
    const ret = wasm$1.aloc(bytes);
    return Instruction.__wrap(ret);
}

/**
*Clear a variable number of bytes in memory.
* @param {number} dst_addr
* @param {number} len
* @returns {Instruction}
*/
function mcl(dst_addr, len) {
    const ret = wasm$1.mcl(dst_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Copy a variable number of bytes in memory.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function mcp(dst_addr, src_addr, len) {
    const ret = wasm$1.mcp(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Compare bytes in memory.
* @param {number} result
* @param {number} lhs_addr
* @param {number} rhs_addr
* @param {number} len
* @returns {Instruction}
*/
function meq(result, lhs_addr, rhs_addr, len) {
    const ret = wasm$1.meq(result, lhs_addr, rhs_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Get block header hash for height.
* @param {number} dst
* @param {number} heigth
* @returns {Instruction}
*/
function bhsh(dst, heigth) {
    const ret = wasm$1.bhsh(dst, heigth);
    return Instruction.__wrap(ret);
}

/**
*Get current block height.
* @param {number} dst
* @returns {Instruction}
*/
function bhei(dst) {
    const ret = wasm$1.bhei(dst);
    return Instruction.__wrap(ret);
}

/**
*Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
* @param {number} amount
* @param {number} sub_id_addr
* @returns {Instruction}
*/
function burn(amount, sub_id_addr) {
    const ret = wasm$1.burn(amount, sub_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Call a contract.
* @param {number} target_struct
* @param {number} fwd_coins
* @param {number} asset_id_addr
* @param {number} fwd_gas
* @returns {Instruction}
*/
function call(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
    const ret = wasm$1.call(target_struct, fwd_coins, asset_id_addr, fwd_gas);
    return Instruction.__wrap(ret);
}

/**
*Copy contract code for a contract.
* @param {number} dst_addr
* @param {number} contract_id_addr
* @param {number} offset
* @param {number} len
* @returns {Instruction}
*/
function ccp(dst_addr, contract_id_addr, offset, len) {
    const ret = wasm$1.ccp(dst_addr, contract_id_addr, offset, len);
    return Instruction.__wrap(ret);
}

/**
*Get code root of a contract.
* @param {number} dst_addr
* @param {number} contract_id_addr
* @returns {Instruction}
*/
function croo(dst_addr, contract_id_addr) {
    const ret = wasm$1.croo(dst_addr, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Get code size of a contract.
* @param {number} dst
* @param {number} contract_id_addr
* @returns {Instruction}
*/
function csiz(dst, contract_id_addr) {
    const ret = wasm$1.csiz(dst, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Get current block proposer's address.
* @param {number} dst
* @returns {Instruction}
*/
function cb(dst) {
    const ret = wasm$1.cb(dst);
    return Instruction.__wrap(ret);
}

/**
*Load a contract's code as executable.
* @param {number} contract_id_addr
* @param {number} offset
* @param {number} len
* @returns {Instruction}
*/
function ldc(contract_id_addr, offset, len) {
    const ret = wasm$1.ldc(contract_id_addr, offset, len);
    return Instruction.__wrap(ret);
}

/**
*Log an event.
* @param {number} a
* @param {number} b
* @param {number} c
* @param {number} d
* @returns {Instruction}
*/
function log(a, b, c, d) {
    const ret = wasm$1.log(a, b, c, d);
    return Instruction.__wrap(ret);
}

/**
*Log data.
* @param {number} a
* @param {number} b
* @param {number} addr
* @param {number} len
* @returns {Instruction}
*/
function logd(a, b, addr, len) {
    const ret = wasm$1.logd(a, b, addr, len);
    return Instruction.__wrap(ret);
}

/**
*Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
* @param {number} amount
* @param {number} sub_id_addr
* @returns {Instruction}
*/
function mint(amount, sub_id_addr) {
    const ret = wasm$1.mint(amount, sub_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Halt execution, reverting state changes and returning a value.
* @param {number} value
* @returns {Instruction}
*/
function rvrt(value) {
    const ret = wasm$1.rvrt(value);
    return Instruction.__wrap(ret);
}

/**
*Clear a series of slots from contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} lenq
* @returns {Instruction}
*/
function scwq(key_addr, status, lenq) {
    const ret = wasm$1.scwq(key_addr, status, lenq);
    return Instruction.__wrap(ret);
}

/**
*Load a word from contract storage.
* @param {number} dst
* @param {number} status
* @param {number} key_addr
* @returns {Instruction}
*/
function srw(dst, status, key_addr) {
    const ret = wasm$1.srw(dst, status, key_addr);
    return Instruction.__wrap(ret);
}

/**
*Load a series of 32 byte slots from contract storage.
* @param {number} dst_addr
* @param {number} status
* @param {number} key_addr
* @param {number} lenq
* @returns {Instruction}
*/
function srwq(dst_addr, status, key_addr, lenq) {
    const ret = wasm$1.srwq(dst_addr, status, key_addr, lenq);
    return Instruction.__wrap(ret);
}

/**
*Store a word in contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} value
* @returns {Instruction}
*/
function sww(key_addr, status, value) {
    const ret = wasm$1.sww(key_addr, status, value);
    return Instruction.__wrap(ret);
}

/**
*Store a series of 32 byte slots in contract storage.
* @param {number} key_addr
* @param {number} status
* @param {number} src_addr
* @param {number} lenq
* @returns {Instruction}
*/
function swwq(key_addr, status, src_addr, lenq) {
    const ret = wasm$1.swwq(key_addr, status, src_addr, lenq);
    return Instruction.__wrap(ret);
}

/**
*Transfer coins to a contract unconditionally.
* @param {number} contract_id_addr
* @param {number} amount
* @param {number} asset_id_addr
* @returns {Instruction}
*/
function tr(contract_id_addr, amount, asset_id_addr) {
    const ret = wasm$1.tr(contract_id_addr, amount, asset_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Transfer coins to a variable output.
* @param {number} contract_id_addr
* @param {number} output_index
* @param {number} amount
* @param {number} asset_id_addr
* @returns {Instruction}
*/
function tro(contract_id_addr, output_index, amount, asset_id_addr) {
    const ret = wasm$1.tro(contract_id_addr, output_index, amount, asset_id_addr);
    return Instruction.__wrap(ret);
}

/**
*The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message.
* @param {number} dst_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
function eck1(dst_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.eck1(dst_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
*The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message.
* @param {number} dst_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
function ecr1(dst_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.ecr1(dst_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
*Verify ED25519 public key and signature match a 32-byte message.
* @param {number} pub_key_addr
* @param {number} sig_addr
* @param {number} msg_hash_addr
* @returns {Instruction}
*/
function ed19(pub_key_addr, sig_addr, msg_hash_addr) {
    const ret = wasm$1.ed19(pub_key_addr, sig_addr, msg_hash_addr);
    return Instruction.__wrap(ret);
}

/**
*The keccak-256 hash of a slice.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function k256(dst_addr, src_addr, len) {
    const ret = wasm$1.k256(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*The SHA-2-256 hash of a slice.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function s256(dst_addr, src_addr, len) {
    const ret = wasm$1.s256(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Get timestamp of block at given height.
* @param {number} dst
* @param {number} heigth
* @returns {Instruction}
*/
function time(dst, heigth) {
    const ret = wasm$1.time(dst, heigth);
    return Instruction.__wrap(ret);
}

/**
*Performs no operation.
* @returns {Instruction}
*/
function noop() {
    const ret = wasm$1.noop();
    return Instruction.__wrap(ret);
}

/**
*Set flag register to a register.
* @param {number} value
* @returns {Instruction}
*/
function flag(value) {
    const ret = wasm$1.flag(value);
    return Instruction.__wrap(ret);
}

/**
*Get the balance of contract of an asset ID.
* @param {number} dst
* @param {number} asset_id_addr
* @param {number} contract_id_addr
* @returns {Instruction}
*/
function bal(dst, asset_id_addr, contract_id_addr) {
    const ret = wasm$1.bal(dst, asset_id_addr, contract_id_addr);
    return Instruction.__wrap(ret);
}

/**
*Dynamic jump.
* @param {number} abs_target
* @returns {Instruction}
*/
function jmp(abs_target) {
    const ret = wasm$1.jmp(abs_target);
    return Instruction.__wrap(ret);
}

/**
*Conditional dynamic jump.
* @param {number} abs_target
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function jne(abs_target, lhs, rhs) {
    const ret = wasm$1.jne(abs_target, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Send a message to recipient address with call abi, coins, and output.
* @param {number} recipient_addr
* @param {number} data_addr
* @param {number} data_len
* @param {number} coins
* @returns {Instruction}
*/
function smo(recipient_addr, data_addr, data_len, coins) {
    const ret = wasm$1.smo(recipient_addr, data_addr, data_len, coins);
    return Instruction.__wrap(ret);
}

/**
*Adds a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function addi(dst, lhs, rhs) {
    const ret = wasm$1.addi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ANDs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function andi(dst, lhs, rhs) {
    const ret = wasm$1.andi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Divides a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function divi(dst, lhs, rhs) {
    const ret = wasm$1.divi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Raises one register to the power of an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function expi(dst, lhs, rhs) {
    const ret = wasm$1.expi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Modulo remainder of a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function modi(dst, lhs, rhs) {
    const ret = wasm$1.modi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Multiplies a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function muli(dst, lhs, rhs) {
    const ret = wasm$1.muli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise ORs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function ori(dst, lhs, rhs) {
    const ret = wasm$1.ori(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Left shifts a register by an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function slli(dst, lhs, rhs) {
    const ret = wasm$1.slli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Right shifts a register by an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function srli(dst, lhs, rhs) {
    const ret = wasm$1.srli(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Subtracts a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function subi(dst, lhs, rhs) {
    const ret = wasm$1.subi(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Bitwise XORs a register and an immediate value.
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @returns {Instruction}
*/
function xori(dst, lhs, rhs) {
    const ret = wasm$1.xori(dst, lhs, rhs);
    return Instruction.__wrap(ret);
}

/**
*Conditional jump.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} abs_target
* @returns {Instruction}
*/
function jnei(cond_lhs, cond_rhs, abs_target) {
    const ret = wasm$1.jnei(cond_lhs, cond_rhs, abs_target);
    return Instruction.__wrap(ret);
}

/**
*A byte is loaded from the specified address offset by an immediate value.
* @param {number} dst
* @param {number} addr
* @param {number} offset
* @returns {Instruction}
*/
function lb(dst, addr, offset) {
    const ret = wasm$1.lb(dst, addr, offset);
    return Instruction.__wrap(ret);
}

/**
*A word is loaded from the specified address offset by an immediate value.
* @param {number} dst
* @param {number} addr
* @param {number} offset
* @returns {Instruction}
*/
function lw(dst, addr, offset) {
    const ret = wasm$1.lw(dst, addr, offset);
    return Instruction.__wrap(ret);
}

/**
*Write the least significant byte of a register to memory.
* @param {number} addr
* @param {number} value
* @param {number} offset
* @returns {Instruction}
*/
function sb(addr, value, offset) {
    const ret = wasm$1.sb(addr, value, offset);
    return Instruction.__wrap(ret);
}

/**
*Write a register to memory.
* @param {number} addr
* @param {number} value
* @param {number} offset
* @returns {Instruction}
*/
function sw(addr, value, offset) {
    const ret = wasm$1.sw(addr, value, offset);
    return Instruction.__wrap(ret);
}

/**
*Copy an immediate number of bytes in memory.
* @param {number} dst_addr
* @param {number} src_addr
* @param {number} len
* @returns {Instruction}
*/
function mcpi(dst_addr, src_addr, len) {
    const ret = wasm$1.mcpi(dst_addr, src_addr, len);
    return Instruction.__wrap(ret);
}

/**
*Get transaction fields.
* @param {number} dst
* @param {number} arg
* @param {number} selector
* @returns {Instruction}
*/
function gtf(dst, arg, selector) {
    const ret = wasm$1.gtf(dst, arg, selector);
    return Instruction.__wrap(ret);
}

/**
*Clear an immediate number of bytes in memory.
* @param {number} addr
* @param {number} count
* @returns {Instruction}
*/
function mcli(addr, count) {
    const ret = wasm$1.mcli(addr, count);
    return Instruction.__wrap(ret);
}

/**
*Get metadata from memory.
* @param {number} dst
* @param {number} selector
* @returns {Instruction}
*/
function gm(dst, selector) {
    const ret = wasm$1.gm(dst, selector);
    return Instruction.__wrap(ret);
}

/**
*Copy immediate value into a register
* @param {number} dst
* @param {number} val
* @returns {Instruction}
*/
function movi(dst, val) {
    const ret = wasm$1.movi(dst, val);
    return Instruction.__wrap(ret);
}

/**
*Conditional jump against zero.
* @param {number} cond_nz
* @param {number} abs_target
* @returns {Instruction}
*/
function jnzi(cond_nz, abs_target) {
    const ret = wasm$1.jnzi(cond_nz, abs_target);
    return Instruction.__wrap(ret);
}

/**
*Unconditional dynamic relative jump forwards, with a constant offset.
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jmpf(dynamic, fixed) {
    const ret = wasm$1.jmpf(dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Unconditional dynamic relative jump backwards, with a constant offset.
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jmpb(dynamic, fixed) {
    const ret = wasm$1.jmpb(dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump forwards, conditional against zero, with a constant offset.
* @param {number} cond_nz
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jnzf(cond_nz, dynamic, fixed) {
    const ret = wasm$1.jnzf(cond_nz, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump backwards, conditional against zero, with a constant offset.
* @param {number} cond_nz
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jnzb(cond_nz, dynamic, fixed) {
    const ret = wasm$1.jnzb(cond_nz, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jnef(cond_lhs, cond_rhs, dynamic, fixed) {
    const ret = wasm$1.jnef(cond_lhs, cond_rhs, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
* @param {number} cond_lhs
* @param {number} cond_rhs
* @param {number} dynamic
* @param {number} fixed
* @returns {Instruction}
*/
function jneb(cond_lhs, cond_rhs, dynamic, fixed) {
    const ret = wasm$1.jneb(cond_lhs, cond_rhs, dynamic, fixed);
    return Instruction.__wrap(ret);
}

/**
*Jump.
* @param {number} abs_target
* @returns {Instruction}
*/
function ji(abs_target) {
    const ret = wasm$1.ji(abs_target);
    return Instruction.__wrap(ret);
}

/**
*Extend the current call frame's stack by an immediate value.
* @param {number} amount
* @returns {Instruction}
*/
function cfei(amount) {
    const ret = wasm$1.cfei(amount);
    return Instruction.__wrap(ret);
}

/**
*Shrink the current call frame's stack by an immediate value.
* @param {number} amount
* @returns {Instruction}
*/
function cfsi(amount) {
    const ret = wasm$1.cfsi(amount);
    return Instruction.__wrap(ret);
}

/**
*Extend the current call frame's stack
* @param {number} amount
* @returns {Instruction}
*/
function cfe(amount) {
    const ret = wasm$1.cfe(amount);
    return Instruction.__wrap(ret);
}

/**
*Shrink the current call frame's stack
* @param {number} amount
* @returns {Instruction}
*/
function cfs(amount) {
    const ret = wasm$1.cfs(amount);
    return Instruction.__wrap(ret);
}

/**
*Push a bitmask-selected set of registers in range 16..40 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function pshl(bitmask) {
    const ret = wasm$1.pshl(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Push a bitmask-selected set of registers in range 40..64 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function pshh(bitmask) {
    const ret = wasm$1.pshh(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Pop a bitmask-selected set of registers in range 16..40 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function popl(bitmask) {
    const ret = wasm$1.popl(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Pop a bitmask-selected set of registers in range 40..64 to the stack.
* @param {number} bitmask
* @returns {Instruction}
*/
function poph(bitmask) {
    const ret = wasm$1.poph(bitmask);
    return Instruction.__wrap(ret);
}

/**
*Compare 128bit integers
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wdcm(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdcm(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Compare 256bit integers
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqcm(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqcm(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Simple 128bit operations
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wdop(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Simple 256bit operations
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqop(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqop(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Multiply 128bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wdml(dst, lhs, rhs, flags) {
    const ret = wasm$1.wdml(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Multiply 256bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqml(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqml(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Divide 128bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wddv(dst, lhs, rhs, flags) {
    const ret = wasm$1.wddv(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Divide 256bit
* @param {number} dst
* @param {number} lhs
* @param {number} rhs
* @param {number} flags
* @returns {Instruction}
*/
function wqdv(dst, lhs, rhs, flags) {
    const ret = wasm$1.wqdv(dst, lhs, rhs, flags);
    return Instruction.__wrap(ret);
}

/**
*Fused multiply-divide 128bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
function wdmd(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.wdmd(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
*Fused multiply-divide 256bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} divisor
* @returns {Instruction}
*/
function wqmd(dst, mul_lhs, mul_rhs, divisor) {
    const ret = wasm$1.wqmd(dst, mul_lhs, mul_rhs, divisor);
    return Instruction.__wrap(ret);
}

/**
*AddMod 128bit
* @param {number} dst
* @param {number} add_lhs
* @param {number} add_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wdam(dst, add_lhs, add_rhs, modulo) {
    const ret = wasm$1.wdam(dst, add_lhs, add_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*AddMod 256bit
* @param {number} dst
* @param {number} add_lhs
* @param {number} add_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wqam(dst, add_lhs, add_rhs, modulo) {
    const ret = wasm$1.wqam(dst, add_lhs, add_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*MulMod 128bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wdmm(dst, mul_lhs, mul_rhs, modulo) {
    const ret = wasm$1.wdmm(dst, mul_lhs, mul_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*MulMod 256bit
* @param {number} dst
* @param {number} mul_lhs
* @param {number} mul_rhs
* @param {number} modulo
* @returns {Instruction}
*/
function wqmm(dst, mul_lhs, mul_rhs, modulo) {
    const ret = wasm$1.wqmm(dst, mul_lhs, mul_rhs, modulo);
    return Instruction.__wrap(ret);
}

/**
*Call external function
* @param {number} a
* @param {number} b
* @param {number} c
* @param {number} d
* @returns {Instruction}
*/
function ecal(a, b, c, d) {
    const ret = wasm$1.ecal(a, b, c, d);
    return Instruction.__wrap(ret);
}

let cachedInt32Memory0 = null;

function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm$1.memory.buffer);
    }
    return cachedInt32Memory0;
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
*r" Argument list for GM (get metadata) instruction
*r" The VM is the only who should match this struct, and it *MUST* always perform
*r" exhaustive match so all offered variants are covered.
*/
const GMArgs = Object.freeze({
/**
*r" Get if caller is external.
*/
IsCallerExternal:1,"1":"IsCallerExternal",
/**
*r" Get caller's contract ID.
*/
GetCaller:2,"2":"GetCaller",
/**
*r" Get index of current predicate.
*/
GetVerifyingPredicate:3,"3":"GetVerifyingPredicate",
/**
*r" Get the Chain ID this VM is operating within
*/
GetChainId:4,"4":"GetChainId",
/**
*r" Get memory address where the transaction is located
*/
TxStart:5,"5":"TxStart",
/**
*r" Get memory address of base asset ID
*/
BaseAssetId:6,"6":"BaseAssetId", });
/**
* Comparison mode used by WDCM and WQCM instructions.
*/
const CompareMode = Object.freeze({
/**
* Equality (`==`)
*/
EQ:0,"0":"EQ",
/**
* Inequality (`!=`)
*/
NE:1,"1":"NE",
/**
* Less than (`<`)
*/
LT:2,"2":"LT",
/**
* Greater than (`>`)
*/
GT:3,"3":"GT",
/**
* Less than or equals (`>=`)
*/
LTE:4,"4":"LTE",
/**
* Greater than or equals (`>=`)
*/
GTE:5,"5":"GTE",
/**
* Number of leading zeroes in lhs (`lzcnt`) (discards rhs)
*/
LZC:6,"6":"LZC", });
/**
*r" Argument list for GTF (get tx fields) instruction
*r" The VM is the only who should match this struct, and it *MUST* always perform
*r" exhaustive match so all offered variants are covered.
*/
const GTFArgs = Object.freeze({
/**
*r" Set `$rA` to `tx.type`
*/
Type:1,"1":"Type",
/**
*r" Set `$rA` to `tx.scriptGasLimit`
*/
ScriptGasLimit:2,"2":"ScriptGasLimit",
/**
*r" Set `$rA` to `tx.scriptLength`
*/
ScriptLength:3,"3":"ScriptLength",
/**
*r" Set `$rA` to `tx.scriptDataLength`
*/
ScriptDataLength:4,"4":"ScriptDataLength",
/**
*r" Set `$rA` to `tx.inputsCount`
*/
ScriptInputsCount:5,"5":"ScriptInputsCount",
/**
*r" Set `$rA` to `tx.outputsCount`
*/
ScriptOutputsCount:6,"6":"ScriptOutputsCount",
/**
*r" Set `$rA` to `tx.witnessesCount`
*/
ScriptWitnessesCount:7,"7":"ScriptWitnessesCount",
/**
*r" Set `$rA` to `Memory address of tx.receiptsRoot`
*/
ScriptReceiptsRoot:8,"8":"ScriptReceiptsRoot",
/**
*r" Set `$rA` to `Memory address of tx.script`
*/
Script:9,"9":"Script",
/**
*r" Set `$rA` to `Memory address of tx.scriptData`
*/
ScriptData:10,"10":"ScriptData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB]`
*/
ScriptInputAtIndex:11,"11":"ScriptInputAtIndex",
/**
*r" Set `$rA` to `Memory address of t.outputs[$rB]`
*/
ScriptOutputAtIndex:12,"12":"ScriptOutputAtIndex",
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
*/
ScriptWitnessAtIndex:13,"13":"ScriptWitnessAtIndex",
/**
*r" Set `$rA` to size of the transaction in memory, in bytes
*/
TxLength:14,"14":"TxLength",
/**
*r" Set `$rA` to `tx.bytecodeWitnessIndex`
*/
CreateBytecodeWitnessIndex:257,"257":"CreateBytecodeWitnessIndex",
/**
*r" Set `$rA` to `tx.storageSlotsCount`
*/
CreateStorageSlotsCount:258,"258":"CreateStorageSlotsCount",
/**
*r" Set `$rA` to `tx.inputsCount`
*/
CreateInputsCount:259,"259":"CreateInputsCount",
/**
*r" Set `$rA` to `tx.outputsCount`
*/
CreateOutputsCount:260,"260":"CreateOutputsCount",
/**
*r" Set `$rA` to `tx.witnessesCount`
*/
CreateWitnessesCount:261,"261":"CreateWitnessesCount",
/**
*r" Set `$rA` to `Memory address of tx.salt`
*/
CreateSalt:262,"262":"CreateSalt",
/**
*r" Set `$rA` to `Memory address of tx.storageSlots[$rB]`
*/
CreateStorageSlotAtIndex:263,"263":"CreateStorageSlotAtIndex",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB]`
*/
CreateInputAtIndex:264,"264":"CreateInputAtIndex",
/**
*r" Set `$rA` to `Memory address of t.outputs[$rB]`
*/
CreateOutputAtIndex:265,"265":"CreateOutputAtIndex",
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
*/
CreateWitnessAtIndex:266,"266":"CreateWitnessAtIndex",
/**
*r" Set `$rA` to `tx.inputs[$rB].type`
*/
InputType:512,"512":"InputType",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
*/
InputCoinTxId:513,"513":"InputCoinTxId",
/**
*r" Set `$rA` to `tx.inputs[$rB].outputIndex`
*/
InputCoinOutputIndex:514,"514":"InputCoinOutputIndex",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].owner`
*/
InputCoinOwner:515,"515":"InputCoinOwner",
/**
*r" Set `$rA` to `tx.inputs[$rB].amount`
*/
InputCoinAmount:516,"516":"InputCoinAmount",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].asset_id`
*/
InputCoinAssetId:517,"517":"InputCoinAssetId",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
*/
InputCoinTxPointer:518,"518":"InputCoinTxPointer",
/**
*r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
*/
InputCoinWitnessIndex:519,"519":"InputCoinWitnessIndex",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateLength`
*/
InputCoinPredicateLength:521,"521":"InputCoinPredicateLength",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
*/
InputCoinPredicateDataLength:522,"522":"InputCoinPredicateDataLength",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
*/
InputCoinPredicate:523,"523":"InputCoinPredicate",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
*/
InputCoinPredicateData:524,"524":"InputCoinPredicateData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
*/
InputCoinPredicateGasUsed:525,"525":"InputCoinPredicateGasUsed",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
*/
InputContractTxId:544,"544":"InputContractTxId",
/**
*r" Set `$rA` to `tx.inputs[$rB].outputIndex`
*/
InputContractOutputIndex:545,"545":"InputContractOutputIndex",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].contractID`
*/
InputContractId:549,"549":"InputContractId",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].sender`
*/
InputMessageSender:576,"576":"InputMessageSender",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].recipient`
*/
InputMessageRecipient:577,"577":"InputMessageRecipient",
/**
*r" Set `$rA` to `tx.inputs[$rB].amount`
*/
InputMessageAmount:578,"578":"InputMessageAmount",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].nonce`
*/
InputMessageNonce:579,"579":"InputMessageNonce",
/**
*r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
*/
InputMessageWitnessIndex:580,"580":"InputMessageWitnessIndex",
/**
*r" Set `$rA` to `tx.inputs[$rB].dataLength`
*/
InputMessageDataLength:581,"581":"InputMessageDataLength",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateLength`
*/
InputMessagePredicateLength:582,"582":"InputMessagePredicateLength",
/**
*r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
*/
InputMessagePredicateDataLength:583,"583":"InputMessagePredicateDataLength",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].data`
*/
InputMessageData:584,"584":"InputMessageData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
*/
InputMessagePredicate:585,"585":"InputMessagePredicate",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
*/
InputMessagePredicateData:586,"586":"InputMessagePredicateData",
/**
*r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
*/
InputMessagePredicateGasUsed:587,"587":"InputMessagePredicateGasUsed",
/**
*r" Set `$rA` to `tx.outputs[$rB].type`
*/
OutputType:768,"768":"OutputType",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].to`
*/
OutputCoinTo:769,"769":"OutputCoinTo",
/**
*r" Set `$rA` to `tx.outputs[$rB].amount`
*/
OutputCoinAmount:770,"770":"OutputCoinAmount",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].asset_id`
*/
OutputCoinAssetId:771,"771":"OutputCoinAssetId",
/**
*r" Set `$rA` to `tx.outputs[$rB].inputIndex`
*/
OutputContractInputIndex:772,"772":"OutputContractInputIndex",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].contractID`
*/
OutputContractCreatedContractId:775,"775":"OutputContractCreatedContractId",
/**
*r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
*/
OutputContractCreatedStateRoot:776,"776":"OutputContractCreatedStateRoot",
/**
*r" Set `$rA` to `tx.witnesses[$rB].dataLength`
*/
WitnessDataLength:1024,"1024":"WitnessDataLength",
/**
*r" Set `$rA` to `Memory address of tx.witnesses[$rB].data`
*/
WitnessData:1025,"1025":"WitnessData",
/**
*r" Set `$rA` to `tx.policyTypes`
*/
PolicyTypes:1280,"1280":"PolicyTypes",
/**
*r" Set `$rA` to `tx.policies[0x00].gasPrice`
*/
PolicyTip:1281,"1281":"PolicyTip",
/**
*r" Set `$rA` to `tx.policies[count_ones(0b11 & tx.policyTypes) - 1].witnessLimit`
*/
PolicyWitnessLimit:1282,"1282":"PolicyWitnessLimit",
/**
*r" Set `$rA` to `tx.policies[count_ones(0b111 & tx.policyTypes) - 1].maturity`
*/
PolicyMaturity:1283,"1283":"PolicyMaturity",
/**
*r" Set `$rA` to `tx.policies[count_ones(0b1111 & tx.policyTypes) - 1].maxFee`
*/
PolicyMaxFee:1284,"1284":"PolicyMaxFee", });
/**
*r" Panic reason representation for the interpreter.
*/
const PanicReason = Object.freeze({
/**
*r" The byte can't be mapped to any known `PanicReason`.
*/
UnknownPanicReason:0,"0":"UnknownPanicReason",
/**
*r" Found `RVRT` instruction.
*/
Revert:1,"1":"Revert",
/**
*r" Execution ran out of gas.
*/
OutOfGas:2,"2":"OutOfGas",
/**
*r" The transaction validity is violated.
*/
TransactionValidity:3,"3":"TransactionValidity",
/**
*r" Attempt to write outside interpreter memory boundaries.
*/
MemoryOverflow:4,"4":"MemoryOverflow",
/**
*r" Overflow while executing arithmetic operation.
*r" These errors are ignored using the WRAPPING flag.
*/
ArithmeticOverflow:5,"5":"ArithmeticOverflow",
/**
*r" Designed contract was not found in the storage.
*/
ContractNotFound:6,"6":"ContractNotFound",
/**
*r" Memory ownership rules are violated.
*/
MemoryOwnership:7,"7":"MemoryOwnership",
/**
*r" The asset ID balance isn't enough for the instruction.
*/
NotEnoughBalance:8,"8":"NotEnoughBalance",
/**
*r" The interpreter is expected to be in internal context.
*/
ExpectedInternalContext:9,"9":"ExpectedInternalContext",
/**
*r" The queried asset ID was not found in the state.
*/
AssetIdNotFound:10,"10":"AssetIdNotFound",
/**
*r" The provided input is not found in the transaction.
*/
InputNotFound:11,"11":"InputNotFound",
/**
*r" The provided output is not found in the transaction.
*/
OutputNotFound:12,"12":"OutputNotFound",
/**
*r" The provided witness is not found in the transaction.
*/
WitnessNotFound:13,"13":"WitnessNotFound",
/**
*r" The transaction maturity is not valid for this request.
*/
TransactionMaturity:14,"14":"TransactionMaturity",
/**
*r" The metadata identifier is invalid.
*/
InvalidMetadataIdentifier:15,"15":"InvalidMetadataIdentifier",
/**
*r" The call structure is not valid.
*/
MalformedCallStructure:16,"16":"MalformedCallStructure",
/**
*r" The provided register does not allow write operations.
*/
ReservedRegisterNotWritable:17,"17":"ReservedRegisterNotWritable",
/**
*r" The execution resulted in an erroneous state of the interpreter.
*/
InvalidFlags:18,"18":"InvalidFlags",
/**
*r" The provided immediate value is not valid for this instruction.
*/
InvalidImmediateValue:19,"19":"InvalidImmediateValue",
/**
*r" The provided transaction input is not of type `Coin`.
*/
ExpectedCoinInput:20,"20":"ExpectedCoinInput",
/**
*r" `ECAL` instruction failed.
*/
EcalError:21,"21":"EcalError",
/**
*r" Two segments of the interpreter memory should not intersect for write operations.
*/
MemoryWriteOverlap:22,"22":"MemoryWriteOverlap",
/**
*r" The requested contract is not listed in the transaction inputs.
*/
ContractNotInInputs:23,"23":"ContractNotInInputs",
/**
*r" The internal asset ID balance overflowed with the provided instruction.
*/
InternalBalanceOverflow:24,"24":"InternalBalanceOverflow",
/**
*r" The maximum allowed contract size is violated.
*/
ContractMaxSize:25,"25":"ContractMaxSize",
/**
*r" This instruction expects the stack area to be unallocated for this call.
*/
ExpectedUnallocatedStack:26,"26":"ExpectedUnallocatedStack",
/**
*r" The maximum allowed number of static contracts was reached for this transaction.
*/
MaxStaticContractsReached:27,"27":"MaxStaticContractsReached",
/**
*r" The requested transfer amount cannot be zero.
*/
TransferAmountCannotBeZero:28,"28":"TransferAmountCannotBeZero",
/**
*r" The provided transaction output should be of type `Variable`.
*/
ExpectedOutputVariable:29,"29":"ExpectedOutputVariable",
/**
*r" The expected context of the stack parent is internal.
*/
ExpectedParentInternalContext:30,"30":"ExpectedParentInternalContext",
/**
*r" The predicate returned non `1`. The `1` means successful verification
*r" of the predicate, all other values means unsuccessful.
*/
PredicateReturnedNonOne:31,"31":"PredicateReturnedNonOne",
/**
*r" The contract ID is already deployed and can't be overwritten.
*/
ContractIdAlreadyDeployed:32,"32":"ContractIdAlreadyDeployed",
/**
*r" The loaded contract mismatch expectations.
*/
ContractMismatch:33,"33":"ContractMismatch",
/**
*r" Attempting to send message data longer than `MAX_MESSAGE_DATA_LENGTH`
*/
MessageDataTooLong:34,"34":"MessageDataTooLong",
/**
*r" Mathematically invalid arguments where given to an arithmetic instruction.
*r" For instance, division by zero produces this.
*r" These errors are ignored using the UNSAFEMATH flag.
*/
ArithmeticError:35,"35":"ArithmeticError",
/**
*r" The contract instruction is not allowed in predicates.
*/
ContractInstructionNotAllowed:36,"36":"ContractInstructionNotAllowed",
/**
*r" Transfer of zero coins is not allowed.
*/
TransferZeroCoins:37,"37":"TransferZeroCoins",
/**
*r" Attempted to execute an invalid instruction
*/
InvalidInstruction:38,"38":"InvalidInstruction",
/**
*r" Memory outside $is..$ssp range is not executable
*/
MemoryNotExecutable:39,"39":"MemoryNotExecutable",
/**
*r" The policy is not set.
*/
PolicyIsNotSet:40,"40":"PolicyIsNotSet",
/**
*r" The policy is not found across policies.
*/
PolicyNotFound:41,"41":"PolicyNotFound",
/**
*r" Receipt context is full
*/
TooManyReceipts:42,"42":"TooManyReceipts",
/**
*r" Balance of a contract overflowed
*/
BalanceOverflow:43,"43":"BalanceOverflow",
/**
*r" Block height value is invalid, typically because it is too large
*/
InvalidBlockHeight:44,"44":"InvalidBlockHeight",
/**
*r" Attempt to use sequential memory instructions with too large slot count,
*r" typically because it cannot fit into usize
*/
TooManySlots:45,"45":"TooManySlots",
/**
*r" Caller of this internal context is also expected to be internal,
*r" i.e. $fp->$fp must be non-zero.
*/
ExpectedNestedCaller:46,"46":"ExpectedNestedCaller",
/**
*r" During memory growth, the stack overlapped with the heap
*/
MemoryGrowthOverlap:47,"47":"MemoryGrowthOverlap",
/**
*r" Attempting to read or write uninitialized memory.
*r" Also occurs when boundary crosses from stack to heap.
*/
UninitalizedMemoryAccess:48,"48":"UninitalizedMemoryAccess",
/**
*r" Overriding consensus parameters is not allowed.
*/
OverridingConsensusParameters:49,"49":"OverridingConsensusParameters",
/**
*r" The storage doesn't know about the hash of the state transition bytecode.
*/
UnknownStateTransactionBytecodeRoot:50,"50":"UnknownStateTransactionBytecodeRoot",
/**
*r" Overriding the state transition bytecode is not allowed.
*/
OverridingStateTransactionBytecode:51,"51":"OverridingStateTransactionBytecode",
/**
*r" The bytecode is already uploaded and cannot be uploaded again.
*/
BytecodeAlreadyUploaded:52,"52":"BytecodeAlreadyUploaded",
/**
*r" The part of the bytecode is not sequentially connected to the previous parts.
*/
ThePartIsNotSequentiallyConnected:53,"53":"ThePartIsNotSequentiallyConnected", });
/**
* The operation performed by WDOP and WQOP instructions, determined as
*/
const MathOp = Object.freeze({
/**
* Add
*/
ADD:0,"0":"ADD",
/**
* Subtract
*/
SUB:1,"1":"SUB",
/**
* Invert bits (discards rhs)
*/
NOT:2,"2":"NOT",
/**
* Bitwise or
*/
OR:3,"3":"OR",
/**
* Bitwise exclusive or
*/
XOR:4,"4":"XOR",
/**
* Bitwise and
*/
AND:5,"5":"AND",
/**
* Shift left
*/
SHL:6,"6":"SHL",
/**
* Shift right
*/
SHR:7,"7":"SHR", });

const ADDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_add_free(ptr >>> 0));
/**
*Adds two registers.
*/
class ADD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ADDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_add_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ADDIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_addi_free(ptr >>> 0));
/**
*Adds a register and an immediate value.
*/
class ADDI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ADDIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_addi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const ALOCFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_aloc_free(ptr >>> 0));
/**
*Allocate a number of bytes from the heap.
*/
class ALOC {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ALOCFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_aloc_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} bytes
    */
    constructor(bytes) {
        _assertClass(bytes, RegId);
        var ptr0 = bytes.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ANDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_and_free(ptr >>> 0));
/**
*Bitwise ANDs two registers.
*/
class AND {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ANDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_and_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ANDIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_andi_free(ptr >>> 0));
/**
*Bitwise ANDs a register and an immediate value.
*/
class ANDI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ANDIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_andi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const BALFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bal_free(ptr >>> 0));
/**
*Get the balance of contract of an asset ID.
*/
class BAL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BALFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bal_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} asset_id_addr
    * @param {RegId} contract_id_addr
    */
    constructor(dst, asset_id_addr, contract_id_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr1 = asset_id_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr2 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BHEIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bhei_free(ptr >>> 0));
/**
*Get current block height.
*/
class BHEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BHEIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bhei_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    */
    constructor(dst) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BHSHFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_bhsh_free(ptr >>> 0));
/**
*Get block header hash for height.
*/
class BHSH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BHSHFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_bhsh_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} heigth
    */
    constructor(dst, heigth) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(heigth, RegId);
        var ptr1 = heigth.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const BURNFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_burn_free(ptr >>> 0));
/**
*Burns `amount` coins of the asset ID created from `sub_id` for the current contract.
*/
class BURN {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BURNFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_burn_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    * @param {RegId} sub_id_addr
    */
    constructor(amount, sub_id_addr) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        _assertClass(sub_id_addr, RegId);
        var ptr1 = sub_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CALLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_call_free(ptr >>> 0));
/**
*Call a contract.
*/
class CALL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CALLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_call_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} target_struct
    * @param {RegId} fwd_coins
    * @param {RegId} asset_id_addr
    * @param {RegId} fwd_gas
    */
    constructor(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
        _assertClass(target_struct, RegId);
        var ptr0 = target_struct.__destroy_into_raw();
        _assertClass(fwd_coins, RegId);
        var ptr1 = fwd_coins.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr2 = asset_id_addr.__destroy_into_raw();
        _assertClass(fwd_gas, RegId);
        var ptr3 = fwd_gas.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cb_free(ptr >>> 0));
/**
*Get current block proposer's address.
*/
class CB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    */
    constructor(dst) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CCPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ccp_free(ptr >>> 0));
/**
*Copy contract code for a contract.
*/
class CCP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CCPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ccp_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} contract_id_addr
    * @param {RegId} offset
    * @param {RegId} len
    */
    constructor(dst_addr, contract_id_addr, offset, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr2 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CFEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfe_free(ptr >>> 0));
/**
*Extend the current call frame's stack
*/
class CFE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfe_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    */
    constructor(amount) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CFEIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfei_free(ptr >>> 0));
/**
*Extend the current call frame's stack by an immediate value.
*/
class CFEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFEIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfei_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} amount
    */
    constructor(amount) {
        _assertClass(amount, Imm24);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const CFSFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfs_free(ptr >>> 0));
/**
*Shrink the current call frame's stack
*/
class CFS {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFSFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfs_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    */
    constructor(amount) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CFSIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_cfsi_free(ptr >>> 0));
/**
*Shrink the current call frame's stack by an immediate value.
*/
class CFSI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CFSIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_cfsi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} amount
    */
    constructor(amount) {
        _assertClass(amount, Imm24);
        var ptr0 = amount.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const CROOFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_croo_free(ptr >>> 0));
/**
*Get code root of a contract.
*/
class CROO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CROOFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_croo_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} contract_id_addr
    */
    constructor(dst_addr, contract_id_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CSIZFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_csiz_free(ptr >>> 0));
/**
*Get code size of a contract.
*/
class CSIZ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CSIZFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_csiz_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} contract_id_addr
    */
    constructor(dst, contract_id_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(contract_id_addr, RegId);
        var ptr1 = contract_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const CompareArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compareargs_free(ptr >>> 0));
/**
* Arguments for WDCM and WQCM instructions.
*/
class CompareArgs {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompareArgs.prototype);
        obj.__wbg_ptr = ptr;
        CompareArgsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompareArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compareargs_free(ptr);
    }
    /**
    * Comparison mode
    * @returns {CompareMode}
    */
    get mode() {
        const ret = wasm$1.__wbg_get_compareargs_mode(this.__wbg_ptr);
        return ret;
    }
    /**
    * Comparison mode
    * @param {CompareMode} arg0
    */
    set mode(arg0) {
        wasm$1.__wbg_set_compareargs_mode(this.__wbg_ptr, arg0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
    /**
    * Convert to immediate value.
    * @returns {Imm06}
    */
    to_imm() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.compareargs_to_imm(ptr);
        return Imm06.__wrap(ret);
    }
    /**
    * Construct from `Imm06`. Returns `None` if the value has reserved flags set.
    * @param {Imm06} bits
    * @returns {CompareArgs | undefined}
    */
    static from_imm(bits) {
        _assertClass(bits, Imm06);
        var ptr0 = bits.__destroy_into_raw();
        const ret = wasm$1.compareargs_from_imm(ptr0);
        return ret === 0 ? undefined : CompareArgs.__wrap(ret);
    }
}

const DIVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_div_free(ptr >>> 0));
/**
*Divides two registers.
*/
class DIV {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DIVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_div_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const DIVIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_divi_free(ptr >>> 0));
/**
*Divides a register and an immediate value.
*/
class DIVI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DIVIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_divi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const DivArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_divargs_free(ptr >>> 0));
/**
* Additional arguments for WMDV and WDDV instructions.
*/
class DivArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DivArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_divargs_free(ptr);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_divargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}

const ECALFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ecal_free(ptr >>> 0));
/**
*Call external function
*/
class ECAL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECALFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecal_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} a
    * @param {RegId} b
    * @param {RegId} c
    * @param {RegId} d
    */
    constructor(a, b, c, d) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(c, RegId);
        var ptr2 = c.__destroy_into_raw();
        _assertClass(d, RegId);
        var ptr3 = d.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ECK1Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_eck1_free(ptr >>> 0));
/**
*The 64-byte public key (x, y) recovered from 64-byte signature on 32-byte message.
*/
class ECK1 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECK1Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_eck1_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} sig_addr
    * @param {RegId} msg_hash_addr
    */
    constructor(dst_addr, sig_addr, msg_hash_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ECR1Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ecr1_free(ptr >>> 0));
/**
*The 64-byte Secp256r1 public key (x, y) recovered from 64-byte signature on 32-byte message.
*/
class ECR1 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ECR1Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ecr1_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} sig_addr
    * @param {RegId} msg_hash_addr
    */
    constructor(dst_addr, sig_addr, msg_hash_addr) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ED19Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ed19_free(ptr >>> 0));
/**
*Verify ED25519 public key and signature match a 32-byte message.
*/
class ED19 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ED19Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ed19_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} pub_key_addr
    * @param {RegId} sig_addr
    * @param {RegId} msg_hash_addr
    */
    constructor(pub_key_addr, sig_addr, msg_hash_addr) {
        _assertClass(pub_key_addr, RegId);
        var ptr0 = pub_key_addr.__destroy_into_raw();
        _assertClass(sig_addr, RegId);
        var ptr1 = sig_addr.__destroy_into_raw();
        _assertClass(msg_hash_addr, RegId);
        var ptr2 = msg_hash_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_eq_free(ptr >>> 0));
/**
*Compares two registers for equality.
*/
class EQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_eq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EXPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_exp_free(ptr >>> 0));
/**
*Raises one register to the power of another.
*/
class EXP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EXPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_exp_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const EXPIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_expi_free(ptr >>> 0));
/**
*Raises one register to the power of an immediate value.
*/
class EXPI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EXPIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_expi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const FLAGFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_flag_free(ptr >>> 0));
/**
*Set flag register to a register.
*/
class FLAG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FLAGFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_flag_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} value
    */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const GMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_gm_free(ptr >>> 0));
/**
*Get metadata from memory.
*/
class GM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GM.prototype);
        obj.__wbg_ptr = ptr;
        GMFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gm_free(ptr);
    }
    /**
    * Construct a `GM` instruction from its arguments.
    * @param {RegId} ra
    * @param {GMArgs} args
    * @returns {GM}
    */
    static from_args(ra, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        const ret = wasm$1.gm_from_args(ptr0, args);
        return GM.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {Imm18} selector
    */
    constructor(dst, selector) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(selector, Imm18);
        var ptr1 = selector.__destroy_into_raw();
        const ret = wasm$1.gm_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const GTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_gt_free(ptr >>> 0));
/**
*Compares two registers for greater-than.
*/
class GT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gt_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const GTFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_gtf_free(ptr >>> 0));
/**
*Get transaction fields.
*/
class GTF {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GTF.prototype);
        obj.__wbg_ptr = ptr;
        GTFFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GTFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_gtf_free(ptr);
    }
    /**
    * Construct a `GTF` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {GTFArgs} args
    * @returns {GTF}
    */
    static from_args(ra, rb, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        const ret = wasm$1.gtf_from_args(ptr0, ptr1, args);
        return GTF.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} arg
    * @param {Imm12} selector
    */
    constructor(dst, arg, selector) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        _assertClass(selector, Imm12);
        var ptr2 = selector.__destroy_into_raw();
        const ret = wasm$1.gtf_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const Imm06Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm06_free(ptr >>> 0));
/**
* Represents a 6-bit immediate value, guaranteed to be masked by construction.
*/
class Imm06 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm06.prototype);
        obj.__wbg_ptr = ptr;
        Imm06Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm06Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm06_free(ptr);
    }
}

const Imm12Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm12_free(ptr >>> 0));
/**
* Represents a 12-bit immediate value, guaranteed to be masked by construction.
*/
class Imm12 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm12.prototype);
        obj.__wbg_ptr = ptr;
        Imm12Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm12Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm12_free(ptr);
    }
}

const Imm18Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm18_free(ptr >>> 0));
/**
* Represents a 18-bit immediate value, guaranteed to be masked by construction.
*/
class Imm18 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm18.prototype);
        obj.__wbg_ptr = ptr;
        Imm18Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm18Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm18_free(ptr);
    }
}

const Imm24Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_imm24_free(ptr >>> 0));
/**
* Represents a 24-bit immediate value, guaranteed to be masked by construction.
*/
class Imm24 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Imm24.prototype);
        obj.__wbg_ptr = ptr;
        Imm24Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Imm24Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_imm24_free(ptr);
    }
}

const InstructionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_instruction_free(ptr >>> 0));
/**
* Representation of a single instruction for the interpreter.
*
* The opcode is represented in the tag (variant), or may be retrieved in the
* form of an `Opcode` byte using the `opcode` method.
*
* The register and immediate data associated with the instruction is represented
* within an inner unit type wrapper around the 3 remaining bytes.
*/
class Instruction {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Instruction.prototype);
        obj.__wbg_ptr = ptr;
        InstructionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        InstructionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_instruction_free(ptr);
    }
    /**
    * Convenience method for converting to bytes
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.instruction_to_bytes(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm$1.__wbindgen_export_0(r0, r1 * 1, 1);
            return v1;
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Size of an instruction in bytes
    * @returns {number}
    */
    static size() {
        const ret = wasm$1.instruction_size();
        return ret >>> 0;
    }
}

const JIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ji_free(ptr >>> 0));
/**
*Jump.
*/
class JI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ji_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} abs_target
    */
    constructor(abs_target) {
        _assertClass(abs_target, Imm24);
        var ptr0 = abs_target.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const JMPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jmp_free(ptr >>> 0));
/**
*Dynamic jump.
*/
class JMP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JMPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmp_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} abs_target
    */
    constructor(abs_target) {
        _assertClass(abs_target, RegId);
        var ptr0 = abs_target.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const JMPBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jmpb_free(ptr >>> 0));
/**
*Unconditional dynamic relative jump backwards, with a constant offset.
*/
class JMPB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JMPBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmpb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dynamic
    * @param {Imm18} fixed
    */
    constructor(dynamic, fixed) {
        _assertClass(dynamic, RegId);
        var ptr0 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm18);
        var ptr1 = fixed.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const JMPFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jmpf_free(ptr >>> 0));
/**
*Unconditional dynamic relative jump forwards, with a constant offset.
*/
class JMPF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JMPFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jmpf_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dynamic
    * @param {Imm18} fixed
    */
    constructor(dynamic, fixed) {
        _assertClass(dynamic, RegId);
        var ptr0 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm18);
        var ptr1 = fixed.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const JNEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jne_free(ptr >>> 0));
/**
*Conditional dynamic jump.
*/
class JNE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jne_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} abs_target
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(abs_target, lhs, rhs) {
        _assertClass(abs_target, RegId);
        var ptr0 = abs_target.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const JNEBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jneb_free(ptr >>> 0));
/**
*Dynamic relative jump backwards, conditional on comparsion, with a constant offset.
*/
class JNEB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jneb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_lhs
    * @param {RegId} cond_rhs
    * @param {RegId} dynamic
    * @param {Imm06} fixed
    */
    constructor(cond_lhs, cond_rhs, dynamic, fixed) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr2 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm06);
        var ptr3 = fixed.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const JNEFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnef_free(ptr >>> 0));
/**
*Dynamic relative jump forwards, conditional on comparsion, with a constant offset.
*/
class JNEF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnef_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_lhs
    * @param {RegId} cond_rhs
    * @param {RegId} dynamic
    * @param {Imm06} fixed
    */
    constructor(cond_lhs, cond_rhs, dynamic, fixed) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr2 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm06);
        var ptr3 = fixed.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const JNEIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnei_free(ptr >>> 0));
/**
*Conditional jump.
*/
class JNEI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNEIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnei_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_lhs
    * @param {RegId} cond_rhs
    * @param {Imm12} abs_target
    */
    constructor(cond_lhs, cond_rhs, abs_target) {
        _assertClass(cond_lhs, RegId);
        var ptr0 = cond_lhs.__destroy_into_raw();
        _assertClass(cond_rhs, RegId);
        var ptr1 = cond_rhs.__destroy_into_raw();
        _assertClass(abs_target, Imm12);
        var ptr2 = abs_target.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JNZBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnzb_free(ptr >>> 0));
/**
*Dynamic relative jump backwards, conditional against zero, with a constant offset.
*/
class JNZB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNZBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_nz
    * @param {RegId} dynamic
    * @param {Imm12} fixed
    */
    constructor(cond_nz, dynamic, fixed) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr1 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm12);
        var ptr2 = fixed.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JNZFFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnzf_free(ptr >>> 0));
/**
*Dynamic relative jump forwards, conditional against zero, with a constant offset.
*/
class JNZF {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNZFFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzf_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_nz
    * @param {RegId} dynamic
    * @param {Imm12} fixed
    */
    constructor(cond_nz, dynamic, fixed) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(dynamic, RegId);
        var ptr1 = dynamic.__destroy_into_raw();
        _assertClass(fixed, Imm12);
        var ptr2 = fixed.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const JNZIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_jnzi_free(ptr >>> 0));
/**
*Conditional jump against zero.
*/
class JNZI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        JNZIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_jnzi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} cond_nz
    * @param {Imm18} abs_target
    */
    constructor(cond_nz, abs_target) {
        _assertClass(cond_nz, RegId);
        var ptr0 = cond_nz.__destroy_into_raw();
        _assertClass(abs_target, Imm18);
        var ptr1 = abs_target.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const K256Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_k256_free(ptr >>> 0));
/**
*The keccak-256 hash of a slice.
*/
class K256 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        K256Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_k256_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {RegId} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lb_free(ptr >>> 0));
/**
*A byte is loaded from the specified address offset by an immediate value.
*/
class LB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} addr
    * @param {Imm12} offset
    */
    constructor(dst, addr, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr1 = addr.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const LDCFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ldc_free(ptr >>> 0));
/**
*Load a contract's code as executable.
*/
class LDC {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LDCFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ldc_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} contract_id_addr
    * @param {RegId} offset
    * @param {RegId} len
    */
    constructor(contract_id_addr, offset, len) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(offset, RegId);
        var ptr1 = offset.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LOGFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_log_free(ptr >>> 0));
/**
*Log an event.
*/
class LOG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LOGFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_log_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} a
    * @param {RegId} b
    * @param {RegId} c
    * @param {RegId} d
    */
    constructor(a, b, c, d) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(c, RegId);
        var ptr2 = c.__destroy_into_raw();
        _assertClass(d, RegId);
        var ptr3 = d.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LOGDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_logd_free(ptr >>> 0));
/**
*Log data.
*/
class LOGD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LOGDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_logd_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} a
    * @param {RegId} b
    * @param {RegId} addr
    * @param {RegId} len
    */
    constructor(a, b, addr, len) {
        _assertClass(a, RegId);
        var ptr0 = a.__destroy_into_raw();
        _assertClass(b, RegId);
        var ptr1 = b.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr2 = addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lt_free(ptr >>> 0));
/**
*Compares two registers for less-than.
*/
class LT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lt_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const LWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_lw_free(ptr >>> 0));
/**
*A word is loaded from the specified address offset by an immediate value.
*/
class LW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_lw_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} addr
    * @param {Imm12} offset
    */
    constructor(dst, addr, offset) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(addr, RegId);
        var ptr1 = addr.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MCLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcl_free(ptr >>> 0));
/**
*Clear a variable number of bytes in memory.
*/
class MCL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcl_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} len
    */
    constructor(dst_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr1 = len.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MCLIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcli_free(ptr >>> 0));
/**
*Clear an immediate number of bytes in memory.
*/
class MCLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCLIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcli_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {Imm18} count
    */
    constructor(addr, count) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(count, Imm18);
        var ptr1 = count.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const MCPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcp_free(ptr >>> 0));
/**
*Copy a variable number of bytes in memory.
*/
class MCP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcp_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {RegId} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MCPIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mcpi_free(ptr >>> 0));
/**
*Copy an immediate number of bytes in memory.
*/
class MCPI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MCPIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mcpi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {Imm12} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, Imm12);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MEQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_meq_free(ptr >>> 0));
/**
*Compare bytes in memory.
*/
class MEQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MEQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_meq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} result
    * @param {RegId} lhs_addr
    * @param {RegId} rhs_addr
    * @param {RegId} len
    */
    constructor(result, lhs_addr, rhs_addr, len) {
        _assertClass(result, RegId);
        var ptr0 = result.__destroy_into_raw();
        _assertClass(lhs_addr, RegId);
        var ptr1 = lhs_addr.__destroy_into_raw();
        _assertClass(rhs_addr, RegId);
        var ptr2 = rhs_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr3 = len.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MINTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mint_free(ptr >>> 0));
/**
*Mints `amount` coins of the asset ID created from `sub_id` for the current contract.
*/
class MINT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MINTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mint_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} amount
    * @param {RegId} sub_id_addr
    */
    constructor(amount, sub_id_addr) {
        _assertClass(amount, RegId);
        var ptr0 = amount.__destroy_into_raw();
        _assertClass(sub_id_addr, RegId);
        var ptr1 = sub_id_addr.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MLDVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mldv_free(ptr >>> 0));
/**
*Fused multiply-divide with arbitrary precision intermediate step.
*/
class MLDV {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MLDVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mldv_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} divisor
    */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MLOGFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mlog_free(ptr >>> 0));
/**
*The integer logarithm of a register.
*/
class MLOG {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MLOGFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mlog_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MODFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mod_free(ptr >>> 0));
/**
*Modulo remainder of two registers.
*/
class MOD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MODFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mod_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MODIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_modi_free(ptr >>> 0));
/**
*Modulo remainder of a register and an immediate value.
*/
class MODI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MODIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_modi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MOVEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_move_free(ptr >>> 0));
/**
*Copy from one register to another.
*/
class MOVE {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MOVEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_move_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} src
    */
    constructor(dst, src) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(src, RegId);
        var ptr1 = src.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MOVIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_movi_free(ptr >>> 0));
/**
*Copy immediate value into a register
*/
class MOVI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MOVIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_movi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {Imm18} val
    */
    constructor(dst, val) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(val, Imm18);
        var ptr1 = val.__destroy_into_raw();
        const ret = wasm$1.jmpb_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 18-bit immediate value.
    * @returns {Imm18}
    */
    imm18() {
        const ret = wasm$1.gm_imm18(this.__wbg_ptr);
        return Imm18.__wrap(ret);
    }
}

const MROOFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mroo_free(ptr >>> 0));
/**
*The integer root of a register.
*/
class MROO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MROOFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mroo_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MULFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mul_free(ptr >>> 0));
/**
*Multiplies two registers.
*/
class MUL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MULFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mul_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const MULIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_muli_free(ptr >>> 0));
/**
*Multiplies a register and an immediate value.
*/
class MULI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MULIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_muli_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const MathArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mathargs_free(ptr >>> 0));
/**
* Additional arguments for WDOP and WQOP instructions.
*/
class MathArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MathArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mathargs_free(ptr);
    }
    /**
    * The operation to perform
    * @returns {MathOp}
    */
    get op() {
        const ret = wasm$1.__wbg_get_mathargs_op(this.__wbg_ptr);
        return ret;
    }
    /**
    * The operation to perform
    * @param {MathOp} arg0
    */
    set op(arg0) {
        wasm$1.__wbg_set_mathargs_op(this.__wbg_ptr, arg0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}

const MulArgsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_mulargs_free(ptr >>> 0));
/**
* Additional arguments for WDML and WQML instructions.
*/
class MulArgs {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MulArgsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_mulargs_free(ptr);
    }
    /**
    * Load LHSS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_lhs() {
        const ret = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load LHSS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_lhs(arg0) {
        wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @returns {boolean}
    */
    get indirect_rhs() {
        const ret = wasm$1.__wbg_get_mulargs_indirect_rhs(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Load RHS from register if true, otherwise zero-extend register value
    * @param {boolean} arg0
    */
    set indirect_rhs(arg0) {
        wasm$1.__wbg_set_mulargs_indirect_rhs(this.__wbg_ptr, arg0);
    }
}

const NOOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_noop_free(ptr >>> 0));
/**
*Performs no operation.
*/
class NOOP {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NOOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_noop_free(ptr);
    }
    /**
    * Construct the instruction.
    */
    constructor() {
        const ret = wasm$1.noop_new_typescript();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}

const NOTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_not_free(ptr >>> 0));
/**
*Bitwise NOT a register.
*/
class NOT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NOTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_not_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} arg
    */
    constructor(dst, arg) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(arg, RegId);
        var ptr1 = arg.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ORFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_or_free(ptr >>> 0));
/**
*Bitwise ORs two registers.
*/
class OR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ORFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_or_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const ORIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ori_free(ptr >>> 0));
/**
*Bitwise ORs a register and an immediate value.
*/
class ORI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ORIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ori_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const POPHFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_poph_free(ptr >>> 0));
/**
*Pop a bitmask-selected set of registers in range 40..64 to the stack.
*/
class POPH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        POPHFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_poph_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const POPLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_popl_free(ptr >>> 0));
/**
*Pop a bitmask-selected set of registers in range 16..40 to the stack.
*/
class POPL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        POPLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_popl_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const PSHHFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_pshh_free(ptr >>> 0));
/**
*Push a bitmask-selected set of registers in range 40..64 to the stack.
*/
class PSHH {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PSHHFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_pshh_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const PSHLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_pshl_free(ptr >>> 0));
/**
*Push a bitmask-selected set of registers in range 16..40 to the stack.
*/
class PSHL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PSHLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_pshl_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {Imm24} bitmask
    */
    constructor(bitmask) {
        _assertClass(bitmask, Imm24);
        var ptr0 = bitmask.__destroy_into_raw();
        const ret = wasm$1.cfei_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the 24-bit immediate value.
    * @returns {Imm24}
    */
    imm24() {
        const ret = wasm$1.cfei_imm24(this.__wbg_ptr);
        return Imm24.__wrap(ret);
    }
}

const PanicInstructionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_panicinstruction_free(ptr >>> 0));
/**
* Describe a panic reason with the instruction that generated it
*/
class PanicInstruction {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PanicInstructionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_panicinstruction_free(ptr);
    }
    /**
    * Represents an error described by a reason and an instruction.
    * @param {PanicReason} reason
    * @param {number} instruction
    */
    constructor(reason, instruction) {
        const ret = wasm$1.panicinstruction_error_typescript(reason, instruction);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Underlying panic reason
    * @returns {PanicReason}
    */
    reason() {
        const ret = wasm$1.panicinstruction_reason(this.__wbg_ptr);
        return ret;
    }
    /**
    * Underlying instruction
    * @returns {number}
    */
    instruction() {
        const ret = wasm$1.panicinstruction_instruction(this.__wbg_ptr);
        return ret >>> 0;
    }
}

const RETFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_ret_free(ptr >>> 0));
/**
*Return from context.
*/
class RET {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RETFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_ret_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} value
    */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const RETDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_retd_free(ptr >>> 0));
/**
*Return from context with data.
*/
class RETD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RETDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_retd_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {RegId} len
    */
    constructor(addr, len) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr1 = len.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const RVRTFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_rvrt_free(ptr >>> 0));
/**
*Halt execution, reverting state changes and returning a value.
*/
class RVRT {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RVRTFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_rvrt_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} value
    */
    constructor(value) {
        _assertClass(value, RegId);
        var ptr0 = value.__destroy_into_raw();
        const ret = wasm$1.aloc_new_typescript(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.aloc_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const RegIdFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_regid_free(ptr >>> 0));
/**
* Represents a 6-bit register ID, guaranteed to be masked by construction.
*/
class RegId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RegId.prototype);
        obj.__wbg_ptr = ptr;
        RegIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RegIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_regid_free(ptr);
    }
    /**
    * Construct a register ID from the given value.
    *
    * Returns `None` if the value is outside the 6-bit value range.
    * @param {number} u
    * @returns {RegId | undefined}
    */
    static new_checked(u) {
        const ret = wasm$1.regid_new_checked(u);
        return ret === 0 ? undefined : RegId.__wrap(ret);
    }
    /**
    * Received balance for this context.
    * @returns {RegId}
    */
    static bal() {
        const ret = wasm$1.regid_bal();
        return RegId.__wrap(ret);
    }
    /**
    * Remaining gas in the context.
    * @returns {RegId}
    */
    static cgas() {
        const ret = wasm$1.regid_cgas();
        return RegId.__wrap(ret);
    }
    /**
    * Error codes for particular operations.
    * @returns {RegId}
    */
    static err() {
        const ret = wasm$1.regid_err();
        return RegId.__wrap(ret);
    }
    /**
    * Flags register.
    * @returns {RegId}
    */
    static flag() {
        const ret = wasm$1.regid_flag();
        return RegId.__wrap(ret);
    }
    /**
    * Frame pointer. Memory address of beginning of current call frame.
    * @returns {RegId}
    */
    static fp() {
        const ret = wasm$1.regid_fp();
        return RegId.__wrap(ret);
    }
    /**
    * Remaining gas globally.
    * @returns {RegId}
    */
    static ggas() {
        const ret = wasm$1.regid_ggas();
        return RegId.__wrap(ret);
    }
    /**
    * Heap pointer. Memory address below the current bottom of the heap (points to free
    * memory).
    * @returns {RegId}
    */
    static hp() {
        const ret = wasm$1.regid_hp();
        return RegId.__wrap(ret);
    }
    /**
    * Instructions start. Pointer to the start of the currently-executing code.
    * @returns {RegId}
    */
    static is() {
        const ret = wasm$1.regid_is();
        return RegId.__wrap(ret);
    }
    /**
    * Contains overflow/underflow of addition, subtraction, and multiplication.
    * @returns {RegId}
    */
    static of() {
        const ret = wasm$1.regid_of();
        return RegId.__wrap(ret);
    }
    /**
    * Contains one (1), for convenience.
    * @returns {RegId}
    */
    static one() {
        const ret = wasm$1.regid_one();
        return RegId.__wrap(ret);
    }
    /**
    * The program counter. Memory address of the current instruction.
    * @returns {RegId}
    */
    static pc() {
        const ret = wasm$1.regid_pc();
        return RegId.__wrap(ret);
    }
    /**
    * Return value or pointer.
    * @returns {RegId}
    */
    static ret() {
        const ret = wasm$1.regid_ret();
        return RegId.__wrap(ret);
    }
    /**
    * Return value length in bytes.
    * @returns {RegId}
    */
    static retl() {
        const ret = wasm$1.regid_retl();
        return RegId.__wrap(ret);
    }
    /**
    * Stack pointer. Memory address on top of current writable stack area (points to
    * free memory).
    * @returns {RegId}
    */
    static sp() {
        const ret = wasm$1.regid_sp();
        return RegId.__wrap(ret);
    }
    /**
    * Stack start pointer. Memory address of bottom of current writable stack area.
    * @returns {RegId}
    */
    static spp() {
        const ret = wasm$1.regid_spp();
        return RegId.__wrap(ret);
    }
    /**
    * Smallest writable register.
    * @returns {RegId}
    */
    static writable() {
        const ret = wasm$1.regid_writable();
        return RegId.__wrap(ret);
    }
    /**
    * Contains zero (0), for convenience.
    * @returns {RegId}
    */
    static zero() {
        const ret = wasm$1.regid_zero();
        return RegId.__wrap(ret);
    }
    /**
    * Construct a register ID from the given value.
    *
    * The given value will be masked to 6 bits.
    * @param {number} u
    */
    constructor(u) {
        const ret = wasm$1.regid_new_typescript(u);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * A const alternative to the `Into<u8>` implementation.
    * @returns {number}
    */
    to_u8() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.regid_to_u8(ptr);
        return ret;
    }
}

const S256Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_s256_free(ptr >>> 0));
/**
*The SHA-2-256 hash of a slice.
*/
class S256 {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        S256Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_s256_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} src_addr
    * @param {RegId} len
    */
    constructor(dst_addr, src_addr, len) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr1 = src_addr.__destroy_into_raw();
        _assertClass(len, RegId);
        var ptr2 = len.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sb_free(ptr >>> 0));
/**
*Write the least significant byte of a register to memory.
*/
class SB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sb_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {RegId} value
    * @param {Imm12} offset
    */
    constructor(addr, value, offset) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr1 = value.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SCWQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_scwq_free(ptr >>> 0));
/**
*Clear a series of slots from contract storage.
*/
class SCWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SCWQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_scwq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} key_addr
    * @param {RegId} status
    * @param {RegId} lenq
    */
    constructor(key_addr, status, lenq) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr2 = lenq.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SLLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sll_free(ptr >>> 0));
/**
*Left shifts a register by a register.
*/
class SLL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SLLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sll_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SLLIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_slli_free(ptr >>> 0));
/**
*Left shifts a register by an immediate value.
*/
class SLLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SLLIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_slli_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SMOFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_smo_free(ptr >>> 0));
/**
*Send a message to recipient address with call abi, coins, and output.
*/
class SMO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SMOFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_smo_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} recipient_addr
    * @param {RegId} data_addr
    * @param {RegId} data_len
    * @param {RegId} coins
    */
    constructor(recipient_addr, data_addr, data_len, coins) {
        _assertClass(recipient_addr, RegId);
        var ptr0 = recipient_addr.__destroy_into_raw();
        _assertClass(data_addr, RegId);
        var ptr1 = data_addr.__destroy_into_raw();
        _assertClass(data_len, RegId);
        var ptr2 = data_len.__destroy_into_raw();
        _assertClass(coins, RegId);
        var ptr3 = coins.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SRLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srl_free(ptr >>> 0));
/**
*Right shifts a register by a register.
*/
class SRL {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srl_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SRLIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srli_free(ptr >>> 0));
/**
*Right shifts a register by an immediate value.
*/
class SRLI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRLIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srli_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SRWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srw_free(ptr >>> 0));
/**
*Load a word from contract storage.
*/
class SRW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srw_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} status
    * @param {RegId} key_addr
    */
    constructor(dst, status, key_addr) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(key_addr, RegId);
        var ptr2 = key_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SRWQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_srwq_free(ptr >>> 0));
/**
*Load a series of 32 byte slots from contract storage.
*/
class SRWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SRWQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_srwq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst_addr
    * @param {RegId} status
    * @param {RegId} key_addr
    * @param {RegId} lenq
    */
    constructor(dst_addr, status, key_addr, lenq) {
        _assertClass(dst_addr, RegId);
        var ptr0 = dst_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(key_addr, RegId);
        var ptr2 = key_addr.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr3 = lenq.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SUBFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sub_free(ptr >>> 0));
/**
*Subtracts two registers.
*/
class SUB {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SUBFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sub_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SUBIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_subi_free(ptr >>> 0));
/**
*Subtracts a register and an immediate value.
*/
class SUBI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SUBIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_subi_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sw_free(ptr >>> 0));
/**
*Write a register to memory.
*/
class SW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sw_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} addr
    * @param {RegId} value
    * @param {Imm12} offset
    */
    constructor(addr, value, offset) {
        _assertClass(addr, RegId);
        var ptr0 = addr.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr1 = value.__destroy_into_raw();
        _assertClass(offset, Imm12);
        var ptr2 = offset.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

const SWWFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_sww_free(ptr >>> 0));
/**
*Store a word in contract storage.
*/
class SWW {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SWWFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_sww_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} key_addr
    * @param {RegId} status
    * @param {RegId} value
    */
    constructor(key_addr, status, value) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(value, RegId);
        var ptr2 = value.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const SWWQFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_swwq_free(ptr >>> 0));
/**
*Store a series of 32 byte slots in contract storage.
*/
class SWWQ {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SWWQFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_swwq_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} key_addr
    * @param {RegId} status
    * @param {RegId} src_addr
    * @param {RegId} lenq
    */
    constructor(key_addr, status, src_addr, lenq) {
        _assertClass(key_addr, RegId);
        var ptr0 = key_addr.__destroy_into_raw();
        _assertClass(status, RegId);
        var ptr1 = status.__destroy_into_raw();
        _assertClass(src_addr, RegId);
        var ptr2 = src_addr.__destroy_into_raw();
        _assertClass(lenq, RegId);
        var ptr3 = lenq.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const TIMEFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_time_free(ptr >>> 0));
/**
*Get timestamp of block at given height.
*/
class TIME {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TIMEFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_time_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} heigth
    */
    constructor(dst, heigth) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(heigth, RegId);
        var ptr1 = heigth.__destroy_into_raw();
        const ret = wasm$1.bhsh_new_typescript(ptr0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const TRFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tr_free(ptr >>> 0));
/**
*Transfer coins to a contract unconditionally.
*/
class TR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TRFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tr_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} contract_id_addr
    * @param {RegId} amount
    * @param {RegId} asset_id_addr
    */
    constructor(contract_id_addr, amount, asset_id_addr) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(amount, RegId);
        var ptr1 = amount.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr2 = asset_id_addr.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const TROFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tro_free(ptr >>> 0));
/**
*Transfer coins to a variable output.
*/
class TRO {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TROFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tro_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} contract_id_addr
    * @param {RegId} output_index
    * @param {RegId} amount
    * @param {RegId} asset_id_addr
    */
    constructor(contract_id_addr, output_index, amount, asset_id_addr) {
        _assertClass(contract_id_addr, RegId);
        var ptr0 = contract_id_addr.__destroy_into_raw();
        _assertClass(output_index, RegId);
        var ptr1 = output_index.__destroy_into_raw();
        _assertClass(amount, RegId);
        var ptr2 = amount.__destroy_into_raw();
        _assertClass(asset_id_addr, RegId);
        var ptr3 = asset_id_addr.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDAMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdam_free(ptr >>> 0));
/**
*AddMod 128bit
*/
class WDAM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDAMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdam_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} add_lhs
    * @param {RegId} add_rhs
    * @param {RegId} modulo
    */
    constructor(dst, add_lhs, add_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(add_lhs, RegId);
        var ptr1 = add_lhs.__destroy_into_raw();
        _assertClass(add_rhs, RegId);
        var ptr2 = add_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDCMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdcm_free(ptr >>> 0));
/**
*Compare 128bit integers
*/
class WDCM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDCM.prototype);
        obj.__wbg_ptr = ptr;
        WDCMFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDCMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdcm_free(ptr);
    }
    /**
    * Construct a `WDCM` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {CompareArgs} args
    * @returns {WDCM}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, CompareArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDCM.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WDDVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wddv_free(ptr >>> 0));
/**
*Divide 128bit
*/
class WDDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDDV.prototype);
        obj.__wbg_ptr = ptr;
        WDDVFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDDVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wddv_free(ptr);
    }
    /**
    * Construct a `WDDV` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {DivArgs} args
    * @returns {WDDV}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, DivArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDDV.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WDMDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdmd_free(ptr >>> 0));
/**
*Fused multiply-divide 128bit
*/
class WDMD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDMDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdmd_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} divisor
    */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDMLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdml_free(ptr >>> 0));
/**
*Multiply 128bit
*/
class WDML {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDML.prototype);
        obj.__wbg_ptr = ptr;
        WDMLFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDMLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdml_free(ptr);
    }
    /**
    * Construct a `WDML` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MulArgs} args
    * @returns {WDML}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MulArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDML.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WDMMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdmm_free(ptr >>> 0));
/**
*MulMod 128bit
*/
class WDMM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDMMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdmm_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} modulo
    */
    constructor(dst, mul_lhs, mul_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WDOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wdop_free(ptr >>> 0));
/**
*Simple 128bit operations
*/
class WDOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WDOP.prototype);
        obj.__wbg_ptr = ptr;
        WDOPFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WDOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wdop_free(ptr);
    }
    /**
    * Construct a `WDOP` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MathArgs} args
    * @returns {WDOP}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
        return WDOP.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQAMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqam_free(ptr >>> 0));
/**
*AddMod 256bit
*/
class WQAM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQAMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqam_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} add_lhs
    * @param {RegId} add_rhs
    * @param {RegId} modulo
    */
    constructor(dst, add_lhs, add_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(add_lhs, RegId);
        var ptr1 = add_lhs.__destroy_into_raw();
        _assertClass(add_rhs, RegId);
        var ptr2 = add_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WQCMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqcm_free(ptr >>> 0));
/**
*Compare 256bit integers
*/
class WQCM {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQCM.prototype);
        obj.__wbg_ptr = ptr;
        WQCMFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQCMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqcm_free(ptr);
    }
    /**
    * Construct a `WQCM` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {CompareArgs} args
    * @returns {WQCM}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, CompareArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQCM.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQDVFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqdv_free(ptr >>> 0));
/**
*Divide 256bit
*/
class WQDV {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQDV.prototype);
        obj.__wbg_ptr = ptr;
        WQDVFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQDVFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqdv_free(ptr);
    }
    /**
    * Construct a `WQDV` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {DivArgs} args
    * @returns {WQDV}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, DivArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQDV.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQMDFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqmd_free(ptr >>> 0));
/**
*Fused multiply-divide 256bit
*/
class WQMD {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQMDFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqmd_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} divisor
    */
    constructor(dst, mul_lhs, mul_rhs, divisor) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(divisor, RegId);
        var ptr3 = divisor.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WQMLFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqml_free(ptr >>> 0));
/**
*Multiply 256bit
*/
class WQML {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQML.prototype);
        obj.__wbg_ptr = ptr;
        WQMLFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQMLFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqml_free(ptr);
    }
    /**
    * Construct a `WQML` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MulArgs} args
    * @returns {WQML}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MulArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQML.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const WQMMFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqmm_free(ptr >>> 0));
/**
*MulMod 256bit
*/
class WQMM {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQMMFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqmm_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} mul_lhs
    * @param {RegId} mul_rhs
    * @param {RegId} modulo
    */
    constructor(dst, mul_lhs, mul_rhs, modulo) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(mul_lhs, RegId);
        var ptr1 = mul_lhs.__destroy_into_raw();
        _assertClass(mul_rhs, RegId);
        var ptr2 = mul_rhs.__destroy_into_raw();
        _assertClass(modulo, RegId);
        var ptr3 = modulo.__destroy_into_raw();
        const ret = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register D.
    * @returns {RegId}
    */
    rd() {
        const ret = wasm$1.call_rd(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const WQOPFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wqop_free(ptr >>> 0));
/**
*Simple 256bit operations
*/
class WQOP {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WQOP.prototype);
        obj.__wbg_ptr = ptr;
        WQOPFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WQOPFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wqop_free(ptr);
    }
    /**
    * Construct a `WQOP` instruction from its arguments.
    * @param {RegId} ra
    * @param {RegId} rb
    * @param {RegId} rc
    * @param {MathArgs} args
    * @returns {WQOP}
    */
    static from_args(ra, rb, rc, args) {
        _assertClass(ra, RegId);
        var ptr0 = ra.__destroy_into_raw();
        _assertClass(rb, RegId);
        var ptr1 = rb.__destroy_into_raw();
        _assertClass(rc, RegId);
        var ptr2 = rc.__destroy_into_raw();
        _assertClass(args, MathArgs);
        var ptr3 = args.__destroy_into_raw();
        const ret = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
        return WQOP.__wrap(ret);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    * @param {Imm06} flags
    */
    constructor(dst, lhs, rhs, flags) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        _assertClass(flags, Imm06);
        var ptr3 = flags.__destroy_into_raw();
        const ret = wasm$1.wdcm_new_typescript(ptr0, ptr1, ptr2, ptr3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 6-bit immediate value.
    * @returns {Imm06}
    */
    imm06() {
        const ret = wasm$1.jneb_imm06(this.__wbg_ptr);
        return Imm06.__wrap(ret);
    }
}

const XORFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_xor_free(ptr >>> 0));
/**
*Bitwise XORs two registers.
*/
class XOR {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XORFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_xor_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {RegId} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, RegId);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register C.
    * @returns {RegId}
    */
    rc() {
        const ret = wasm$1.add_rc(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
}

const XORIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_xori_free(ptr >>> 0));
/**
*Bitwise XORs a register and an immediate value.
*/
class XORI {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XORIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_xori_free(ptr);
    }
    /**
    * Construct the instruction from its parts.
    * @param {RegId} dst
    * @param {RegId} lhs
    * @param {Imm12} rhs
    */
    constructor(dst, lhs, rhs) {
        _assertClass(dst, RegId);
        var ptr0 = dst.__destroy_into_raw();
        _assertClass(lhs, RegId);
        var ptr1 = lhs.__destroy_into_raw();
        _assertClass(rhs, Imm12);
        var ptr2 = rhs.__destroy_into_raw();
        const ret = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Access the ID for register A.
    * @returns {RegId}
    */
    ra() {
        const ret = wasm$1.add_ra(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the ID for register B.
    * @returns {RegId}
    */
    rb() {
        const ret = wasm$1.add_rb(this.__wbg_ptr);
        return RegId.__wrap(ret);
    }
    /**
    * Access the 12-bit immediate value.
    * @returns {Imm12}
    */
    imm12() {
        const ret = wasm$1.addi_imm12(this.__wbg_ptr);
        return Imm12.__wrap(ret);
    }
}

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };

    return imports;
}

function __wbg_finalize_init(instance, module) {
    wasm$1 = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedInt32Memory0 = null;
    cachedUint8Memory0 = null;


    return wasm$1;
}

function initSync(module) {
    if (wasm$1 !== undefined) return wasm$1;

    const imports = __wbg_get_imports();

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return __wbg_finalize_init(instance, module);
}

async function __wbg_init(input) {
    if (wasm$1 !== undefined) return wasm$1;
    const imports = __wbg_get_imports();

    const { instance, module } = await __wbg_load(await input, imports);

    return __wbg_finalize_init(instance, module);
}

function _loadWasmModule (sync, filepath, src, imports) {
  function _instantiateOrCompile(source, imports, stream) {
    var instantiateFunc = stream ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
    var compileFunc = stream ? WebAssembly.compileStreaming : WebAssembly.compile;

    if (imports) {
      return instantiateFunc(source, imports)
    } else {
      return compileFunc(source)
    }
  }

  
var buf = null;
var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
if (isNode) {
  
buf = Buffer.from(src, 'base64');

} else {
  
var raw = globalThis.atob(src);
var rawLength = raw.length;
buf = new Uint8Array(new ArrayBuffer(rawLength));
for(var i = 0; i < rawLength; i++) {
   buf[i] = raw.charCodeAt(i);
}

}


  if(sync) {
    var mod = new WebAssembly.Module(buf);
    return imports ? new WebAssembly.Instance(mod, imports) : mod
  } else {
    return _instantiateOrCompile(buf, imports, false)
  }
}

function wasm(imports){return _loadWasmModule(1, null, 'AGFzbQEAAAABQAtgA39/fwF/YAF/AX9gBH9/f38Bf2ACf38Bf2AAAX9gAn9/AGABfwBgBX9/f39/AX9gA39/fwBgAABgAn5/AX8CGAEDd2JnEF9fd2JpbmRnZW5fdGhyb3cABQP7AfkBAQMKBgEFBQUBBQEBAQEBAQECBQICAQEDAgICAgUCAwMDAwMDAwIBBQEFAAMDAwMDAwMDAwMDAQABAQUFAQEBAQEBAQEBAQIBBQUFAwIBAAABAQEFAgIBAQYABgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGAwcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEDBgADAQEBBwICAAIABgEEAwEDBQgBCQkDAwMFAQEBBgYGBgQEBAQEBAQEBAQEBAQEBAQEBAQGBwcCAgIDBwcACAADBAUBcAEHBwUDAQARBgkBfwFBgIDAAAsHxEvBBQZtZW1vcnkCABZfX3diZ19jb21wYXJlYXJnc19mcmVlAHcaX193YmdfZ2V0X2NvbXBhcmVhcmdzX21vZGUAORpfX3diZ19zZXRfY29tcGFyZWFyZ3NfbW9kZQAoIl9fd2JnX2dldF9jb21wYXJlYXJnc19pbmRpcmVjdF9yaHMAOiJfX3diZ19zZXRfY29tcGFyZWFyZ3NfaW5kaXJlY3RfcmhzADsSY29tcGFyZWFyZ3NfdG9faW1tAEgUY29tcGFyZWFyZ3NfZnJvbV9pbW0AKRVfX3diZ19nZXRfbWF0aGFyZ3Nfb3AAORVfX3diZ19zZXRfbWF0aGFyZ3Nfb3AAKhJfX3diZ19tdWxhcmdzX2ZyZWUAeB5fX3diZ19nZXRfbXVsYXJnc19pbmRpcmVjdF9yaHMAOR5fX3diZ19zZXRfbXVsYXJnc19pbmRpcmVjdF9yaHMAPBJfX3diZ19kaXZhcmdzX2ZyZWUA1gEeX193YmdfZ2V0X2RpdmFyZ3NfaW5kaXJlY3RfcmhzAK0BIXBhbmljaW5zdHJ1Y3Rpb25fZXJyb3JfdHlwZXNjcmlwdABMF3BhbmljaW5zdHJ1Y3Rpb25fcmVhc29uAD4ccGFuaWNpbnN0cnVjdGlvbl9pbnN0cnVjdGlvbgA/DGdtX2Zyb21fYXJncwDJAQ1ndGZfZnJvbV9hcmdzAMEBB2dtX2FyZ3MAeQhndGZfYXJncwBaDndkY21fZnJvbV9hcmdzACYOd2RvcF9mcm9tX2FyZ3MAJg53ZG1sX2Zyb21fYXJncwAeDndkZHZfZnJvbV9hcmdzAL8BCXdkY21fYXJncwAZCXdxY21fYXJncwAaCXdkb3BfYXJncwAbCXdxb3BfYXJncwAcCXdkbWxfYXJncwAUCXdxbWxfYXJncwAVCXdkZHZfYXJncwBVCXdxZHZfYXJncwBWEF9fd2JnX2ltbTA2X2ZyZWUA1wEQX193YmdfaW1tMTJfZnJlZQDYARBfX3diZ19pbW0xOF9mcmVlANkBDl9fd2JnX2FkZF9mcmVlALgBD19fd2JnX25vb3BfZnJlZQBbEmFkZF9uZXdfdHlwZXNjcmlwdABPBmFkZF9yYQAWBmFkZF9yYgALBmFkZF9yYwAPA2FkZAC5AQNhbmQAewNkaXYAfAJlcQB9A2V4cAB+Amd0AH8CbHQAgAEEbWxvZwCBAQRtcm9vAIIBBG1vZF8AgwEFbW92ZV8ALANtdWwAhAEDbm90AC0Cb3IAhQEDc2xsAIYBA3NybACHAQNzdWIAiAEDeG9yAIkBBG1sZHYAXANyZXQArgEEcmV0ZAAuE2Fsb2NfbmV3X3R5cGVzY3JpcHQAVwdhbG9jX3JhAE4EYWxvYwCvAQNtY2wALwNtY3AAigEDbWVxAF0TYmhzaF9uZXdfdHlwZXNjcmlwdAAfBGJoc2gAMARiaGVpALABBGJ1cm4AMRNjYWxsX25ld190eXBlc2NyaXB0AE0HY2FsbF9yZAAXBGNhbGwAXgNjY3AAXwRjcm9vADIEY3NpegAzAmNiALEBA2xkYwCLAQNsb2cAYARsb2dkAGEEbWludAA0BHJ2cnQAsgEEc2N3cQCMAQNzcncAjQEEc3J3cQBiA3N3dwCOAQRzd3dxAGMCdHIAjwEDdHJvAGQEZWNrMQCQAQRlY3IxAJEBBGVkMTkAkgEEazI1NgCTAQRzMjU2AJQBBHRpbWUANRNub29wX25ld190eXBlc2NyaXB0AMYBBG5vb3AA2gEEZmxhZwCzAQNiYWwAlQEDam1wALQBA2puZQCWAQNzbW8AZRNhZGRpX25ld190eXBlc2NyaXB0AFAKYWRkaV9pbW0xMgAMBGFkZGkAlwEEYW5kaQCYAQRkaXZpAJkBBGV4cGkAmgEEbW9kaQCbAQRtdWxpAJwBA29yaQCdAQRzbGxpAJ4BBHNybGkAnwEEc3ViaQCgAQR4b3JpAKEBBGpuZWkAogECbGIAowECbHcApAECc2IApQECc3cApgEEbWNwaQCnARJndGZfbmV3X3R5cGVzY3JpcHQAwwEDZ3RmAKgBBG1jbGkAIBFnbV9uZXdfdHlwZXNjcmlwdAA2CGdtX2ltbTE4AAkCZ20AIQRtb3ZpACIEam56aQAjBGptcGYAJBNqbXBiX25ld190eXBlc2NyaXB0ABgEam1wYgAlBGpuemYAqQEEam56YgCqAQRqbmVmAGYKam5lYl9pbW0wNgAXBGpuZWIAZwJqaQBAE2NmZWlfbmV3X3R5cGVzY3JpcHQANwpjZmVpX2ltbTI0ACcEY2ZlaQBBBGNmc2kAQgNjZmUAtQEDY2ZzALYBBHBzaGwAQwRwc2hoAEQEcG9wbABFBHBvcGgARhN3ZGNtX25ld190eXBlc2NyaXB0AMABBHdkY20AaAR3cWNtAGkEd2RvcABqBHdxb3AAawR3ZG1sAGwEd3FtbABtBHdkZHYAbgR3cWR2AG8Ed2RtZABwBHdxbWQAcQR3ZGFtAHIEd3FhbQBzBHdkbW0AdAR3cW1tAHUEZWNhbAB2Fl9fd2JnX2luc3RydWN0aW9uX2ZyZWUAWRRpbnN0cnVjdGlvbl90b19ieXRlcwAKEGluc3RydWN0aW9uX3NpemUA7AERcmVnaWRfbmV3X2NoZWNrZWQAqwEJcmVnaWRfYmFsANsBCnJlZ2lkX2NnYXMA3AEJcmVnaWRfZXJyAN0BCnJlZ2lkX2ZsYWcA3gEIcmVnaWRfZnAA3wEKcmVnaWRfZ2dhcwDgAQhyZWdpZF9ocADhAQhyZWdpZF9pcwDiAQhyZWdpZF9vZgDjAQlyZWdpZF9vbmUA5AEIcmVnaWRfcGMA5QEJcmVnaWRfcmV0AOYBCnJlZ2lkX3JldGwA5wEIcmVnaWRfc3AA6AEJcmVnaWRfc3BwAOkBDnJlZ2lkX3dyaXRhYmxlAOoBCnJlZ2lkX3plcm8A6wEUcmVnaWRfbmV3X3R5cGVzY3JpcHQA0wELcmVnaWRfdG9fdTgA1AETbW92aV9uZXdfdHlwZXNjcmlwdAAYE21jbGlfbmV3X3R5cGVzY3JpcHQAGBNqbnppX25ld190eXBlc2NyaXB0ABgTam1wZl9uZXdfdHlwZXNjcmlwdAAYEm5vdF9uZXdfdHlwZXNjcmlwdAAfE3JldGRfbmV3X3R5cGVzY3JpcHQAHxNtb3ZlX25ld190eXBlc2NyaXB0AB8SbWNsX25ld190eXBlc2NyaXB0AB8TYnVybl9uZXdfdHlwZXNjcmlwdAAfE2Nyb29fbmV3X3R5cGVzY3JpcHQAHxNjc2l6X25ld190eXBlc2NyaXB0AB8TbWludF9uZXdfdHlwZXNjcmlwdAAfE3RpbWVfbmV3X3R5cGVzY3JpcHQAHxJyZXRfbmV3X3R5cGVzY3JpcHQAVxNiaGVpX25ld190eXBlc2NyaXB0AFcRY2JfbmV3X3R5cGVzY3JpcHQAVxNydnJ0X25ld190eXBlc2NyaXB0AFcTZmxhZ19uZXdfdHlwZXNjcmlwdABXEmptcF9uZXdfdHlwZXNjcmlwdABXEmNmZV9uZXdfdHlwZXNjcmlwdABXEmNmc19uZXdfdHlwZXNjcmlwdABXE21sZHZfbmV3X3R5cGVzY3JpcHQATRJtZXFfbmV3X3R5cGVzY3JpcHQATRJjY3BfbmV3X3R5cGVzY3JpcHQATRJsb2dfbmV3X3R5cGVzY3JpcHQATRNsb2dkX25ld190eXBlc2NyaXB0AE0Tc3J3cV9uZXdfdHlwZXNjcmlwdABNE3N3d3FfbmV3X3R5cGVzY3JpcHQATRJ0cm9fbmV3X3R5cGVzY3JpcHQATRJzbW9fbmV3X3R5cGVzY3JpcHQATRNqbmVmX25ld190eXBlc2NyaXB0AE0Td2RtZF9uZXdfdHlwZXNjcmlwdABNE3dxbWRfbmV3X3R5cGVzY3JpcHQATRN3ZGFtX25ld190eXBlc2NyaXB0AE0Td3FhbV9uZXdfdHlwZXNjcmlwdABNE3dkbW1fbmV3X3R5cGVzY3JpcHQATRN3cW1tX25ld190eXBlc2NyaXB0AE0TZWNhbF9uZXdfdHlwZXNjcmlwdABNEmFuZF9uZXdfdHlwZXNjcmlwdABPEmRpdl9uZXdfdHlwZXNjcmlwdABPEWVxX25ld190eXBlc2NyaXB0AE8SZXhwX25ld190eXBlc2NyaXB0AE8RZ3RfbmV3X3R5cGVzY3JpcHQATxFsdF9uZXdfdHlwZXNjcmlwdABPE21sb2dfbmV3X3R5cGVzY3JpcHQATxNtcm9vX25ld190eXBlc2NyaXB0AE8SbW9kX25ld190eXBlc2NyaXB0AE8SbXVsX25ld190eXBlc2NyaXB0AE8Rb3JfbmV3X3R5cGVzY3JpcHQATxJzbGxfbmV3X3R5cGVzY3JpcHQATxJzcmxfbmV3X3R5cGVzY3JpcHQATxJzdWJfbmV3X3R5cGVzY3JpcHQATxJ4b3JfbmV3X3R5cGVzY3JpcHQATxJtY3BfbmV3X3R5cGVzY3JpcHQATxJsZGNfbmV3X3R5cGVzY3JpcHQATxNzY3dxX25ld190eXBlc2NyaXB0AE8Sc3J3X25ld190eXBlc2NyaXB0AE8Sc3d3X25ld190eXBlc2NyaXB0AE8RdHJfbmV3X3R5cGVzY3JpcHQATxNlY2sxX25ld190eXBlc2NyaXB0AE8TZWNyMV9uZXdfdHlwZXNjcmlwdABPE2VkMTlfbmV3X3R5cGVzY3JpcHQATxNrMjU2X25ld190eXBlc2NyaXB0AE8TczI1Nl9uZXdfdHlwZXNjcmlwdABPEmJhbF9uZXdfdHlwZXNjcmlwdABPEmpuZV9uZXdfdHlwZXNjcmlwdABPE2FuZGlfbmV3X3R5cGVzY3JpcHQAUBNkaXZpX25ld190eXBlc2NyaXB0AFATZXhwaV9uZXdfdHlwZXNjcmlwdABQE21vZGlfbmV3X3R5cGVzY3JpcHQAUBNtdWxpX25ld190eXBlc2NyaXB0AFASb3JpX25ld190eXBlc2NyaXB0AFATc2xsaV9uZXdfdHlwZXNjcmlwdABQE3NybGlfbmV3X3R5cGVzY3JpcHQAUBNzdWJpX25ld190eXBlc2NyaXB0AFATeG9yaV9uZXdfdHlwZXNjcmlwdABQE2puZWlfbmV3X3R5cGVzY3JpcHQAUBFsYl9uZXdfdHlwZXNjcmlwdABQEWx3X25ld190eXBlc2NyaXB0AFARc2JfbmV3X3R5cGVzY3JpcHQAUBFzd19uZXdfdHlwZXNjcmlwdABQE21jcGlfbmV3X3R5cGVzY3JpcHQAUBNqbnpmX25ld190eXBlc2NyaXB0AFATam56Yl9uZXdfdHlwZXNjcmlwdABQDndxY21fZnJvbV9hcmdzACYOd3FvcF9mcm9tX2FyZ3MAJh9fX3diZ19zZXRfbWF0aGFyZ3NfaW5kaXJlY3RfcmhzADseX193Ymdfc2V0X211bGFyZ3NfaW5kaXJlY3RfbGhzADseX193Ymdfc2V0X2RpdmFyZ3NfaW5kaXJlY3RfcmhzADsRamlfbmV3X3R5cGVzY3JpcHQANxNjZnNpX25ld190eXBlc2NyaXB0ADcTcHNobF9uZXdfdHlwZXNjcmlwdAA3E3BzaGhfbmV3X3R5cGVzY3JpcHQANxNwb3BsX25ld190eXBlc2NyaXB0ADcTcG9waF9uZXdfdHlwZXNjcmlwdAA3E3dxb3BfbmV3X3R5cGVzY3JpcHQAwAETd2Rkdl9uZXdfdHlwZXNjcmlwdADAARN3ZG1sX25ld190eXBlc2NyaXB0AMABE3dxY21fbmV3X3R5cGVzY3JpcHQAwAETd3Fkdl9uZXdfdHlwZXNjcmlwdADAAQ53cWR2X2Zyb21fYXJncwC/ARN3ZG9wX25ld190eXBlc2NyaXB0AMABDndxbWxfZnJvbV9hcmdzAB4Td3FtbF9uZXdfdHlwZXNjcmlwdADAARBfX3diZ19yZWdpZF9mcmVlANcBEF9fd2JnX2ltbTI0X2ZyZWUA2QEOX193YmdfbXVsX2ZyZWUAuAEPX193Ymdfam5lYl9mcmVlALgBDl9fd2JnX21jbF9mcmVlALgBDV9fd2JnX2xiX2ZyZWUAuAEKcHNobF9pbW0yNAAnD19fd2JnX3BzaGxfZnJlZQC4AQ9fX3diZ19tdWxpX2ZyZWUAuAEPX193YmdfZXhwaV9mcmVlALgBD19fd2JnX3dkbWRfZnJlZQC4AQ5fX3diZ19tb2RfZnJlZQC4AQ1fX3diZ19vcl9mcmVlALgBD19fd2JnX2Nmc2lfZnJlZQC4AQ9fX3diZ194b3JpX2ZyZWUAuAEPX193YmdfbW92aV9mcmVlALgBD19fd2JnX2puZWZfZnJlZQC4AQ9fX3diZ19zcmxpX2ZyZWUAuAEPX193YmdfbWxvZ19mcmVlALgBDV9fd2JnX3N3X2ZyZWUAuAEPX193YmdfbWNsaV9mcmVlALgBD19fd2JnX2NhbGxfZnJlZQC4AQ9fX3diZ19iaHNoX2ZyZWUAuAEPX193YmdfazI1Nl9mcmVlALgBD19fd2JnX2J1cm5fZnJlZQC4AQ9fX3diZ19qbnppX2ZyZWUAuAEPX193YmdfZWQxOV9mcmVlALgBD19fd2JnX3dkYW1fZnJlZQC4AQ9fX3diZ19hbmRpX2ZyZWUAuAENX193Ymdfc2JfZnJlZQC4AQpwb3BsX2ltbTI0ACcPX193YmdfcG9wbF9mcmVlALgBDl9fd2JnX3Nyd19mcmVlALgBD19fd2JnX3dxbW1fZnJlZQC4AQ9fX3diZ193ZGR2X2ZyZWUAuAEPX193Ymdfam1wYl9mcmVlALgBDl9fd2JnX2puZV9mcmVlALgBBmNmZV9yYQBODl9fd2JnX2NmZV9mcmVlALgBD19fd2JnX2Fsb2NfZnJlZQC4AQ9fX3diZ19zMjU2X2ZyZWUAuAEPX193YmdfbXJvb19mcmVlALgBDV9fd2JnX2x0X2ZyZWUAuAEOX193YmdfZGl2X2ZyZWUAuAEPX193Ymdfd3FvcF9mcmVlALgBDV9fd2JnX3RyX2ZyZWUAuAEPX193YmdfcmV0ZF9mcmVlALgBDV9fd2JnX2x3X2ZyZWUAuAEPX193Ymdfd2RtbV9mcmVlALgBB2ZsYWdfcmEATg9fX3diZ19mbGFnX2ZyZWUAuAENX193YmdfZ3RfZnJlZQC4AQZyZXRfcmEATg5fX3diZ19yZXRfZnJlZQC4AQ1fX3diZ19lcV9mcmVlALgBDl9fd2JnX21lcV9mcmVlALgBHl9fd2JnX2dldF9tdWxhcmdzX2luZGlyZWN0X2xocwA6Dl9fd2JnX3Ntb19mcmVlALgBCGppX2ltbTI0ACcNX193YmdfamlfZnJlZQC4AQ5fX3diZ19zcmxfZnJlZQC4AQ5fX3diZ19zbGxfZnJlZQC4AQ9fX3diZ190aW1lX2ZyZWUAuAEPX193Ymdfc2N3cV9mcmVlALgBD19fd2JnX3dxbWxfZnJlZQC4AQ9fX3diZ19kaXZpX2ZyZWUAuAEOX193YmdfbWNwX2ZyZWUAuAEOX193Ymdfbm90X2ZyZWUAuAEGam1wX3JhAE4OX193Ymdfam1wX2ZyZWUAuAEOX193YmdfYmFsX2ZyZWUAuAEPX193YmdfbG9nZF9mcmVlALgBB2JoZWlfcmEATg9fX3diZ19iaGVpX2ZyZWUAuAEPX193Ymdfam5laV9mcmVlALgBD19fd2JnX2ptcGZfZnJlZQC4AQ9fX3diZ19qbnpmX2ZyZWUAuAEfX193YmdfZ2V0X21hdGhhcmdzX2luZGlyZWN0X3JocwA6D19fd2JnX21vZGlfZnJlZQC4AQ5fX3diZ19vcmlfZnJlZQC4AQ9fX3diZ19lY2sxX2ZyZWUAuAEPX193YmdfZWNhbF9mcmVlALgBD19fd2JnX3Nyd3FfZnJlZQC4AQ5fX3diZ194b3JfZnJlZQC4AQ9fX3diZ19jc2l6X2ZyZWUAuAEPX193YmdfbWludF9mcmVlALgBBmNmc19yYQBODl9fd2JnX2Nmc19mcmVlALgBD19fd2JnX3NsbGlfZnJlZQC4AQ5fX3diZ19sb2dfZnJlZQC4AQ9fX3diZ19tb3ZlX2ZyZWUAuAEOX193YmdfbGRjX2ZyZWUAuAEPX193Ymdfd2RtbF9mcmVlALgBDV9fd2JnX2dtX2ZyZWUAuAEPX193Ymdfd2RjbV9mcmVlALgBD19fd2JnX3N1YmlfZnJlZQC4AQ5fX3diZ190cm9fZnJlZQC4AQ5fX3diZ19ndGZfZnJlZQC4AQdydnJ0X3JhAE4PX193YmdfcnZydF9mcmVlALgBDl9fd2JnX2V4cF9mcmVlALgBD19fd2JnX3dxYW1fZnJlZQC4AQ9fX3diZ193cWR2X2ZyZWUAuAEKcHNoaF9pbW0yNAAnD19fd2JnX3BzaGhfZnJlZQC4AQ9fX3diZ19hZGRpX2ZyZWUAuAEPX193Ymdfd3FtZF9mcmVlALgBD19fd2JnX2VjcjFfZnJlZQC4AQ9fX3diZ19jcm9vX2ZyZWUAuAEKY2ZzaV9pbW0yNAAnD19fd2JnX2NmZWlfZnJlZQC4AQ9fX3diZ19tY3BpX2ZyZWUAuAEPX193Ymdfd2RvcF9mcmVlALgBDl9fd2JnX3N1Yl9mcmVlALgBD19fd2JnX2puemJfZnJlZQC4AQVjYl9yYQBODV9fd2JnX2NiX2ZyZWUAuAEOX193Ymdfc3d3X2ZyZWUAuAEPX193Ymdfc3d3cV9mcmVlALgBD19fd2JnX21sZHZfZnJlZQC4AQ5fX3diZ19jY3BfZnJlZQC4AQ9fX3diZ193cWNtX2ZyZWUAuAEKcG9waF9pbW0yNAAnD19fd2JnX3BvcGhfZnJlZQC4AQ5fX3diZ19hbmRfZnJlZQC4AQpqbXBmX2ltbTE4AAkKam56aV9pbW0xOAAJCm1vdmlfaW1tMTgACQpqbXBiX2ltbTE4AAkKbWNsaV9pbW0xOAAJE2puZWJfbmV3X3R5cGVzY3JpcHQATQp3cWR2X2ltbTA2ABcKd3FtbF9pbW0wNgAXCndkbWxfaW1tMDYAFwp3cW9wX2ltbTA2ABcKd2RvcF9pbW0wNgAXCndxY21faW1tMDYAFwp3ZGR2X2ltbTA2ABcKd2RjbV9pbW0wNgAXCmpuZWZfaW1tMDYAFwZtdWxfcmMADwZtdWxfcmIACwZtdWxfcmEAFgZtY2xfcmIACwZtY2xfcmEAFgdtdWxpX3JiAAsHbXVsaV9yYQAWCm11bGlfaW1tMTIADAdqbmViX3JiAAsHam5lYl9yYQAWB3dkbWRfcmMADwd3ZG1kX3JiAAsHd2RtZF9yYQAWBm1vZF9yYwAPBm1vZF9yYgALBm1vZF9yYQAWBW9yX3JjAA8Fb3JfcmIACwVvcl9yYQAWCmV4cGlfaW1tMTIADAdleHBpX3JiAAsHZXhwaV9yYQAWCnhvcmlfaW1tMTIADAd4b3JpX3JiAAsHeG9yaV9yYQAWB21vdmlfcmEAFgdqbmVmX3JjAA8Ham5lZl9yYgALB2puZWZfcmEAFgpzcmxpX2ltbTEyAAwHc3JsaV9yYgALB3NybGlfcmEAFgdtbG9nX3JjAA8HbWxvZ19yYgALB21sb2dfcmEAFghzd19pbW0xMgAMBXN3X3JiAAsFc3dfcmEAFgdtY2xpX3JhABYHd2RtZF9yZAAXB2puZWJfcmMADwdjYWxsX3JiAAsHY2FsbF9yYQAWB2Joc2hfcmIACwdiaHNoX3JhABYHazI1Nl9yYwAPB2syNTZfcmIACwdrMjU2X3JhABYHYnVybl9yYgALB2J1cm5fcmEAFgdqbnppX3JhABYHZWQxOV9yYwAPB2VkMTlfcmIACwdlZDE5X3JhABYHd2RhbV9yZAAXB3dkYW1fcmMADwd3ZGFtX3JiAAsHd2RhbV9yYQAWCHNiX2ltbTEyAAwFc2JfcmIACwVzYl9yYQAWBnNyd19yYwAPBnNyd19yYgALBnNyd19yYQAWB3dxbW1fcmQAFwd3cW1tX3JjAA8Hd3FtbV9yYgALB3dxbW1fcmEAFgd3ZGR2X3JjAA8Hd2Rkdl9yYgALB3dkZHZfcmEAFgdqbXBiX3JhABYGam5lX3JjAA8Gam5lX3JiAAsGam5lX3JhABYHY2FsbF9yYwAPB2FuZGlfcmIACwdhbmRpX3JhABYHczI1Nl9yYwAPB3MyNTZfcmIACwdzMjU2X3JhABYHbXJvb19yYwAPB21yb29fcmIACwdtcm9vX3JhABYFbHRfcmMADwVsdF9yYgALBWx0X3JhABYGZGl2X3JjAA8GZGl2X3JiAAsGZGl2X3JhABYHd3FvcF9yYwAPB3dxb3BfcmIACwd3cW9wX3JhABYIbGJfaW1tMTIADAVsYl9yYgALBWxiX3JhABYFdHJfcmMADwV0cl9yYgALBXRyX3JhABYHcmV0ZF9yYgALB3JldGRfcmEAFghsd19pbW0xMgAMBWx3X3JiAAsFbHdfcmEAFgd3ZG1tX3JkABcHd2RtbV9yYwAPB3dkbW1fcmIACwd3ZG1tX3JhABYFZ3RfcmMADwVndF9yYgALBWd0X3JhABYFZXFfcmMADwVlcV9yYgALBWVxX3JhABYGbWVxX3JkABcGbWVxX3JjAA8GbWVxX3JiAAsGbWVxX3JhABYGc21vX3JkABcGc21vX3JjAA8Gc21vX3JiAAsGc21vX3JhABYGc3JsX3JjAA8Gc3JsX3JiAAsGc3JsX3JhABYGc2xsX3JjAA8Gc2xsX3JiAAsGc2xsX3JhABYHdGltZV9yYgALB3RpbWVfcmEAFgdzY3dxX3JjAA8Hc2N3cV9yYgALB3Njd3FfcmEAFgd3cW1sX3JjAA8Hd3FtbF9yYgALB3dxbWxfcmEAFgpkaXZpX2ltbTEyAAwHZGl2aV9yYgALB2RpdmlfcmEAFgZtY3BfcmMADwZtY3BfcmIACwZtY3BfcmEAFgZub3RfcmIACwZub3RfcmEAFgZiYWxfcmMADwZiYWxfcmIACwZiYWxfcmEAFgdsb2dkX3JkABcHbG9nZF9yYwAPB2xvZ2RfcmIACwdsb2dkX3JhABYKam5laV9pbW0xMgAMB2puZWlfcmIACwdqbmVpX3JhABYHam1wZl9yYQAWCmpuemZfaW1tMTIADAdqbnpmX3JiAAsHam56Zl9yYQAWE19fd2JnX21hdGhhcmdzX2ZyZWUAdwptb2RpX2ltbTEyAAwHbW9kaV9yYgALB21vZGlfcmEAFglvcmlfaW1tMTIADAZvcmlfcmIACwZvcmlfcmEAFgdlY2sxX3JjAA8HZWNrMV9yYgALB2VjazFfcmEAFgdlY2FsX3JkABcHZWNhbF9yYwAPB2VjYWxfcmIACwdlY2FsX3JhABYHc3J3cV9yZAAXB3Nyd3FfcmMADwdzcndxX3JiAAsHc3J3cV9yYQAWBnhvcl9yYwAPBnhvcl9yYgALBnhvcl9yYQAWB2NzaXpfcmIACwdjc2l6X3JhABYHbWludF9yYgALB21pbnRfcmEAFgpzbGxpX2ltbTEyAAwHc2xsaV9yYgALB3NsbGlfcmEAFgZsb2dfcmQAFwZsb2dfcmMADwZsb2dfcmIACwZsb2dfcmEAFgdtb3ZlX3JiAAsHbW92ZV9yYQAWBmxkY19yYwAPBmxkY19yYgALBmxkY19yYQAWB3dkbWxfcmMADwd3ZG1sX3JiAAsHd2RtbF9yYQAWBWdtX3JhABYHd2RjbV9yYwAPB3dkY21fcmIACwd3ZGNtX3JhABYKc3ViaV9pbW0xMgAMB3N1YmlfcmIACwdzdWJpX3JhABYGdHJvX3JkABcGdHJvX3JjAA8GdHJvX3JiAAsGdHJvX3JhABYJZ3RmX2ltbTEyAAwGZ3RmX3JiAAsGZ3RmX3JhABYGZXhwX3JjAA8GZXhwX3JiAAsGZXhwX3JhABYHd3FhbV9yZAAXB3dxYW1fcmMADwd3cWFtX3JiAAsHd3FhbV9yYQAWB3dxZHZfcmMADwd3cWR2X3JiAAsHd3Fkdl9yYQAWCmFuZGlfaW1tMTIADAdhZGRpX3JiAAsHYWRkaV9yYQAWB3dxbWRfcmQAFwd3cW1kX3JjAA8Hd3FtZF9yYgALB3dxbWRfcmEAFgdlY3IxX3JjAA8HZWNyMV9yYgALB2VjcjFfcmEAFgdjcm9vX3JiAAsHY3Jvb19yYQAWCm1jcGlfaW1tMTIADAdtY3BpX3JiAAsHbWNwaV9yYQAWB3dkb3BfcmMADwd3ZG9wX3JiAAsHd2RvcF9yYQAWBnN1Yl9yYwAPBnN1Yl9yYgALBnN1Yl9yYQAWCmpuemJfaW1tMTIADAdqbnpiX3JiAAsHam56Yl9yYQAWBnN3d19yYwAPBnN3d19yYgALBnN3d19yYQAWB3N3d3FfcmQAFwdzd3dxX3JjAA8Hc3d3cV9yYgALB3N3d3FfcmEAFgdtbGR2X3JkABcHbWxkdl9yYwAPB21sZHZfcmIACwdtbGR2X3JhABYGY2NwX3JkABcGY2NwX3JjAA8GY2NwX3JiAAsGY2NwX3JhABYHd3FjbV9yYwAPB3dxY21fcmIACwd3cWNtX3JhABYGYW5kX3JjAA8GYW5kX3JiAAsGYW5kX3JhABYbX193YmdfcGFuaWNpbnN0cnVjdGlvbl9mcmVlALgBH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAzAETX193YmluZGdlbl9leHBvcnRfMADLAQkRAQBBAQsGAs8B0AHRAe0BygEK1oEB+QGJIwIIfwF+AkACQAJAAkACQAJAAkACQCAAQfUBTwRAIABBzf97Tw0FIABBC2oiAEF4cSEFQfiMwAAoAgAiCEUNBEEAIAVrIQQCf0EAIAVBgAJJDQAaQR8gBUH///8HSw0AGiAFQQYgAEEIdmciAGt2QQFxIABBAXRrQT5qCyIHQQJ0QdyJwABqKAIAIgFFBEBBACEADAILQQAhACAFQRkgB0EBdmtBACAHQR9HG3QhAwNAAkAgASgCBEF4cSIGIAVJDQAgBiAFayIGIARPDQAgASECIAYiBA0AQQAhBCABIQAMBAsgAUEUaigCACIGIAAgBiABIANBHXZBBHFqQRBqKAIAIgFHGyAAIAYbIQAgA0EBdCEDIAENAAsMAQtB9IzAACgCACICQRAgAEELakF4cSAAQQtJGyIFQQN2IgB2IgFBA3EEQAJAIAFBf3NBAXEgAGoiAUEDdCIAQeyKwABqIgMgAEH0isAAaigCACIAKAIIIgRHBEAgBCADNgIMIAMgBDYCCAwBC0H0jMAAIAJBfiABd3E2AgALIAAgAUEDdCIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAgLIAVB/IzAACgCAE0NAwJAAkAgAUUEQEH4jMAAKAIAIgBFDQYgAGhBAnRB3InAAGooAgAiASgCBEF4cSAFayEEIAEhAgNAAkAgASgCECIADQAgAUEUaigCACIADQAgAigCGCEHAkACQCACIAIoAgwiAEYEQCACQRRBECACQRRqIgAoAgAiAxtqKAIAIgENAUEAIQAMAgsgAigCCCIBIAA2AgwgACABNgIIDAELIAAgAkEQaiADGyEDA0AgAyEGIAEiAEEUaiIBIABBEGogASgCACIBGyEDIABBFEEQIAEbaigCACIBDQALIAZBADYCAAsgB0UNBCACIAIoAhxBAnRB3InAAGoiASgCAEcEQCAHQRBBFCAHKAIQIAJGG2ogADYCACAARQ0FDAQLIAEgADYCACAADQNB+IzAAEH4jMAAKAIAQX4gAigCHHdxNgIADAQLIAAoAgRBeHEgBWsiASAEIAEgBEkiARshBCAAIAIgARshAiAAIQEMAAsACwJAQQIgAHQiA0EAIANrciABIAB0cWgiAEEDdCIBQeyKwABqIgMgAUH0isAAaigCACIBKAIIIgRHBEAgBCADNgIMIAMgBDYCCAwBC0H0jMAAIAJBfiAAd3E2AgALIAEgBUEDcjYCBCABIAVqIgYgAEEDdCIAIAVrIgRBAXI2AgQgACABaiAENgIAQfyMwAAoAgAiAgRAIAJBeHFB7IrAAGohAEGEjcAAKAIAIQMCf0H0jMAAKAIAIgVBASACQQN2dCICcUUEQEH0jMAAIAIgBXI2AgAgAAwBCyAAKAIICyECIAAgAzYCCCACIAM2AgwgAyAANgIMIAMgAjYCCAtBhI3AACAGNgIAQfyMwAAgBDYCACABQQhqDwsgACAHNgIYIAIoAhAiAQRAIAAgATYCECABIAA2AhgLIAJBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAAkAgBEEQTwRAIAIgBUEDcjYCBCACIAVqIgUgBEEBcjYCBCAEIAVqIAQ2AgBB/IzAACgCACIDRQ0BIANBeHFB7IrAAGohAEGEjcAAKAIAIQECf0H0jMAAKAIAIgZBASADQQN2dCIDcUUEQEH0jMAAIAMgBnI2AgAgAAwBCyAAKAIICyEDIAAgATYCCCADIAE2AgwgASAANgIMIAEgAzYCCAwBCyACIAQgBWoiAEEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwBC0GEjcAAIAU2AgBB/IzAACAENgIACyACQQhqDwsgACACckUEQEEAIQJBAiAHdCIAQQAgAGtyIAhxIgBFDQMgAGhBAnRB3InAAGooAgAhAAsgAEUNAQsDQCAAIAIgACgCBEF4cSIDIAVrIgYgBEkiBxshCCAAKAIQIgFFBEAgAEEUaigCACEBCyACIAggAyAFSSIAGyECIAQgBiAEIAcbIAAbIQQgASIADQALCyACRQ0AIAVB/IzAACgCACIATSAEIAAgBWtPcQ0AIAIoAhghBwJAAkAgAiACKAIMIgBGBEAgAkEUQRAgAkEUaiIAKAIAIgMbaigCACIBDQFBACEADAILIAIoAggiASAANgIMIAAgATYCCAwBCyAAIAJBEGogAxshAwNAIAMhBiABIgBBFGoiASAAQRBqIAEoAgAiARshAyAAQRRBECABG2ooAgAiAQ0ACyAGQQA2AgALIAdFDQMgAiACKAIcQQJ0QdyJwABqIgEoAgBHBEAgB0EQQRQgBygCECACRhtqIAA2AgAgAEUNBAwDCyABIAA2AgAgAA0CQfiMwABB+IzAACgCAEF+IAIoAhx3cTYCAAwDCwJAAkACQAJAAkAgBUH8jMAAKAIAIgFLBEAgBUGAjcAAKAIAIgBPBEBBACEEIAVBr4AEaiIAQRB2QAAiAUF/RiIDDQcgAUEQdCICRQ0HQYyNwABBACAAQYCAfHEgAxsiBEGMjcAAKAIAaiIANgIAQZCNwABBkI3AACgCACIBIAAgACABSRs2AgACQAJAQYiNwAAoAgAiAwRAQdyKwAAhAANAIAAoAgAiASAAKAIEIgZqIAJGDQIgACgCCCIADQALDAILQZiNwAAoAgAiAEEAIAAgAk0bRQRAQZiNwAAgAjYCAAtBnI3AAEH/HzYCAEHgisAAIAQ2AgBB3IrAACACNgIAQfiKwABB7IrAADYCAEGAi8AAQfSKwAA2AgBB9IrAAEHsisAANgIAQYiLwABB/IrAADYCAEH8isAAQfSKwAA2AgBBkIvAAEGEi8AANgIAQYSLwABB/IrAADYCAEGYi8AAQYyLwAA2AgBBjIvAAEGEi8AANgIAQaCLwABBlIvAADYCAEGUi8AAQYyLwAA2AgBBqIvAAEGci8AANgIAQZyLwABBlIvAADYCAEGwi8AAQaSLwAA2AgBBpIvAAEGci8AANgIAQeiKwABBADYCAEG4i8AAQayLwAA2AgBBrIvAAEGki8AANgIAQbSLwABBrIvAADYCAEHAi8AAQbSLwAA2AgBBvIvAAEG0i8AANgIAQciLwABBvIvAADYCAEHEi8AAQbyLwAA2AgBB0IvAAEHEi8AANgIAQcyLwABBxIvAADYCAEHYi8AAQcyLwAA2AgBB1IvAAEHMi8AANgIAQeCLwABB1IvAADYCAEHci8AAQdSLwAA2AgBB6IvAAEHci8AANgIAQeSLwABB3IvAADYCAEHwi8AAQeSLwAA2AgBB7IvAAEHki8AANgIAQfiLwABB7IvAADYCAEGAjMAAQfSLwAA2AgBB9IvAAEHsi8AANgIAQYiMwABB/IvAADYCAEH8i8AAQfSLwAA2AgBBkIzAAEGEjMAANgIAQYSMwABB/IvAADYCAEGYjMAAQYyMwAA2AgBBjIzAAEGEjMAANgIAQaCMwABBlIzAADYCAEGUjMAAQYyMwAA2AgBBqIzAAEGcjMAANgIAQZyMwABBlIzAADYCAEGwjMAAQaSMwAA2AgBBpIzAAEGcjMAANgIAQbiMwABBrIzAADYCAEGsjMAAQaSMwAA2AgBBwIzAAEG0jMAANgIAQbSMwABBrIzAADYCAEHIjMAAQbyMwAA2AgBBvIzAAEG0jMAANgIAQdCMwABBxIzAADYCAEHEjMAAQbyMwAA2AgBB2IzAAEHMjMAANgIAQcyMwABBxIzAADYCAEHgjMAAQdSMwAA2AgBB1IzAAEHMjMAANgIAQeiMwABB3IzAADYCAEHcjMAAQdSMwAA2AgBB8IzAAEHkjMAANgIAQeSMwABB3IzAADYCAEGIjcAAIAI2AgBB7IzAAEHkjMAANgIAQYCNwAAgBEEoayIANgIAIAIgAEEBcjYCBCAAIAJqQSg2AgRBlI3AAEGAgIABNgIADAgLIAIgA00gASADS3INACAAKAIMRQ0DC0GYjcAAQZiNwAAoAgAiACACIAAgAkkbNgIAIAIgBGohAUHcisAAIQACQAJAA0AgASAAKAIARwRAIAAoAggiAA0BDAILCyAAKAIMRQ0BC0HcisAAIQADQAJAIAMgACgCACIBTwRAIAEgACgCBGoiBiADSw0BCyAAKAIIIQAMAQsLQYiNwAAgAjYCAEGAjcAAIARBKGsiADYCACACIABBAXI2AgQgACACakEoNgIEQZSNwABBgICAATYCACADIAZBIGtBeHFBCGsiACAAIANBEGpJGyIBQRs2AgRB3IrAACkCACEJIAFBEGpB5IrAACkCADcCACABIAk3AghB4IrAACAENgIAQdyKwAAgAjYCAEHkisAAIAFBCGo2AgBB6IrAAEEANgIAIAFBHGohAANAIABBBzYCACAAQQRqIgAgBkkNAAsgASADRg0HIAEgASgCBEF+cTYCBCADIAEgA2siAEEBcjYCBCABIAA2AgAgAEGAAk8EQCADIAAQCAwICyAAQXhxQeyKwABqIQECf0H0jMAAKAIAIgJBASAAQQN2dCIAcUUEQEH0jMAAIAAgAnI2AgAgAQwBCyABKAIICyEAIAEgAzYCCCAAIAM2AgwgAyABNgIMIAMgADYCCAwHCyAAIAI2AgAgACAAKAIEIARqNgIEIAIgBUEDcjYCBCABIAIgBWoiA2shBSABQYiNwAAoAgBGDQMgAUGEjcAAKAIARg0EIAEoAgQiBEEDcUEBRgRAIAEgBEF4cSIAEAcgACAFaiEFIAAgAWoiASgCBCEECyABIARBfnE2AgQgAyAFQQFyNgIEIAMgBWogBTYCACAFQYACTwRAIAMgBRAIDAYLIAVBeHFB7IrAAGohAAJ/QfSMwAAoAgAiAUEBIAVBA3Z0IgRxRQRAQfSMwAAgASAEcjYCACAADAELIAAoAggLIQUgACADNgIIIAUgAzYCDCADIAA2AgwgAyAFNgIIDAULQYCNwAAgACAFayIBNgIAQYiNwABBiI3AACgCACIAIAVqIgI2AgAgAiABQQFyNgIEIAAgBUEDcjYCBCAAQQhqIQQMBgtBhI3AACgCACEAAkAgASAFayICQQ9NBEBBhI3AAEEANgIAQfyMwABBADYCACAAIAFBA3I2AgQgACABaiIBIAEoAgRBAXI2AgQMAQtB/IzAACACNgIAQYSNwAAgACAFaiIDNgIAIAMgAkEBcjYCBCAAIAFqIAI2AgAgACAFQQNyNgIECwwICyAAIAQgBmo2AgRBiI3AAEGIjcAAKAIAIgBBD2pBeHEiAUEIayICNgIAQYCNwABBgI3AACgCACAEaiIDIAAgAWtqQQhqIgE2AgAgAiABQQFyNgIEIAAgA2pBKDYCBEGUjcAAQYCAgAE2AgAMAwtBiI3AACADNgIAQYCNwABBgI3AACgCACAFaiIANgIAIAMgAEEBcjYCBAwBC0GEjcAAIAM2AgBB/IzAAEH8jMAAKAIAIAVqIgA2AgAgAyAAQQFyNgIEIAAgA2ogADYCAAsgAkEIag8LQQAhBEGAjcAAKAIAIgAgBU0NAEGAjcAAIAAgBWsiATYCAEGIjcAAQYiNwAAoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQMAwsgBA8LIAAgBzYCGCACKAIQIgEEQCAAIAE2AhAgASAANgIYCyACQRRqKAIAIgFFDQAgAEEUaiABNgIAIAEgADYCGAsCQCAEQRBPBEAgAiAFQQNyNgIEIAIgBWoiASAEQQFyNgIEIAEgBGogBDYCACAEQYACTwRAIAEgBBAIDAILIARBeHFB7IrAAGohAAJ/QfSMwAAoAgAiA0EBIARBA3Z0IgRxRQRAQfSMwAAgAyAEcjYCACAADAELIAAoAggLIQQgACABNgIIIAQgATYCDCABIAA2AgwgASAENgIIDAELIAIgBCAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIECyACQQhqDwsgAEEIagvtCwELfyAAKAIEIQcgACgCACEFAkACQAJAIAEoAgAiCiABKAIIIgByBEACQCAARQ0AIAUgB2ohCSABQQxqKAIAQQFqIQYgBSECA0ACQCACIQAgBkEBayIGRQ0AIAAgCUYNAgJ/IAAsAAAiBEEATgRAIARB/wFxIQQgAEEBagwBCyAALQABQT9xIQggBEEfcSECIARBX00EQCACQQZ0IAhyIQQgAEECagwBCyAALQACQT9xIAhBBnRyIQggBEFwSQRAIAggAkEMdHIhBCAAQQNqDAELIAJBEnRBgIDwAHEgAC0AA0E/cSAIQQZ0cnIiBEGAgMQARg0DIABBBGoLIgIgAyAAa2ohAyAEQYCAxABHDQEMAgsLIAAgCUYNACAALAAAIgJBAE4gAkFgSXIgAkFwSXJFBEAgAkH/AXFBEnRBgIDwAHEgAC0AA0E/cSAALQACQT9xQQZ0IAAtAAFBP3FBDHRycnJBgIDEAEYNAQsCQAJAIANFDQAgAyAHTwRAQQAhACADIAdGDQEMAgtBACEAIAMgBWosAABBQEgNAQsgBSEACyADIAcgABshByAAIAUgABshBQsgCkUNAyABKAIEIQsgB0EQTwRAIAcgBSAFQQNqQXxxIgRrIgZqIgpBA3EhCEEAIQlBACEAIAQgBUcEQCAEIAVBf3NqQQNPBEBBACEDA0AgACADIAVqIgIsAABBv39KaiACQQFqLAAAQb9/SmogAkECaiwAAEG/f0pqIAJBA2osAABBv39KaiEAIANBBGoiAw0ACwsgBSECA0AgACACLAAAQb9/SmohACACQQFqIQIgBkEBaiIGDQALCwJAIAhFDQAgBCAKQXxxaiICLAAAQb9/SiEJIAhBAUYNACAJIAIsAAFBv39KaiEJIAhBAkYNACAJIAIsAAJBv39KaiEJCyAKQQJ2IQggACAJaiEDA0AgBCEGIAhFDQRBwAEgCCAIQcABTxsiCUEDcSEKIAlBAnQhBEEAIQIgCUEETwRAIAYgBEHwB3FqIQwgBiEAA0AgAiAAKAIAIgJBf3NBB3YgAkEGdnJBgYKECHFqIABBBGooAgAiAkF/c0EHdiACQQZ2ckGBgoQIcWogAEEIaigCACICQX9zQQd2IAJBBnZyQYGChAhxaiAAQQxqKAIAIgJBf3NBB3YgAkEGdnJBgYKECHFqIQIgAEEQaiIAIAxHDQALCyAIIAlrIQggBCAGaiEEIAJBCHZB/4H8B3EgAkH/gfwHcWpBgYAEbEEQdiADaiEDIApFDQALIAYgCUH8AXFBAnRqIgIoAgAiAEF/c0EHdiAAQQZ2ckGBgoQIcSEAIApBAUYNAiAAIAIoAgQiAEF/c0EHdiAAQQZ2ckGBgoQIcWohACAKQQJGDQIgACACKAIIIgBBf3NBB3YgAEEGdnJBgYKECHFqIQAMAgsgB0UEQEEAIQMMAwsgB0EDcSECAkAgB0EESQRAQQAhA0EAIQYMAQtBACEDIAUhACAHQXxxIgYhBANAIAMgACwAAEG/f0pqIABBAWosAABBv39KaiAAQQJqLAAAQb9/SmogAEEDaiwAAEG/f0pqIQMgAEEEaiEAIARBBGsiBA0ACwsgAkUNAiAFIAZqIQADQCADIAAsAABBv39KaiEDIABBAWohACACQQFrIgINAAsMAgsMAgsgAEEIdkH/gRxxIABB/4H8B3FqQYGABGxBEHYgA2ohAwsCQCADIAtJBEAgCyADayEDQQAhAAJAAkACQCABLQAgQQFrDgIAAQILIAMhAEEAIQMMAQsgA0EBdiEAIANBAWpBAXYhAwsgAEEBaiEAIAFBGGooAgAhAiABKAIQIQYgASgCFCEBA0AgAEEBayIARQ0CIAEgBiACKAIQEQMARQ0AC0EBDwsMAQtBASEAIAEgBSAHIAIoAgwRAAAEf0EBBUEAIQACfwNAIAMgACADRg0BGiAAQQFqIQAgASAGIAIoAhARAwBFDQALIABBAWsLIANJCw8LIAEoAhQgBSAHIAFBGGooAgAoAgwRAAALpgYCDX8BfiMAQTBrIgckAEEnIQICQCAAQpDOAFQEQCAAIQ8MAQsDQCAHQQlqIAJqIgZBBGsgAEKQzgCAIg9C8LEDfiAAfKciBEH//wNxQeQAbiIDQQF0QciGwABqLwAAOwAAIAZBAmsgA0Gcf2wgBGpB//8DcUEBdEHIhsAAai8AADsAACACQQRrIQIgAEL/wdcvViAPIQANAAsLIA+nIgRB4wBLBEAgAkECayICIAdBCWpqIA+nIgNB//8DcUHkAG4iBEGcf2wgA2pB//8DcUEBdEHIhsAAai8AADsAAAsCQCAEQQpPBEAgAkECayICIAdBCWpqIARBAXRByIbAAGovAAA7AAAMAQsgAkEBayICIAdBCWpqIARBMGo6AAALQScgAmshCEEBIQVBK0GAgMQAIAEoAhwiBEEBcSIMGyEJIARBHXRBH3VB6IjAAHEhCiAHQQlqIAJqIQsCQCABKAIARQRAIAEoAhQiAyABKAIYIgEgCSAKEEcNASADIAsgCCABKAIMEQAAIQUMAQsgASgCBCINIAggDGoiA00EQCABKAIUIgMgASgCGCIBIAkgChBHDQEgAyALIAggASgCDBEAACEFDAELIARBCHEEQCABKAIQIQQgAUEwNgIQIAEtACAhAyABQQE6ACAgASgCFCIOIAEoAhgiBiAJIAoQRw0BIAIgDWogDGtBJmshAgNAIAJBAWsiAgRAIA5BMCAGKAIQEQMARQ0BDAMLCyAOIAsgCCAGKAIMEQAADQEgASADOgAgIAEgBDYCEEEAIQUMAQsgDSADayEDAkACQAJAIAEtACAiAkEBaw4DAAEAAgsgAyECQQAhAwwBCyADQQF2IQIgA0EBakEBdiEDCyACQQFqIQIgAUEYaigCACEGIAEoAhAhBCABKAIUIQECQANAIAJBAWsiAkUNASABIAQgBigCEBEDAEUNAAsMAQsgASAGIAkgChBHDQAgASALIAggBigCDBEAAA0AQQAhAgNAIAIgA0YEQEEAIQUMAgsgAkEBaiECIAEgBCAGKAIQEQMARQ0ACyACQQFrIANJIQULIAdBMGokACAFC/wFAQV/IABBCGsiASAAQQRrKAIAIgNBeHEiAGohAgJAAkACQAJAIANBAXENACADQQNxRQ0BIAEoAgAiAyAAaiEAIAEgA2siAUGEjcAAKAIARgRAIAIoAgRBA3FBA0cNAUH8jMAAIAA2AgAgAiACKAIEQX5xNgIEIAEgAEEBcjYCBCACIAA2AgAPCyABIAMQBwsCQAJAIAIoAgQiA0ECcUUEQCACQYiNwAAoAgBGDQIgAkGEjcAAKAIARg0FIAIgA0F4cSICEAcgASAAIAJqIgBBAXI2AgQgACABaiAANgIAIAFBhI3AACgCAEcNAUH8jMAAIAA2AgAPCyACIANBfnE2AgQgASAAQQFyNgIEIAAgAWogADYCAAsgAEGAAkkNAiABIAAQCEEAIQFBnI3AAEGcjcAAKAIAQQFrIgA2AgAgAA0BQeSKwAAoAgAiAARAA0AgAUEBaiEBIAAoAggiAA0ACwtBnI3AAEH/HyABIAFB/x9NGzYCAA8LQYiNwAAgATYCAEGAjcAAQYCNwAAoAgAgAGoiADYCACABIABBAXI2AgRBhI3AACgCACABRgRAQfyMwABBADYCAEGEjcAAQQA2AgALIABBlI3AACgCACIDTQ0AQYiNwAAoAgAiAkUNAEEAIQECQEGAjcAAKAIAIgRBKUkNAEHcisAAIQADQCACIAAoAgAiBU8EQCAFIAAoAgRqIAJLDQILIAAoAggiAA0ACwtB5IrAACgCACIABEADQCABQQFqIQEgACgCCCIADQALC0GcjcAAQf8fIAEgAUH/H00bNgIAIAMgBE8NAEGUjcAAQX82AgALDwsgAEF4cUHsisAAaiECAn9B9IzAACgCACIDQQEgAEEDdnQiAHFFBEBB9IzAACAAIANyNgIAIAIMAQsgAigCCAshACACIAE2AgggACABNgIMIAEgAjYCDCABIAA2AggPC0GEjcAAIAE2AgBB/IzAAEH8jMAAKAIAIABqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAuBBQEBfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQYAEaw4mAQIDBAUGBwgsCQoLDA0sLCwsLCwsLCwsLCwsLCwsLCwODywsLBAAC0EBIQECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEEBaw4OQgECAwQFBgcICQoLDA0ACwJAIABBwARrDgwoKSorLC0uLzAxMjMACwJAIABBgQJrDgoODxAREhMUFRYXAAsCQCAAQYAGaw4JNDU2NzhDQzk6AAsCQCAAQYAKaw4FPT4/QEEACyAAQYAIaw4COjtCC0ECDwtBAw8LQQQPC0EFDwtBBg8LQQcPC0EIDwtBCQ8LQQoPC0ELDwtBDA8LQQ0PC0EODwtBgQIPC0GCAg8LQYMCDwtBhAIPC0GFAg8LQYYCDwtBhwIPC0GIAg8LQYkCDwtBigIPC0GABA8LQYEEDwtBggQPC0GDBA8LQYQEDwtBhQQPC0GGBA8LQYcEDwtBiQQPC0GKBA8LQYsEDwtBjAQPC0GNBA8LQaAEDwtBoQQPC0GlBA8LQcAEDwtBwQQPC0HCBA8LQcMEDwtBxAQPC0HFBA8LQcYEDwtBxwQPC0HIBA8LQckEDwtBygQPC0HLBA8LQYAGDwtBgQYPC0GCBg8LQYMGDwtBhAYPC0GHBg8LQYgGDwtBgAgPC0GBCA8LQYAKDwtBgQoPC0GCCg8LQYMKDwtBhAohAQsgAQ8LQeCCwABBGRDSAQAL+AMBAn8gACABaiECAkACQCAAKAIEIgNBAXENACADQQNxRQ0BIAAoAgAiAyABaiEBIAAgA2siAEGEjcAAKAIARgRAIAIoAgRBA3FBA0cNAUH8jMAAIAE2AgAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCACIAE2AgAPCyAAIAMQBwsCQAJAAkAgAigCBCIDQQJxRQRAIAJBiI3AACgCAEYNAiACQYSNwAAoAgBGDQMgAiADQXhxIgIQByAAIAEgAmoiAUEBcjYCBCAAIAFqIAE2AgAgAEGEjcAAKAIARw0BQfyMwAAgATYCAA8LIAIgA0F+cTYCBCAAIAFBAXI2AgQgACABaiABNgIACyABQYACTwRAIAAgARAIDAMLIAFBeHFB7IrAAGohAgJ/QfSMwAAoAgAiA0EBIAFBA3Z0IgFxRQRAQfSMwAAgASADcjYCACACDAELIAIoAggLIQEgAiAANgIIIAEgADYCDCAAIAI2AgwgACABNgIIDwtBiI3AACAANgIAQYCNwABBgI3AACgCACABaiIBNgIAIAAgAUEBcjYCBCAAQYSNwAAoAgBHDQFB/IzAAEEANgIAQYSNwABBADYCAA8LQYSNwAAgADYCAEH8jMAAQfyMwAAoAgAgAWoiATYCACAAIAFBAXI2AgQgACABaiABNgIACwv7AgEEfyAAKAIMIQICQAJAIAFBgAJPBEAgACgCGCEDAkACQCAAIAJGBEAgAEEUQRAgAEEUaiICKAIAIgQbaigCACIBDQFBACECDAILIAAoAggiASACNgIMIAIgATYCCAwBCyACIABBEGogBBshBANAIAQhBSABIgJBFGoiASACQRBqIAEoAgAiARshBCACQRRBECABG2ooAgAiAQ0ACyAFQQA2AgALIANFDQIgACAAKAIcQQJ0QdyJwABqIgEoAgBHBEAgA0EQQRQgAygCECAARhtqIAI2AgAgAkUNAwwCCyABIAI2AgAgAg0BQfiMwABB+IzAACgCAEF+IAAoAhx3cTYCAAwCCyAAKAIIIgAgAkcEQCAAIAI2AgwgAiAANgIIDwtB9IzAAEH0jMAAKAIAQX4gAUEDdndxNgIADwsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIABBFGooAgAiAEUNACACQRRqIAA2AgAgACACNgIYCwusAgEEf0EfIQIgAEIANwIQIAFB////B00EQCABQQYgAUEIdmciA2t2QQFxIANBAXRrQT5qIQILIAAgAjYCHCACQQJ0QdyJwABqIQQCQEH4jMAAKAIAIgVBASACdCIDcUUEQEH4jMAAIAMgBXI2AgAgBCAANgIAIAAgBDYCGAwBCwJAAkAgASAEKAIAIgMoAgRBeHFGBEAgAyECDAELIAFBGSACQQF2a0EAIAJBH0cbdCEEA0AgAyAEQR12QQRxakEQaiIFKAIAIgJFDQIgBEEBdCEEIAIhAyACKAIEQXhxIAFHDQALCyACKAIIIgEgADYCDCACIAA2AgggAEEANgIYIAAgAjYCDCAAIAE2AggPCyAFIAA2AgAgACADNgIYCyAAIAA2AgwgACAANgIIC2kBA38jAEEQayIBJAAgAUEIaiAAEEogASgCCCIAQQJqLQAAIQIgAC8AACABKAIMIgMgAygCAEEBazYCACACQRB0chDVASIAQYAGcUEIdCAAQQh2QYD+A3EgAEEYdnJyELsBIAFBEGokAAt5AQN/IAEQxAECQCABKAIAIgJBf0cEQCABIAJBAWo2AgAgASgCBCgAACIDQRh0QRZ1QfyCwABqKAIAIQRBAUEEEMcBIgJFDQEgAiAEIANBgH5xcjYAACABIAEoAgBBAWs2AgAgAEEENgIEIAAgAjYCAA8LEM4BAAsAC2YBA38jAEEQayIBJAAgAUEIaiAAEEogASgCCCIAQQJqLQAAIQIgAC8AACABKAIMIgMgAygCAEEBazYCACACQRB0chDVASIAQYAGcUEIdCAAQQh2QYDgA3FyQQx2ELwBIAFBEGokAAtuAQJ/IwBBEGsiASQAIAFBCGogABBKIAEoAggiAC8AACAAQQJqLQAAQRB0chDVASEAIAEoAgwiAiACKAIAQQFrNgIAQQhBBBC6ASICIABBCHZBgB5xIABBGHZyOwEEIAJBADYCACABQRBqJAAgAgttAQF/IwBBMGsiASQAIAEgADoADyAAQf8BcUHAAE8EQCABQRxqQgE3AgAgAUECNgIUIAFB9IDAADYCECABQQI2AiwgASABQShqNgIYIAEgAUEPajYCKCABQRBqQYSBwAAQSQALIAFBMGokACAAC24BAX8jAEEwayIBJAAgASAAOwEOIABB//8DcUGAIE8EQCABQRxqQgE3AgAgAUECNgIUIAFBuIHAADYCECABQQM2AiwgASABQShqNgIYIAEgAUEOajYCKCABQRBqQciBwAAQSQALIAFBMGokACAAC10BA38jAEEQayIBJAAgAUEIaiAAEEogASgCCCIAQQJqLQAAIQIgAC8AACABKAIMIgMgAygCAEEBazYCACACQRB0chDVASIAQR52IABBDnZBPHFyELwBIAFBEGokAAsVACAAQYyCwABB/IHAAEGAgBAQ8gELFgAgAEHQgsAAQcCCwABBgICACBDyAQtMACADQf8BcSABQf8BcUEMdCAAQf8BcUESdHIiACACQf8BcUEGdHJyIgFBEHRBgID8B3EgAEEIdkGA/gNxIAFBgP4DcUEIdHJBCHZyC1UCAX8BfiMAQRBrIgIkACABEMQBIAJBCGogARBUIAIoAgxBADYCACABKQIAIQMgARAEIAAgA0IoiKdBAXE6AAEgACADQiCIp0EBcToAACACQRBqJAALEAAgACABIAIgA0HiABD0AQsQACAAIAEgAiADQeMAEPQBC08BA38jAEEQayIBJAAgAUEIaiAAEEogASgCCCIAQQJqLQAAIQIgAC8AACABKAIMIgMgAygCAEEBazYCACACQRB0chDIARC8ASABQRBqJAALVQEDfyMAQRBrIgEkACABQQhqIAAQSiABKAIIIgBBAmotAAAhAiAALwAAIAEoAgwiAyADKAIAQQFrNgIAIAJBEHRyENUBQRh2QT9xELwBIAFBEGokAAtSAQF/IAAQUSECIAEQUyEAQQhBBBC6ASIBIABBEHRBgID8B3EgACACQf8BcUESdHIiAEGA/gNxQQh0IABBCHZBgP4DcXJBCHZyrUIghjcCACABCxAAIAAgASACIANB3gAQ9QELEAAgACABIAIgA0HfABD1AQsQACAAIAEgAiADQeAAEPUBCxAAIAAgASACIANB4QAQ9QELUQIBfwF+IwBBEGsiAiQAIAEQxAEgAkEIaiABEFQgAigCDEEANgIAIAEpAgAhAyABEAQgACADQiiIPAABIAAgA0IgiKdBAXE6AAAgAkEQaiQACz4BAX8jAEEQayIEJAAgABBRIAEQUSACEFEgBEEIaiADEBMgBC0ACEEBcSAELQAJQQFxEHoQrAEgBEEQaiQAC0kBAX8gABBRIQAgARBRIQFBCEEEELoBIgIgAUH/AXFBDHQgAEESdHIiAEGA4ANxQQh0IABBCHZBgP4DcXJBCHatQiCGNwIAIAILDAAgACABQcsAEPYBCwwAIAAgAUHMABD2AQsMACAAIAFBzQAQ9gELDAAgACABQc4AEPYBCwwAIAAgAUHPABD2AQsMACAAIAFB0AAQ9gELPAEBfyMAQRBrIgQkACAAEFEgARBRIAIQUSAEQQhqIAMQHSAELQAIQQFxIAQtAAkQvgEQrAEgBEEQaiQAC0gAIAAQxAEgACgCAEF/RgRAEM4BAAsgAC8ABCAAQQZqLQAAQRB0chDVASIAQYD+A3FBCHQgAEEIdkGA/gNxIABBGHZychC7AQsLACAAIAFBBxD3AQs/AQJ/AkAgABBRIgBBGHENACAAQQdxIgJBB0YNAEEIQQQQugEiASAAQQV2QQFxrUIghiACrUIohoQ3AgALIAELCwAgACABQQgQ9wELPwAgAkEWdEGAgIAGcSABQf8BcUEMdCIBIAJB/AFxQQZ0ckGA/gNxQQh0IAEgAEESdHJBCHZBgP4DcXJBCHZyCwsAIAAgAUEKEPgBCwsAIAAgAUEMEPgBCwsAIAAgAUEUEPgBCwsAIAAgAUEWEPgBCwsAIAAgAUEZEPgBCwsAIAAgAUEbEPgBCwsAIAAgAUEeEPgBCwsAIAAgAUEfEPgBCwsAIAAgAUEkEPgBCwsAIAAgAUEyEPgBCz8AIAAQUSEAIAEQUyIBQRB0QYCA/AdxIABB/wFxQRJ0IAFyIgBBgP4DcUEIdCAAQQh2QYD+A3FyQQh2chCsAQtAAQF/IAAQUyEAQQhBBBC6ASIBIABBEHRBgID8B3EgAEEIdkGA/gNxIABBgP4DcUEIdHJBCHZyrUIghjcCACABCzgAIAJBEHRBgID8B3EgAUH/AXFBDHQiASACckGA/gNxQQh0IAEgAEESdHJBCHZBgP4DcXJBCHZyCzwBAn8jAEEQayIBJAAgABDEASABQQhqIAAQSyABKAIILQABIAEoAgwiAiACKAIAQQFrNgIAIAFBEGokAAs8AQJ/IwBBEGsiASQAIAAQxAEgAUEIaiAAEEsgASgCCC0AACABKAIMIgIgAigCAEEBazYCACABQRBqJAALOQEBfyMAQRBrIgIkACAAEMQBIAJBCGogABBUIAIoAgwgAigCCCABQQBHOgAAQQA2AgAgAkEQaiQACzkBAX8jAEEQayICJAAgABDEASACQQhqIAAQVCACKAIMIAIoAgggAUEARzoAAUEANgIAIAJBEGokAAs4AQJ/IwBBEGsiASQAIAAQxAEgAUEIaiAAEFQgASgCDEEANgIAIAAtAAQgABAEIAFBEGokAEEBcQs3AQJ/IwBBEGsiASQAIAFBCGogABBKIAEoAggtAAQgASgCDCICIAIoAgBBAWs2AgAgAUEQaiQACzcBAn8jAEEQayIBJAAgAUEIaiAAEEogASgCCCgCACABKAIMIgIgAigCAEEBazYCACABQRBqJAALCgAgAEHVABD5AQsKACAAQdYAEPkBCwoAIABB1wAQ+QELCgAgAEHaABD5AQsKACAAQdsAEPkBCwoAIABB3AAQ+QELCgAgAEHdABD5AQs5AAJAAn8gAkGAgMQARwRAQQEgACACIAEoAhARAwANARoLIAMNAUEACw8LIAAgA0EAIAEoAgwRAAALMQEBfyMAQRBrIgEkACABQQhqIAAQHSABLQAJIAEtAAhBBXRBIHFyELwBIAFBEGokAAuhAgEBfyMAQSBrIgIkACACQQE7ARwgAiABNgIYIAIgADYCFCACQbiGwAA2AhAgAkHoiMAANgIMIAJBDGoiACgCCCIBRQRAIwBBIGsiACQAIABBDGpCADcCACAAQQE2AgQgAEHoiMAANgIIIABBKzYCHCAAQZCIwAA2AhggACAAQRhqNgIAIABB2IjAABBJAAsgAUEMaigCACECAkACQCABKAIEDgIAAAELIAINAAsgAC0AECEBIAAtABEaQdiJwABB2InAACgCACIAQQFqNgIAAkAgAEEASA0AQaSNwAAtAABBAXENAEGkjcAAQQE6AABBoI3AAEGgjcAAKAIAQQFqNgIAQdSJwAAoAgBBAEgNAEGkjcAAQQA6AAAgAUUNAAALAAs1AQF/IAEQxAEgASgCACICQX9GBEAQzgEACyABIAJBAWo2AgAgACABNgIEIAAgAUEEajYCAAsxAQF/IAEoAgAiAkF/RwRAIAEgAkEBajYCACAAIAE2AgQgACABQQRqNgIADwsQzgEACzUBAX8gAEE2TwRAQeCCwABBGRDSAQALQQxBBBC6ASICIAA6AAggAiABNgIEIAJBADYCACACCzAAIAAQUSABEFEgAhBRIAMQURASIQBBCEEEELoBIgEgAK1C////B4NCIIY3AgAgAQstACAAEMQBIAAoAgBBf0YEQBDOAQALIAAvAAQgAEEGai0AAEEQdHIQyAEQvAELLAAgABBRIAEQUSACEFEQKyEAQQhBBBC6ASIBIACtQv///weDQiCGNwIAIAELLAAgABBRIAEQUSACEFIQOCEAQQhBBBC6ASIBIACtQv///weDQiCGNwIAIAELJQEBfwJAIAAEQCAAKAIADQEgAC0ABCAAEAQPCxDNAQALEM4BAAslAQF/AkAgAARAIAAoAgANASAALwEEIAAQBA8LEM0BAAsQzgEACyUBAX8CQCAABEAgACgCAA0BIAAoAgQgABAEDwsQzQEACxDOAQALKAAgASgCAEUEQCABQX82AgAgACABNgIEIAAgAUEEajYCAA8LEM4BAAspACADED0hAyAAEL0BIAEQvQEgAhC9ASADEMIBQQh0QeQAchDFARC7AQspACADED0hAyAAEL0BIAEQvQEgAhC9ASADEMIBQQh0QeUAchDFARC7AQslAQF/IAAQUSEAQQhBBBC6ASIBIABBAnRB/AFxrUIghjcCACABCyAAIABBAWsiAEEFTQRAIABBAWoPC0HggsAAQRkQ0gEACyABAX8gABDEASAAKAIABEAQzgEACyAAKAIEIAAQBBAECyMAIAIQBSECIAAQvQEgARC9ASACEDhBCHRBygByEMUBELsBCx4AAkAgAARAIAAoAgANASAAEAQPCxDNAQALEM4BAAsPACAAIAEgAiADQRIQ7gELDwAgACABIAIgA0EYEO4BCw8AIAAgASACIANBHBDuAQsPACAAIAEgAiADQR0Q7gELDwAgACABIAIgA0EiEO4BCw8AIAAgASACIANBIxDuAQsPACAAIAEgAiADQSgQ7gELDwAgACABIAIgA0EqEO4BCw8AIAAgASACIANBLBDuAQsPACAAIAEgAiADQTgQ7gELEAAgACABIAIgA0HTABDvAQsQACAAIAEgAiADQdQAEO8BCxAAIAAgASACIANB3gAQ7wELEAAgACABIAIgA0HfABDvAQsQACAAIAEgAiADQeAAEO8BCxAAIAAgASACIANB4QAQ7wELEAAgACABIAIgA0HiABDvAQsQACAAIAEgAiADQeMAEO8BCxAAIAAgASACIANB5AAQ7wELEAAgACABIAIgA0HlABDvAQsQACAAIAEgAiADQeYAEO4BCxAAIAAgASACIANB5wAQ7gELEAAgACABIAIgA0HoABDuAQsQACAAIAEgAiADQekAEO4BCxAAIAAgASACIANB6gAQ7gELEAAgACABIAIgA0HrABDuAQsQACAAIAEgAiADQewAEO4BCx0BAX8jAEEQayIBJAAgAUEIaiAAEB0gAUEQaiQACx0BAX8jAEEQayIBJAAgAUEIaiAAEBMgAUEQaiQACx8AIAEQWCEBIAAQvQEgARC3AUEIdEHMAHIQxQEQuwELGQAgACABIAJBIEEAIAQbQRBBACADG3IQEgsNACAAIAEgAkEBEPABCw0AIAAgASACQQIQ8AELDQAgACABIAJBAxDwAQsNACAAIAEgAkEEEPABCw0AIAAgASACQQUQ8AELDQAgACABIAJBBhDwAQsNACAAIAEgAkEHEPABCw0AIAAgASACQQgQ8AELDQAgACABIAJBCRDwAQsNACAAIAEgAkELEPABCw0AIAAgASACQQ0Q8AELDQAgACABIAJBDhDwAQsNACAAIAEgAkEPEPABCw0AIAAgASACQRAQ8AELDQAgACABIAJBERDwAQsNACAAIAEgAkEXEPABCw0AIAAgASACQSEQ8AELDQAgACABIAJBJhDwAQsNACAAIAEgAkEnEPABCw0AIAAgASACQSkQ8AELDQAgACABIAJBKxDwAQsNACAAIAEgAkEtEPABCw0AIAAgASACQS4Q8AELDQAgACABIAJBLxDwAQsNACAAIAEgAkEwEPABCw0AIAAgASACQTEQ8AELDQAgACABIAJBNRDwAQsNACAAIAEgAkE3EPABCw0AIAAgASACQTkQ8QELDQAgACABIAJBOhDxAQsNACAAIAEgAkE7EPEBCw0AIAAgASACQTwQ8QELDQAgACABIAJBPRDxAQsNACAAIAEgAkE+EPEBCw0AIAAgASACQT8Q8QELDgAgACABIAJBwAAQ8QELDgAgACABIAJBwQAQ8QELDgAgACABIAJBwgAQ8QELDgAgACABIAJBwwAQ8QELDgAgACABIAJBxAAQ8QELDgAgACABIAJBxQAQ8QELDgAgACABIAJBxgAQ8QELDgAgACABIAJBxwAQ8QELDgAgACABIAJByAAQ8QELDgAgACABIAJByQAQ8QELDgAgACABIAJBygAQ8QELDgAgACABIAJB0QAQ8QELDgAgACABIAJB0gAQ8QELGAEBfyAAQf8BcUE/TQR/IAAQvAEFQQALCx4BAX9BCEEEELoBIgEgAK1C////B4NCIIY3AgAgAQsbACAAEMQBIAAoAgBBf0YEQBDOAQALIAAtAAQLCQAgAEETEPMBCwkAIABBFRDzAQsJACAAQRoQ8wELCQAgAEEgEPMBCwkAIABBJRDzAQsJACAAQTQQ8wELCQAgAEE2EPMBCwoAIABB2AAQ8wELCgAgAEHZABDzAQsXACABQRB0QYCA/AdxIABBAnRB/AFxcgsXACAAEMQBIAAoAgAEQBDOAQALIAAQBAscACAAEL0BIAEQvQEgAhC9ARArQQh0EMUBELsBCxIAIAEgABDHASIABEAgAA8LAAsbAQF/QQhBBBC6ASIBIAA2AgQgAUEANgIAIAELGwEBf0EIQQQQugEiASAAOgAEIAFBADYCACABC24AIABB/wFxQcAATwRAIwBBMGsiACQAIABBIjYCDCAAQYCAwAA2AgggAEEcakIBNwIAIABBATYCFCAAQbCGwAA2AhAgAEEBNgIsIAAgAEEoajYCGCAAIABBCGo2AiggAEEQakG4gMAAEEkACyAACxQAIAAgASACQSBBACADGyAEchASCxgAIAAQUSABEFEgAhBRIAMQPRDCARCsAQsXACAAEFEgARBRIAIQUSADEFEQEhCsAQsTACAAEFEgARBRIAIQBRA4EKwBCxEAIAAgASACQSBBACADGxASCxMAIAAQUSABEFEgAhBSEDgQrAELDAAgAARADwsQzQEACxQBAX9BBEEBELoBIgEgADYAACABCxQBAX9BCEEEELoBIgBCADcC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', imports)}

async function initWasm () {
  return await __wbg_init(wasm());
}

/**
 * calling it right away for pre-caching
 * the wasm async initialization at startup
 */
initWasm();

exports.ADD = ADD;
exports.ADDI = ADDI;
exports.ALOC = ALOC;
exports.AND = AND;
exports.ANDI = ANDI;
exports.BAL = BAL;
exports.BHEI = BHEI;
exports.BHSH = BHSH;
exports.BURN = BURN;
exports.CALL = CALL;
exports.CB = CB;
exports.CCP = CCP;
exports.CFE = CFE;
exports.CFEI = CFEI;
exports.CFS = CFS;
exports.CFSI = CFSI;
exports.CROO = CROO;
exports.CSIZ = CSIZ;
exports.CompareArgs = CompareArgs;
exports.CompareMode = CompareMode;
exports.DIV = DIV;
exports.DIVI = DIVI;
exports.DivArgs = DivArgs;
exports.ECAL = ECAL;
exports.ECK1 = ECK1;
exports.ECR1 = ECR1;
exports.ED19 = ED19;
exports.EQ = EQ;
exports.EXP = EXP;
exports.EXPI = EXPI;
exports.FLAG = FLAG;
exports.GM = GM;
exports.GMArgs = GMArgs;
exports.GT = GT;
exports.GTF = GTF;
exports.GTFArgs = GTFArgs;
exports.Imm06 = Imm06;
exports.Imm12 = Imm12;
exports.Imm18 = Imm18;
exports.Imm24 = Imm24;
exports.Instruction = Instruction;
exports.JI = JI;
exports.JMP = JMP;
exports.JMPB = JMPB;
exports.JMPF = JMPF;
exports.JNE = JNE;
exports.JNEB = JNEB;
exports.JNEF = JNEF;
exports.JNEI = JNEI;
exports.JNZB = JNZB;
exports.JNZF = JNZF;
exports.JNZI = JNZI;
exports.K256 = K256;
exports.LB = LB;
exports.LDC = LDC;
exports.LOG = LOG;
exports.LOGD = LOGD;
exports.LT = LT;
exports.LW = LW;
exports.MCL = MCL;
exports.MCLI = MCLI;
exports.MCP = MCP;
exports.MCPI = MCPI;
exports.MEQ = MEQ;
exports.MINT = MINT;
exports.MLDV = MLDV;
exports.MLOG = MLOG;
exports.MOD = MOD;
exports.MODI = MODI;
exports.MOVE = MOVE;
exports.MOVI = MOVI;
exports.MROO = MROO;
exports.MUL = MUL;
exports.MULI = MULI;
exports.MathArgs = MathArgs;
exports.MathOp = MathOp;
exports.MulArgs = MulArgs;
exports.NOOP = NOOP;
exports.NOT = NOT;
exports.OR = OR;
exports.ORI = ORI;
exports.POPH = POPH;
exports.POPL = POPL;
exports.PSHH = PSHH;
exports.PSHL = PSHL;
exports.PanicInstruction = PanicInstruction;
exports.PanicReason = PanicReason;
exports.RET = RET;
exports.RETD = RETD;
exports.RVRT = RVRT;
exports.RegId = RegId;
exports.S256 = S256;
exports.SB = SB;
exports.SCWQ = SCWQ;
exports.SLL = SLL;
exports.SLLI = SLLI;
exports.SMO = SMO;
exports.SRL = SRL;
exports.SRLI = SRLI;
exports.SRW = SRW;
exports.SRWQ = SRWQ;
exports.SUB = SUB;
exports.SUBI = SUBI;
exports.SW = SW;
exports.SWW = SWW;
exports.SWWQ = SWWQ;
exports.TIME = TIME;
exports.TR = TR;
exports.TRO = TRO;
exports.WDAM = WDAM;
exports.WDCM = WDCM;
exports.WDDV = WDDV;
exports.WDMD = WDMD;
exports.WDML = WDML;
exports.WDMM = WDMM;
exports.WDOP = WDOP;
exports.WQAM = WQAM;
exports.WQCM = WQCM;
exports.WQDV = WQDV;
exports.WQMD = WQMD;
exports.WQML = WQML;
exports.WQMM = WQMM;
exports.WQOP = WQOP;
exports.XOR = XOR;
exports.XORI = XORI;
exports.add = add;
exports.addi = addi;
exports.aloc = aloc;
exports.and = and;
exports.andi = andi;
exports.bal = bal;
exports.bhei = bhei;
exports.bhsh = bhsh;
exports.burn = burn;
exports.call = call;
exports.cb = cb;
exports.ccp = ccp;
exports.cfe = cfe;
exports.cfei = cfei;
exports.cfs = cfs;
exports.cfsi = cfsi;
exports.croo = croo;
exports.csiz = csiz;
exports.div = div;
exports.divi = divi;
exports.ecal = ecal;
exports.eck1 = eck1;
exports.ecr1 = ecr1;
exports.ed19 = ed19;
exports.eq = eq;
exports.exp = exp;
exports.expi = expi;
exports.flag = flag;
exports.gm = gm;
exports.gm_args = gm_args;
exports.gt = gt;
exports.gtf = gtf;
exports.gtf_args = gtf_args;
exports.initSync = initSync;
exports.initWasm = initWasm;
exports.ji = ji;
exports.jmp = jmp;
exports.jmpb = jmpb;
exports.jmpf = jmpf;
exports.jne = jne;
exports.jneb = jneb;
exports.jnef = jnef;
exports.jnei = jnei;
exports.jnzb = jnzb;
exports.jnzf = jnzf;
exports.jnzi = jnzi;
exports.k256 = k256;
exports.lb = lb;
exports.ldc = ldc;
exports.log = log;
exports.logd = logd;
exports.lt = lt;
exports.lw = lw;
exports.mcl = mcl;
exports.mcli = mcli;
exports.mcp = mcp;
exports.mcpi = mcpi;
exports.meq = meq;
exports.mint = mint;
exports.mldv = mldv;
exports.mlog = mlog;
exports.mod_ = mod_;
exports.modi = modi;
exports.move_ = move_;
exports.movi = movi;
exports.mroo = mroo;
exports.mul = mul;
exports.muli = muli;
exports.noop = noop;
exports.not = not;
exports.or = or;
exports.ori = ori;
exports.poph = poph;
exports.popl = popl;
exports.pshh = pshh;
exports.pshl = pshl;
exports.ret = ret;
exports.retd = retd;
exports.rvrt = rvrt;
exports.s256 = s256;
exports.sb = sb;
exports.scwq = scwq;
exports.sll = sll;
exports.slli = slli;
exports.smo = smo;
exports.srl = srl;
exports.srli = srli;
exports.srw = srw;
exports.srwq = srwq;
exports.sub = sub;
exports.subi = subi;
exports.sw = sw;
exports.sww = sww;
exports.swwq = swwq;
exports.time = time;
exports.tr = tr;
exports.tro = tro;
exports.wdam = wdam;
exports.wdcm = wdcm;
exports.wdcm_args = wdcm_args;
exports.wddv = wddv;
exports.wddv_args = wddv_args;
exports.wdmd = wdmd;
exports.wdml = wdml;
exports.wdml_args = wdml_args;
exports.wdmm = wdmm;
exports.wdop = wdop;
exports.wdop_args = wdop_args;
exports.wqam = wqam;
exports.wqcm = wqcm;
exports.wqcm_args = wqcm_args;
exports.wqdv = wqdv;
exports.wqdv_args = wqdv_args;
exports.wqmd = wqmd;
exports.wqml = wqml;
exports.wqml_args = wqml_args;
exports.wqmm = wqmm;
exports.wqop = wqop;
exports.wqop_args = wqop_args;
exports.xor = xor;
exports.xori = xori;
