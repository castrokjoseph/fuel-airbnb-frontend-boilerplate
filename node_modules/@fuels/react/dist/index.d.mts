import * as _tanstack_react_query from '@tanstack/react-query';
import { DefaultError, QueryKey, UndefinedInitialDataOptions, QueryClient, DefinedInitialDataOptions, UseQueryResult, DefinedUseQueryResult } from '@tanstack/react-query';
import * as fuels from 'fuels';
import { BytesLike, ChainInfo, Asset, TransactionResultReceipt, Fuel, FuelConnector, FuelConfig } from 'fuels';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { ReactNode } from 'react';

type ExcludeData<T> = Omit<T, 'data'>;
type NamedUseQueryResult<TName extends string, TQueryFnData = unknown, TError = DefaultError> = ExcludeData<UseQueryResult<TQueryFnData, TError>> & {
    [key in TName]: UseQueryResult<TQueryFnData, TError>['data'];
};
type DefinedNamedUseQueryResult<TName extends string, TQueryFnData = unknown, TError = DefaultError> = ExcludeData<DefinedUseQueryResult<TQueryFnData, TError>> & {
    [key in TName]: DefinedUseQueryResult<TQueryFnData, TError>['data'];
};
/**
 * When initialData is not provided "data" will be always TQueryFnData | undefined.
 * It might need some type checking to be sure that the data is not undefined.
 */
declare function useNamedQuery<TName extends string, TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(name: TName, options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>, queryClient?: QueryClient): NamedUseQueryResult<TName, TData, TError>;
/**
 * When initialData is provided "data" will be always TQueryFnData.
 * Never undefined.
 */
declare function useNamedQuery<TName extends string, TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(name: TName, options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>, queryClient?: QueryClient): DefinedNamedUseQueryResult<TName, TData, TError>;

declare const useAccount: () => {
    error: Error | null;
    isError: boolean;
    isPending: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<string | null, Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    account: string | null;
};

declare const useAccounts: () => {
    error: Error | null;
    isError: boolean;
    isPending: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<string[], Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    accounts: string[];
};

declare const useBalance: ({ address, assetId, }: {
    address?: string | undefined;
    assetId?: BytesLike | undefined;
}) => {
    error: Error | null;
    isError: boolean;
    isPending: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<fuels.BN | null, Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    balance: fuels.BN | null;
};

declare const useChain: () => {
    error: Error | null;
    isError: boolean;
    isPending: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<ChainInfo | null, Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    chain: ChainInfo | null;
};

declare const useAssets: () => {
    error: Error | null;
    isError: boolean;
    isPending: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<Asset[], Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    assets: Asset[];
};

declare const useAddNetwork: () => {
    data: undefined;
    variables: undefined;
    error: null;
    isError: false;
    isIdle: true;
    isPending: false;
    isSuccess: false;
    status: "idle";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    addNetwork: (networkUrl: string) => void;
    addNetworkAsync: (networkUrl: string) => Promise<boolean>;
} | {
    data: undefined;
    variables: string;
    error: null;
    isError: false;
    isIdle: false;
    isPending: true;
    isSuccess: false;
    status: "pending";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    addNetwork: (networkUrl: string) => void;
    addNetworkAsync: (networkUrl: string) => Promise<boolean>;
} | {
    data: undefined;
    error: Error;
    variables: string;
    isError: true;
    isIdle: false;
    isPending: false;
    isSuccess: false;
    status: "error";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    addNetwork: (networkUrl: string) => void;
    addNetworkAsync: (networkUrl: string) => Promise<boolean>;
} | {
    data: boolean;
    error: null;
    variables: string;
    isError: false;
    isIdle: false;
    isPending: false;
    isSuccess: true;
    status: "success";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    addNetwork: (networkUrl: string) => void;
    addNetworkAsync: (networkUrl: string) => Promise<boolean>;
};

declare const useNetwork: () => {
    error: Error | null;
    isError: boolean;
    isPending: boolean;
    isLoading: boolean;
    isLoadingError: boolean;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success" | "pending";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<fuels.Network, Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    network: fuels.Network | undefined;
};

declare const useAddAssets: () => {
    data: undefined;
    variables: undefined;
    error: null;
    isError: false;
    isIdle: true;
    isPending: false;
    isSuccess: false;
    status: "idle";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    addAssets: (assets: Asset | Asset[]) => void;
    addAssetsAsync: (assets: Asset | Asset[]) => Promise<boolean>;
} | {
    data: undefined;
    variables: Asset | Asset[];
    error: null;
    isError: false;
    isIdle: false;
    isPending: true;
    isSuccess: false;
    status: "pending";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    addAssets: (assets: Asset | Asset[]) => void;
    addAssetsAsync: (assets: Asset | Asset[]) => Promise<boolean>;
} | {
    data: undefined;
    error: Error;
    variables: Asset | Asset[];
    isError: true;
    isIdle: false;
    isPending: false;
    isSuccess: false;
    status: "error";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    addAssets: (assets: Asset | Asset[]) => void;
    addAssetsAsync: (assets: Asset | Asset[]) => Promise<boolean>;
} | {
    data: boolean;
    error: null;
    variables: Asset | Asset[];
    isError: false;
    isIdle: false;
    isPending: false;
    isSuccess: true;
    status: "success";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    addAssets: (assets: Asset | Asset[]) => void;
    addAssetsAsync: (assets: Asset | Asset[]) => Promise<boolean>;
};

declare const useConnect: () => {
    data: undefined;
    variables: undefined;
    error: null;
    isError: false;
    isIdle: true;
    isPending: false;
    isSuccess: false;
    status: "idle";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    connect: (connectorName?: string | null) => void;
    connectAsync: (connectorName?: string | null) => Promise<boolean>;
} | {
    data: undefined;
    variables: string | null | undefined;
    error: null;
    isError: false;
    isIdle: false;
    isPending: true;
    isSuccess: false;
    status: "pending";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    connect: (connectorName?: string | null) => void;
    connectAsync: (connectorName?: string | null) => Promise<boolean>;
} | {
    data: undefined;
    error: Error;
    variables: string | null | undefined;
    isError: true;
    isIdle: false;
    isPending: false;
    isSuccess: false;
    status: "error";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    connect: (connectorName?: string | null) => void;
    connectAsync: (connectorName?: string | null) => Promise<boolean>;
} | {
    data: boolean;
    error: null;
    variables: string | null | undefined;
    isError: false;
    isIdle: false;
    isPending: false;
    isSuccess: true;
    status: "success";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    connect: (connectorName?: string | null) => void;
    connectAsync: (connectorName?: string | null) => Promise<boolean>;
};

declare const useConnectors: () => {
    error: Error | null;
    isError: boolean;
    isPending: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<fuels.FuelConnector[], Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    connectors: fuels.FuelConnector[];
};

declare const useDisconnect: () => {
    data: undefined;
    variables: undefined;
    error: null;
    isError: false;
    isIdle: true;
    isPending: false;
    isSuccess: false;
    status: "idle";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    disconnect: _tanstack_react_query.UseMutateFunction<boolean, Error, void, unknown>;
    disconnectAsync: _tanstack_react_query.UseMutateAsyncFunction<boolean, Error, void, unknown>;
} | {
    data: undefined;
    variables: void;
    error: null;
    isError: false;
    isIdle: false;
    isPending: true;
    isSuccess: false;
    status: "pending";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    disconnect: _tanstack_react_query.UseMutateFunction<boolean, Error, void, unknown>;
    disconnectAsync: _tanstack_react_query.UseMutateAsyncFunction<boolean, Error, void, unknown>;
} | {
    data: undefined;
    error: Error;
    variables: void;
    isError: true;
    isIdle: false;
    isPending: false;
    isSuccess: false;
    status: "error";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    disconnect: _tanstack_react_query.UseMutateFunction<boolean, Error, void, unknown>;
    disconnectAsync: _tanstack_react_query.UseMutateAsyncFunction<boolean, Error, void, unknown>;
} | {
    data: boolean;
    error: null;
    variables: void;
    isError: false;
    isIdle: false;
    isPending: false;
    isSuccess: true;
    status: "success";
    reset: () => void;
    context: unknown;
    failureCount: number;
    failureReason: Error | null;
    isPaused: boolean;
    submittedAt: number;
    disconnect: _tanstack_react_query.UseMutateFunction<boolean, Error, void, unknown>;
    disconnectAsync: _tanstack_react_query.UseMutateAsyncFunction<boolean, Error, void, unknown>;
};

declare const useIsConnected: () => {
    error: Error | null;
    isError: boolean;
    isPending: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<boolean | null, Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    isConnected: boolean | null;
};

type NodeInfoParams = {
    version?: string;
};
declare const useNodeInfo: ({ version }?: NodeInfoParams) => {
    error: Error | null;
    isError: boolean;
    isPending: boolean;
    isLoading: boolean;
    isLoadingError: boolean;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success" | "pending";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<fuels.NodeInfo | undefined, Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    nodeInfo: fuels.NodeInfo | undefined;
} & {
    isCompatible: boolean;
};

declare const useProvider: () => {
    error: Error | null;
    isError: boolean;
    isPending: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<fuels.Provider | null, Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    provider: fuels.Provider | null;
};

declare const useTransaction: (txId?: string) => {
    error: Error | null;
    isError: boolean;
    isPending: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<(Partial<Omit<fuels.TransactionScript, "type">> & Partial<Omit<fuels.TransactionCreate, "type">> & Partial<Omit<fuels.TransactionMint, "type">> & Partial<Omit<fuels.TransactionUpgrade, "type">> & Partial<Omit<fuels.TransactionUpload, "type">> & {
        type: fuels.TransactionType;
    }) | null, Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    transaction: (Partial<Omit<fuels.TransactionScript, "type">> & Partial<Omit<fuels.TransactionCreate, "type">> & Partial<Omit<fuels.TransactionMint, "type">> & Partial<Omit<fuels.TransactionUpgrade, "type">> & Partial<Omit<fuels.TransactionUpload, "type">> & {
        type: fuels.TransactionType;
    }) | null;
};

declare const useTransactionReceipts: ({ txId }: {
    txId?: string | undefined;
}) => {
    error: Error | null;
    isError: boolean;
    isPending: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<TransactionResultReceipt[] | null, Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    transactionReceipts: TransactionResultReceipt[] | null;
};

declare const useWallet: (address?: string | null) => {
    error: Error | null;
    isError: boolean;
    isPending: boolean;
    isLoading: boolean;
    isLoadingError: boolean;
    isRefetchError: boolean;
    isSuccess: boolean;
    status: "error" | "success" | "pending";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    failureReason: Error | null;
    errorUpdateCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isInitialLoading: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: (options?: _tanstack_react_query.RefetchOptions | undefined) => Promise<_tanstack_react_query.QueryObserverResult<fuels.Account | null, Error>>;
    fetchStatus: _tanstack_react_query.FetchStatus;
} & {
    wallet: fuels.Account | null | undefined;
};

declare const QUERY_KEYS: {
    base: QueryKey;
    account: () => QueryKey;
    accounts: () => QueryKey;
    assets: () => QueryKey;
    chain: () => QueryKey;
    isConnected: () => QueryKey;
    provider: () => QueryKey;
    balance: (address?: string, assetId?: BytesLike) => QueryKey;
    wallet: (address?: string | null) => QueryKey;
    transaction: (id?: string) => QueryKey;
    transactionReceipts: (id?: string) => QueryKey;
    nodeInfo: (url?: string) => QueryKey;
    connectorList: () => QueryKey;
    currentConnector: () => QueryKey;
    currentNetwork: () => QueryKey;
};
declare const MUTATION_KEYS: {
    connect: string;
    addAssets: string;
    addNetwork: string;
};

declare function selectCurrentConnector(fuel: Fuel, connectors: Array<FuelConnector>): Promise<boolean> | undefined;

type Connector = {
    name: string;
    image: string | {
        light: string;
        dark: string;
    };
    connector: string;
    install: {
        action: string;
        link: string;
        description: string;
    };
    installed: boolean;
};
type ConnectorList = Array<Connector>;

type FuelUIProviderProps = {
    children?: ReactNode;
    fuelConfig: FuelConfig;
    theme?: string;
};
type FuelUIContextType = {
    fuelConfig: FuelConfig;
    theme: string;
    connectors: Array<FuelConnector>;
    isLoading: boolean;
    isConnecting: boolean;
    isError: boolean;
    connect: () => void;
    cancel: () => void;
    error: Error | null;
    dialog: {
        connector: FuelConnector | null;
        isOpen: boolean;
        back: () => void;
        connect: (connector: FuelConnector) => void;
    };
};
declare const useConnectUI: () => FuelUIContextType;

type FuelReactContextType = {
    fuel: Fuel;
};
declare const useFuel: () => FuelReactContextType;

type FuelProviderProps = {
    ui?: boolean;
    fuelConfig?: FuelConfig;
} & FuelUIProviderProps;
declare function FuelProvider({ theme, children, fuelConfig, ui, }: FuelProviderProps): react_jsx_runtime.JSX.Element;

export { Connector, ConnectorList, FuelProvider, MUTATION_KEYS, QUERY_KEYS, selectCurrentConnector, useAccount, useAccounts, useAddAssets, useAddNetwork, useAssets, useBalance, useChain, useConnect, useConnectUI, useConnectors, useDisconnect, useFuel, useIsConnected, useNamedQuery, useNetwork, useNodeInfo, useProvider, useTransaction, useTransactionReceipts, useWallet };
