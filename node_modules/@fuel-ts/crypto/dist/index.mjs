// src/shared/scrypt.ts
import { scrypt as scryptNoble } from "@noble/hashes/scrypt";
var scrypt = (params) => {
  const { password, salt, n, p, r, dklen } = params;
  const derivedKey = scryptNoble(password, salt, { N: n, r, p, dkLen: dklen });
  return derivedKey;
};

// src/shared/keccak256.ts
import { keccak_256 } from "@noble/hashes/sha3";
var keccak256 = (data) => keccak_256(data);

// src/shared/ripemd160.ts
import { ErrorCode, FuelError } from "@fuel-ts/errors";
import { arrayify } from "@fuel-ts/utils";
import { ripemd160 as noble_ripemd160 } from "@noble/hashes/ripemd160";
var locked = false;
var helper = (data) => noble_ripemd160(data);
var ripemd = helper;
function ripemd160(_data) {
  const data = arrayify(_data, "data");
  return ripemd(data);
}
ripemd160._ = helper;
ripemd160.lock = () => {
  locked = true;
};
ripemd160.register = (func) => {
  if (locked) {
    throw new FuelError(ErrorCode.HASHER_LOCKED, "ripemd160 is locked");
  }
  ripemd = func;
};
Object.freeze(ripemd160);

// src/node/aes-ctr.ts
import { FuelError as FuelError3, ErrorCode as ErrorCode3 } from "@fuel-ts/errors";
import { arrayify as arrayify3 } from "@fuel-ts/utils";
import crypto2 from "crypto";

// src/node/bufferFromString.ts
var bufferFromString = (string, encoding = "base64") => Uint8Array.from(Buffer.from(string, encoding));

// src/node/pbkdf2.ts
import { ErrorCode as ErrorCode2, FuelError as FuelError2 } from "@fuel-ts/errors";
import { arrayify as arrayify2, hexlify } from "@fuel-ts/utils";
import { pbkdf2Sync } from "crypto";
var locked2 = false;
var PBKDF2 = (password, salt, iterations, keylen, algo) => pbkdf2Sync(password, salt, iterations, keylen, algo);
var pBkdf2 = PBKDF2;
function pbkdf2(_password, _salt, iterations, keylen, algo) {
  const password = arrayify2(_password, "password");
  const salt = arrayify2(_salt, "salt");
  return hexlify(pBkdf2(password, salt, iterations, keylen, algo));
}
pbkdf2._ = PBKDF2;
pbkdf2.lock = () => {
  locked2 = true;
};
pbkdf2.register = (func) => {
  if (locked2) {
    throw new FuelError2(ErrorCode2.HASHER_LOCKED, "pbkdf2 is locked");
  }
  pBkdf2 = func;
};
Object.freeze(pbkdf2);

// src/node/randomBytes.ts
import crypto from "crypto";
var randomBytes = (length) => {
  const randomValues = Uint8Array.from(crypto.randomBytes(length));
  return randomValues;
};

// src/node/stringFromBuffer.ts
var stringFromBuffer = (buffer, encoding = "base64") => Buffer.from(buffer).toString(encoding);

// src/node/aes-ctr.ts
var ALGORITHM = "aes-256-ctr";
var keyFromPassword = (password, saltBuffer) => {
  const passBuffer = bufferFromString(String(password).normalize("NFKC"), "utf-8");
  const key = pbkdf2(passBuffer, saltBuffer, 1e5, 32, "sha256");
  return arrayify3(key);
};
var encrypt = async (password, data) => {
  const iv = randomBytes(16);
  const salt = randomBytes(32);
  const secret = keyFromPassword(password, salt);
  const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), "utf-8"));
  const cipher = await crypto2.createCipheriv(ALGORITHM, secret, iv);
  let cipherData = cipher.update(dataBuffer);
  cipherData = Buffer.concat([cipherData, cipher.final()]);
  return {
    data: stringFromBuffer(cipherData),
    iv: stringFromBuffer(iv),
    salt: stringFromBuffer(salt)
  };
};
var decrypt = async (password, keystore) => {
  const iv = bufferFromString(keystore.iv);
  const salt = bufferFromString(keystore.salt);
  const secret = keyFromPassword(password, salt);
  const encryptedText = bufferFromString(keystore.data);
  const decipher = await crypto2.createDecipheriv(ALGORITHM, secret, iv);
  const decrypted = decipher.update(encryptedText);
  const deBuff = Buffer.concat([decrypted, decipher.final()]);
  const decryptedData = Buffer.from(deBuff).toString("utf-8");
  try {
    return JSON.parse(decryptedData);
  } catch {
    throw new FuelError3(ErrorCode3.INVALID_CREDENTIALS, "Invalid credentials.");
  }
};

// src/node/encryptJsonWalletData.ts
import crypto3 from "crypto";
async function encryptJsonWalletData(data, key, iv) {
  const cipher = await crypto3.createCipheriv("aes-128-ctr", key.subarray(0, 16), iv);
  const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);
  return new Uint8Array(encrypted);
}
async function decryptJsonWalletData(data, key, iv) {
  const decipher = crypto3.createDecipheriv("aes-128-ctr", key.subarray(0, 16), iv);
  const decrypted = await Buffer.concat([decipher.update(data), decipher.final()]);
  return new Uint8Array(decrypted);
}

// src/node/hmac.ts
import { FuelError as FuelError4, ErrorCode as ErrorCode4 } from "@fuel-ts/errors";
import { arrayify as arrayify4, hexlify as hexlify2 } from "@fuel-ts/utils";
import { createHmac } from "crypto";
var locked3 = false;
var COMPUTEHMAC = (algorithm, key, data) => createHmac(algorithm, key).update(data).digest();
var computeHMAC = COMPUTEHMAC;
function computeHmac(algorithm, _key, _data) {
  const key = arrayify4(_key, "key");
  const data = arrayify4(_data, "data");
  return hexlify2(computeHMAC(algorithm, key, data));
}
computeHmac._ = COMPUTEHMAC;
computeHmac.lock = () => {
  locked3 = true;
};
computeHmac.register = (func) => {
  if (locked3) {
    throw new FuelError4(ErrorCode4.HASHER_LOCKED, "computeHmac is locked");
  }
  computeHMAC = func;
};
Object.freeze(computeHmac);

// src/node/index.ts
var api = {
  bufferFromString,
  stringFromBuffer,
  decrypt,
  encrypt,
  keyFromPassword,
  randomBytes,
  scrypt,
  keccak256,
  decryptJsonWalletData,
  encryptJsonWalletData,
  computeHmac,
  pbkdf2,
  ripemd160
};
var node_default = api;

// src/index.ts
var {
  bufferFromString: bufferFromString2,
  decrypt: decrypt2,
  encrypt: encrypt2,
  keyFromPassword: keyFromPassword2,
  randomBytes: randomBytes2,
  stringFromBuffer: stringFromBuffer2,
  scrypt: scrypt2,
  keccak256: keccak2562,
  decryptJsonWalletData: decryptJsonWalletData2,
  encryptJsonWalletData: encryptJsonWalletData2,
  computeHmac: computeHmac2,
  pbkdf2: pbkdf22,
  ripemd160: ripemd1602
} = node_default;
export {
  bufferFromString2 as bufferFromString,
  computeHmac2 as computeHmac,
  decrypt2 as decrypt,
  decryptJsonWalletData2 as decryptJsonWalletData,
  encrypt2 as encrypt,
  encryptJsonWalletData2 as encryptJsonWalletData,
  keccak2562 as keccak256,
  keyFromPassword2 as keyFromPassword,
  pbkdf22 as pbkdf2,
  randomBytes2 as randomBytes,
  ripemd1602 as ripemd160,
  scrypt2 as scrypt,
  stringFromBuffer2 as stringFromBuffer
};
//# sourceMappingURL=index.mjs.map