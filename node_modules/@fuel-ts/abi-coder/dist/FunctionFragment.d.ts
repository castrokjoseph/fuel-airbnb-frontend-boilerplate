import type { BytesLike } from '@fuel-ts/interfaces';
import type { DecodedValue, InputValue } from './encoding/coders/AbstractCoder';
import type { JsonAbi, JsonAbiFunction, JsonAbiFunctionAttribute } from './types/JsonAbi';
import type { EncodingVersion } from './utils/constants';
export declare class FunctionFragment<TAbi extends JsonAbi = JsonAbi, FnName extends TAbi['functions'][number]['name'] = string> {
    readonly signature: string;
    readonly selector: string;
    readonly selectorBytes: Uint8Array;
    readonly encoding: EncodingVersion;
    readonly name: string;
    readonly jsonFn: JsonAbiFunction;
    readonly attributes: readonly JsonAbiFunctionAttribute[];
    private readonly jsonAbi;
    constructor(jsonAbi: JsonAbi, name: FnName);
    private static getSignature;
    private static getFunctionSelector;
    encodeArguments(values: InputValue[]): Uint8Array;
    private static verifyArgsAndInputsAlign;
    decodeArguments(data: BytesLike): unknown[] | undefined;
    decodeOutput(data: BytesLike): [DecodedValue | undefined, number];
    /**
     * Checks if the function is read-only i.e. it only reads from storage, does not write to it.
     *
     * @returns True if the function is read-only or pure, false otherwise.
     */
    isReadOnly(): boolean;
}
//# sourceMappingURL=FunctionFragment.d.ts.map