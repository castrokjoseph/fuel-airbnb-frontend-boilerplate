{"version":3,"sources":["../src/encoding/coders/AbstractCoder.ts","../src/encoding/coders/ArrayCoder.ts","../src/utils/constants.ts","../src/utils/utilities.ts","../src/encoding/coders/B256Coder.ts","../src/encoding/coders/B512Coder.ts","../src/encoding/coders/BigNumberCoder.ts","../src/encoding/coders/BooleanCoder.ts","../src/encoding/coders/ByteCoder.ts","../src/encoding/coders/EnumCoder.ts","../src/encoding/coders/NumberCoder.ts","../src/encoding/coders/OptionCoder.ts","../src/encoding/coders/RawSliceCoder.ts","../src/encoding/coders/StdStringCoder.ts","../src/encoding/coders/StrSliceCoder.ts","../src/encoding/coders/StringCoder.ts","../src/encoding/coders/StructCoder.ts","../src/encoding/coders/TupleCoder.ts","../src/encoding/coders/VecCoder.ts","../src/Interface.ts","../src/ResolvedAbiType.ts","../src/utils/json-abi.ts","../src/encoding/strategies/getCoderForEncoding.ts","../src/encoding/strategies/getCoderV1.ts","../src/encoding/strategies/getCoders.ts","../src/AbiCoder.ts","../src/FunctionFragment.ts"],"sourcesContent":["import type { BytesLike } from '@fuel-ts/interfaces';\nimport type { BN } from '@fuel-ts/math';\n\nimport type { Option } from './OptionCoder';\n\ntype Primitive = string | number | boolean;\n\n/**\n * The type of value you can provide to `Coder.encode`\n */\nexport type InputValue<T = void> =\n  | Primitive\n  | BN\n  | Option<T>\n  | BytesLike\n  | InputValue[]\n  | { [key: string]: InputValue }\n  | Record<string, Primitive | BytesLike>;\n\n/**\n * The type of value you can get from `Coder.decode`\n */\nexport type DecodedValue =\n  | Primitive\n  | DecodedValue[]\n  | { [key: string]: DecodedValue }\n  | Record<string, Primitive>;\n\nexport type TypesOfCoder<TCoder> = TCoder extends Coder<infer TInput, infer TDecoded>\n  ? { Input: TInput; Decoded: TDecoded }\n  : never;\n\nexport abstract class Coder<TInput = unknown, TDecoded = unknown> {\n  readonly name: string;\n  readonly type: string;\n  readonly encodedLength: number;\n\n  constructor(name: string, type: string, encodedLength: number) {\n    this.name = name;\n    this.type = type;\n    this.encodedLength = encodedLength;\n  }\n\n  abstract encode(value: TInput, length?: number): Uint8Array;\n\n  abstract decode(data: Uint8Array, offset: number, length?: number): [TDecoded, number];\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { concat } from '@fuel-ts/utils';\n\nimport { MAX_BYTES } from '../../utils/constants';\nimport { hasNestedOption } from '../../utils/utilities';\n\nimport type { TypesOfCoder } from './AbstractCoder';\nimport { Coder } from './AbstractCoder';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport class ArrayCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n  length: number;\n  #hasNestedOption: boolean;\n\n  constructor(coder: TCoder, length: number) {\n    super('array', `[${coder.type}; ${length}]`, length * coder.encodedLength);\n    this.coder = coder;\n    this.length = length;\n    this.#hasNestedOption = hasNestedOption([coder]);\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    if (this.length !== value.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n\n    return concat(Array.from(value).map((v) => this.coder.encode(v)));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    if ((!this.#hasNestedOption && data.length < this.encodedLength) || data.length > MAX_BYTES) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid array data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = Array(this.length)\n      .fill(0)\n      .map(() => {\n        let decoded;\n        [decoded, newOffset] = this.coder.decode(data, newOffset);\n        return decoded;\n      });\n\n    return [decodedValue as DecodedValueOf<TCoder>, newOffset];\n  }\n}\n","/**\n * Types and Type Regex\n */\nexport const U8_CODER_TYPE = 'u8';\nexport const U16_CODER_TYPE = 'u16';\nexport const U32_CODER_TYPE = 'u32';\nexport const U64_CODER_TYPE = 'u64';\nexport const U256_CODER_TYPE = 'u256';\nexport const RAW_PTR_CODER_TYPE = 'raw untyped ptr';\nexport const RAW_SLICE_CODER_TYPE = 'raw untyped slice';\nexport const BOOL_CODER_TYPE = 'bool';\nexport const B256_CODER_TYPE = 'b256';\nexport const B512_CODER_TYPE = 'struct B512';\nexport const OPTION_CODER_TYPE = 'enum Option';\nexport const VEC_CODER_TYPE = 'struct Vec';\nexport const BYTES_CODER_TYPE = 'struct Bytes';\nexport const STD_STRING_CODER_TYPE = 'struct String';\nexport const STR_SLICE_CODER_TYPE = 'str';\nexport const stringRegEx = /str\\[(?<length>[0-9]+)\\]/;\nexport const arrayRegEx = /\\[(?<item>[\\w\\s\\\\[\\]]+);\\s*(?<length>[0-9]+)\\]/;\nexport const structRegEx = /^struct (?<name>\\w+)$/;\nexport const enumRegEx = /^enum (?<name>\\w+)$/;\nexport const tupleRegEx = /^\\((?<items>.*)\\)$/;\nexport const genericRegEx = /^generic (?<name>\\w+)$/;\n/**\n * Encoding versions\n */\nexport const ENCODING_V1 = '1';\nexport type EncodingVersion = typeof ENCODING_V1;\n\n/**\n * Property space and config constants\n */\nexport const WORD_SIZE = 8;\nexport const BYTES_32 = 32;\nexport const UTXO_ID_LEN = BYTES_32 + 2;\nexport const MAX_INPUTS = 255;\nexport const ASSET_ID_LEN = BYTES_32;\nexport const CONTRACT_ID_LEN = BYTES_32;\nexport const ADDRESS_LEN = BYTES_32;\nexport const NONCE_LEN = BYTES_32;\nexport const TX_LEN = WORD_SIZE * 4;\nexport const TX_POINTER_LEN = WORD_SIZE * 2;\nexport const MAX_BYTES = 2 ** 32 - 1; // Max u32\n\nexport const calculateVmTxMemory = ({ maxInputs }: { maxInputs: number }) =>\n  BYTES_32 + // Tx ID\n  ASSET_ID_LEN + // Base asset ID\n  // Asset ID/Balance coin input pairs\n  maxInputs * (ASSET_ID_LEN + WORD_SIZE) +\n  WORD_SIZE; // Tx size\n\n// SCRIPT_FIXED_SIZE = 104\nexport const SCRIPT_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  WORD_SIZE + // Gas limit\n  WORD_SIZE + // Script size\n  WORD_SIZE + // Script data size\n  WORD_SIZE + // Policies\n  WORD_SIZE + // Inputs size\n  WORD_SIZE + // Outputs size\n  WORD_SIZE + // Witnesses size\n  BYTES_32; // Receipts root\n\n// INPUT_COIN_FIXED_SIZE = 176\nexport const INPUT_COIN_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  TX_LEN + // Utxo Length\n  WORD_SIZE + // Output Index\n  ADDRESS_LEN + // Owner\n  WORD_SIZE + // Amount\n  ASSET_ID_LEN + // Asset id\n  TX_POINTER_LEN + // TxPointer\n  WORD_SIZE + // Witnesses index\n  WORD_SIZE + // Predicate size\n  WORD_SIZE + // Predicate data size\n  WORD_SIZE; // Predicate gas used\n\n// INPUT_MESSAGE_FIXED_SIZE = 168\nexport const INPUT_MESSAGE_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  ADDRESS_LEN + // Sender\n  ADDRESS_LEN + // Recipient\n  WORD_SIZE + // Amount\n  NONCE_LEN + // Nonce\n  WORD_SIZE + // witness_index\n  WORD_SIZE + // Data size\n  WORD_SIZE + // Predicate size\n  WORD_SIZE + // Predicate data size\n  WORD_SIZE; // Predicate gas used\n","import type { Coder } from '../encoding/coders/AbstractCoder';\n\nimport { OPTION_CODER_TYPE, WORD_SIZE } from './constants';\n\n/**\n * Turns:\n  Uint8Array(24) [\n    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 24\n  ]\n\n  Into:\n  Array [\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 1\n    ],\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 2\n    ],\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 24\n    ]\n  ]\n *\n */\nexport const chunkByLength = (data: Uint8Array, length = WORD_SIZE): Uint8Array[] => {\n  const chunks = [];\n  let offset = 0;\n  let chunk = data.slice(offset, offset + length);\n  while (chunk.length) {\n    chunks.push(chunk);\n    offset += length;\n    chunk = data.slice(offset, offset + length);\n  }\n\n  return chunks;\n};\n\nexport const isUint8Array = (value: unknown): value is Uint8Array => value instanceof Uint8Array;\n\nexport type TCoders = Record<string, Coder>;\n\n/**\n * Finds a deeply nested option in a coders object.\n *\n * @param coders - the coders object to search.\n * @returns - whether the coder has been found.\n */\nexport const hasNestedOption = (coders: Record<string, Coder> | Coder[]): boolean => {\n  const array = Array.isArray(coders) ? coders : Object.values(coders);\n\n  for (const node of array) {\n    if (node.type === OPTION_CODER_TYPE) {\n      return true;\n    }\n\n    if ('coder' in node && (node.coder as Coder).type === OPTION_CODER_TYPE) {\n      return true;\n    }\n\n    if ('coders' in node) {\n      const child = hasNestedOption(node.coders as TCoders);\n      if (child) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toHex } from '@fuel-ts/math';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\n\nexport class B256Coder extends Coder<string, string> {\n  constructor() {\n    super('b256', 'b256', WORD_SIZE * 4);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = arrayify(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    if (encodedValue.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b256 data size.`);\n    }\n\n    let bytes = data.slice(offset, offset + this.encodedLength);\n\n    const decoded = bn(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(32);\n    }\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b256 byte data size.`);\n    }\n\n    return [toHex(bytes, 32), offset + 32];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toHex } from '@fuel-ts/math';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\n\nexport class B512Coder extends Coder<string, string> {\n  constructor() {\n    super('b512', 'struct B512', WORD_SIZE * 8);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = arrayify(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    if (encodedValue.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b512 data size.`);\n    }\n\n    let bytes = data.slice(offset, offset + this.encodedLength);\n\n    const decoded = bn(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(64);\n    }\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b512 byte data size.`);\n    }\n\n    return [toHex(bytes, this.encodedLength), offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { type BNInput, type BN, toBytes, bn } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\n\ntype BigNumberCoderType = 'u64' | 'u256';\n\nconst encodedLengths: { [key in BigNumberCoderType]: number } = {\n  u64: WORD_SIZE,\n  u256: WORD_SIZE * 4,\n};\n\nexport class BigNumberCoder extends Coder<BNInput, BN> {\n  constructor(baseType: BigNumberCoderType) {\n    super('bigNumber', baseType, encodedLengths[baseType]);\n  }\n\n  encode(value: BNInput): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value, this.encodedLength);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n\n    return bytes;\n  }\n\n  decode(data: Uint8Array, offset: number): [BN, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid ${this.type} data size.`);\n    }\n\n    let bytes = data.slice(offset, offset + this.encodedLength);\n    bytes = bytes.slice(0, this.encodedLength);\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid ${this.type} byte data size.`);\n    }\n\n    return [bn(bytes), offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toBytes } from '@fuel-ts/math';\n\nimport type { EncodingOptions } from '../../types/EncodingOptions';\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\n\nexport class BooleanCoder extends Coder<boolean, boolean> {\n  options: EncodingOptions;\n\n  constructor(\n    options: EncodingOptions = {\n      padToWordSize: false,\n    }\n  ) {\n    const encodedLength = options.padToWordSize ? WORD_SIZE : 1;\n    super('boolean', 'boolean', encodedLength);\n\n    this.options = options;\n  }\n\n  encode(value: boolean): Uint8Array {\n    const isTrueBool = value === true || value === false;\n\n    if (!isTrueBool) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);\n    }\n\n    return toBytes(value ? 1 : 0, this.encodedLength);\n  }\n\n  decode(data: Uint8Array, offset: number): [boolean, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean data size.`);\n    }\n\n    const bytes = bn(data.slice(offset, offset + this.encodedLength));\n\n    if (bytes.isZero()) {\n      return [false, offset + this.encodedLength];\n    }\n\n    if (!bytes.eq(bn(1))) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean value.`);\n    }\n\n    return [true, offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\n\nexport class ByteCoder extends Coder<number[], Uint8Array> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct Bytes', WORD_SIZE);\n  }\n\n  encode(value: number[] | Uint8Array): Uint8Array {\n    const bytes = value instanceof Uint8Array ? value : new Uint8Array(value);\n    const lengthBytes = new BigNumberCoder('u64').encode(bytes.length);\n\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n\n  decode(data: Uint8Array, offset: number): [Uint8Array, number] {\n    if (data.length < WORD_SIZE) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid byte data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (dataBytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid bytes byte data size.`);\n    }\n\n    return [dataBytes, offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber } from '@fuel-ts/math';\nimport { concat } from '@fuel-ts/utils';\nimport type { RequireExactlyOne } from 'type-fest';\n\nimport { OPTION_CODER_TYPE } from '../../utils/constants';\nimport { hasNestedOption } from '../../utils/utilities';\n\nimport type { TypesOfCoder } from './AbstractCoder';\nimport { Coder } from './AbstractCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\n\nexport type InputValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n}>;\nexport type DecodedValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n}>;\n\nconst isFullyNativeEnum = (enumCoders: { [s: string]: unknown } | ArrayLike<unknown>): boolean =>\n  Object.values(enumCoders).every(\n    // @ts-expect-error complicated types\n    ({ type, coders }) => type === '()' && JSON.stringify(coders) === JSON.stringify([])\n  );\n\nexport class EnumCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n  #caseIndexCoder: BigNumberCoder;\n  #encodedValueSize: number;\n  #shouldValidateLength: boolean;\n\n  constructor(name: string, coders: TCoders) {\n    const caseIndexCoder = new BigNumberCoder('u64');\n    const encodedValueSize = Object.values(coders).reduce(\n      (min, coder) => Math.min(min, coder.encodedLength),\n      0\n    );\n    super(`enum ${name}`, `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);\n    this.name = name;\n    this.coders = coders;\n    this.#caseIndexCoder = caseIndexCoder;\n    this.#encodedValueSize = encodedValueSize;\n    this.#shouldValidateLength = !(this.type === OPTION_CODER_TYPE || hasNestedOption(coders));\n  }\n\n  #encodeNativeEnum(value: string): Uint8Array {\n    const valueCoder = this.coders[value];\n    const encodedValue = valueCoder.encode([]);\n    const caseIndex = Object.keys(this.coders).indexOf(value);\n\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return concat([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (typeof value === 'string' && this.coders[value]) {\n      return this.#encodeNativeEnum(value);\n    }\n\n    const [caseKey, ...empty] = Object.keys(value);\n    if (!caseKey) {\n      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, 'A field for the case must be provided.');\n    }\n    if (empty.length !== 0) {\n      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, 'Only one field must be provided.');\n    }\n    const valueCoder = this.coders[caseKey];\n    const caseIndex = Object.keys(this.coders).indexOf(caseKey);\n    const encodedValue = valueCoder.encode(value[caseKey]);\n\n    return new Uint8Array([...this.#caseIndexCoder.encode(caseIndex), ...encodedValue]);\n  }\n\n  #decodeNativeEnum(caseKey: string, newOffset: number): [DecodedValueOf<TCoders>, number] {\n    return [caseKey as unknown as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (this.#shouldValidateLength && data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid enum data size.`);\n    }\n\n    const caseBytes = new BigNumberCoder('u64').decode(data, offset)[0];\n    const caseIndex = toNumber(caseBytes);\n    const caseKey = Object.keys(this.coders)[caseIndex];\n    if (!caseKey) {\n      throw new FuelError(\n        ErrorCode.INVALID_DECODE_VALUE,\n        `Invalid caseIndex \"${caseIndex}\". Valid cases: ${Object.keys(this.coders)}.`\n      );\n    }\n    const valueCoder = this.coders[caseKey];\n    const offsetAndCase = offset + this.#caseIndexCoder.encodedLength;\n\n    if (this.#shouldValidateLength && data.length < offsetAndCase + valueCoder.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid enum data size.`);\n    }\n\n    const [decoded, newOffset] = valueCoder.decode(data, offsetAndCase);\n\n    if (isFullyNativeEnum(this.coders)) {\n      return this.#decodeNativeEnum(caseKey, newOffset);\n    }\n\n    return [{ [caseKey]: decoded } as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber, toBytes } from '@fuel-ts/math';\n\nimport type { EncodingOptions } from '../../types/EncodingOptions';\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\n\ntype NumberCoderType = 'u8' | 'u16' | 'u32' | 'u64';\n\nconst getLength = (baseType: NumberCoderType): number => {\n  switch (baseType) {\n    case 'u8':\n      return 1;\n    case 'u16':\n      return 2;\n    case 'u32':\n      return 4;\n    default:\n      throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Invalid number type: ${baseType}`);\n  }\n};\n\nexport class NumberCoder extends Coder<number, number> {\n  baseType: NumberCoderType;\n  options: EncodingOptions;\n\n  constructor(\n    baseType: NumberCoderType,\n    options: EncodingOptions = {\n      padToWordSize: false,\n    }\n  ) {\n    const length = options.padToWordSize ? WORD_SIZE : getLength(baseType);\n    super('number', baseType, length);\n    this.baseType = baseType;\n    this.options = options;\n  }\n\n  encode(value: number | string): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);\n    }\n\n    if (bytes.length > this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);\n    }\n\n    return toBytes(bytes, this.encodedLength);\n  }\n\n  decode(data: Uint8Array, offset: number): [number, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number data size.`);\n    }\n\n    const bytes = data.slice(offset, offset + this.encodedLength);\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number byte data size.`);\n    }\n\n    return [toNumber(bytes), offset + this.encodedLength];\n  }\n}\n","import type { Coder } from './AbstractCoder';\nimport type { InputValueOf, DecodedValueOf } from './EnumCoder';\nimport { EnumCoder } from './EnumCoder';\n\ntype SwayOption<T> = { None: [] } | { Some: T };\nexport type Option<T> = T | undefined;\n\nexport class OptionCoder<TCoders extends Record<string, Coder>> extends EnumCoder<TCoders> {\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    const result = super.encode(this.toSwayOption(value) as unknown as InputValueOf<TCoders>);\n    return result;\n  }\n\n  private toSwayOption(input: InputValueOf<TCoders>): SwayOption<unknown> {\n    if (input !== undefined) {\n      return { Some: input };\n    }\n\n    return { None: [] };\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    const [decoded, newOffset] = super.decode(data, offset);\n    return [this.toOption(decoded) as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  private toOption(output?: DecodedValueOf<TCoders>): Option<unknown> {\n    if (output && 'Some' in output) {\n      return output.Some;\n    }\n\n    return undefined;\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\nimport { ArrayCoder } from './ArrayCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\nimport { NumberCoder } from './NumberCoder';\n\nexport class RawSliceCoder extends Coder<number[], number[]> {\n  constructor() {\n    super('raw untyped slice', 'raw untyped slice', WORD_SIZE);\n  }\n\n  encode(value: number[]): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const internalCoder = new ArrayCoder(new NumberCoder('u8'), value.length);\n    const bytes = internalCoder.encode(value);\n    const lengthBytes = new BigNumberCoder('u64').encode(bytes.length);\n\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n\n  decode(data: Uint8Array, offset: number): [number[], number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid raw slice data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (dataBytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid raw slice byte data size.`);\n    }\n\n    const internalCoder = new ArrayCoder(new NumberCoder('u8'), length);\n    const [decodedValue] = internalCoder.decode(dataBytes, 0);\n\n    return [decodedValue, offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { toUtf8Bytes, toUtf8String } from '@fuel-ts/utils';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\n\nexport class StdStringCoder extends Coder<string, string> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct String', WORD_SIZE);\n  }\n\n  encode(value: string): Uint8Array {\n    const bytes = toUtf8Bytes(value);\n    const lengthBytes = new BigNumberCoder('u64').encode(value.length);\n\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (dataBytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string byte data size.`);\n    }\n\n    return [toUtf8String(dataBytes), offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { toUtf8Bytes, toUtf8String } from '@fuel-ts/utils';\n\nimport { WORD_SIZE } from '../../utils/constants';\n\nimport { Coder } from './AbstractCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\n\nexport class StrSliceCoder extends Coder<string, string> {\n  static memorySize = 1;\n  constructor() {\n    super('strSlice', 'str', WORD_SIZE);\n  }\n\n  encode(value: string): Uint8Array {\n    const bytes = toUtf8Bytes(value);\n    const lengthBytes = new BigNumberCoder('u64').encode(value.length);\n\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string slice data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n    const bytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (bytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string slice byte data size.`);\n    }\n\n    return [toUtf8String(bytes), offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toUtf8Bytes, toUtf8String } from '@fuel-ts/utils';\n\nimport { Coder } from './AbstractCoder';\n\nexport class StringCoder<TLength extends number = number> extends Coder<string, string> {\n  constructor(length: TLength) {\n    super('string', `str[${length}]`, length);\n  }\n\n  encode(value: string): Uint8Array {\n    if (value.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);\n    }\n\n    return toUtf8Bytes(value);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string data size.`);\n    }\n\n    const bytes = data.slice(offset, offset + this.encodedLength);\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string byte data size.`);\n    }\n\n    return [toUtf8String(bytes), offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { concatBytes } from '@fuel-ts/utils';\n\nimport { hasNestedOption } from '../../utils/utilities';\n\nimport type { TypesOfCoder } from './AbstractCoder';\nimport { Coder } from './AbstractCoder';\nimport { OptionCoder } from './OptionCoder';\n\ntype InputValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class StructCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n  #hasNestedOption: boolean;\n\n  constructor(name: string, coders: TCoders) {\n    const encodedLength = Object.values(coders).reduce(\n      (acc, coder) => acc + coder.encodedLength,\n      0\n    );\n    super('struct', `struct ${name}`, encodedLength);\n    this.name = name;\n    this.coders = coders;\n    this.#hasNestedOption = hasNestedOption(coders);\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    return concatBytes(\n      Object.keys(this.coders).map((fieldName) => {\n        const fieldCoder = this.coders[fieldName];\n        const fieldValue = value[fieldName];\n\n        if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {\n          throw new FuelError(\n            ErrorCode.ENCODE_ERROR,\n            `Invalid ${this.type}. Field \"${fieldName}\" not present.`\n          );\n        }\n\n        return fieldCoder.encode(fieldValue);\n      })\n    );\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (!this.#hasNestedOption && data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid struct data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      let decoded;\n      [decoded, newOffset] = fieldCoder.decode(data, newOffset);\n\n      // eslint-disable-next-line no-param-reassign\n      obj[fieldName as keyof DecodedValueOf<TCoders>] = decoded;\n      return obj;\n    }, {} as DecodedValueOf<TCoders>);\n\n    return [decodedValue, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { concatBytes } from '@fuel-ts/utils';\n\nimport { hasNestedOption } from '../../utils/utilities';\n\nimport type { TypesOfCoder } from './AbstractCoder';\nimport { Coder } from './AbstractCoder';\n\ntype InputValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class TupleCoder<TCoders extends Coder[]> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  coders: TCoders;\n  #hasNestedOption: boolean;\n\n  constructor(coders: TCoders) {\n    const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);\n    super('tuple', `(${coders.map((coder) => coder.type).join(', ')})`, encodedLength);\n    this.coders = coders;\n    this.#hasNestedOption = hasNestedOption(coders);\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (this.coders.length !== value.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n\n    return concatBytes(this.coders.map((coder, i) => coder.encode(value[i])));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (!this.#hasNestedOption && data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid tuple data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = this.coders.map((coder) => {\n      let decoded;\n      [decoded, newOffset] = coder.decode(data, newOffset);\n\n      return decoded;\n    });\n\n    return [decodedValue as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { concatBytes } from '@fuel-ts/utils';\n\nimport { MAX_BYTES, WORD_SIZE } from '../../utils/constants';\nimport { hasNestedOption, isUint8Array } from '../../utils/utilities';\n\nimport { Coder } from './AbstractCoder';\nimport type { TypesOfCoder } from './AbstractCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']> | Uint8Array;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport class VecCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n  #hasNestedOption: boolean;\n\n  constructor(coder: TCoder) {\n    super('struct', `struct Vec`, coder.encodedLength + WORD_SIZE);\n    this.coder = coder;\n    this.#hasNestedOption = hasNestedOption([coder]);\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value) && !isUint8Array(value)) {\n      throw new FuelError(\n        ErrorCode.ENCODE_ERROR,\n        `Expected array value, or a Uint8Array. You can use arrayify to convert a value to a Uint8Array.`\n      );\n    }\n\n    const lengthCoder = new BigNumberCoder('u64');\n\n    if (isUint8Array(value)) {\n      return new Uint8Array([...lengthCoder.encode(value.length), ...value]);\n    }\n\n    const bytes = value.map((v) => this.coder.encode(v));\n    const lengthBytes = lengthCoder.encode(value.length);\n\n    return new Uint8Array([...lengthBytes, ...concatBytes(bytes)]);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    if ((!this.#hasNestedOption && data.length < this.encodedLength) || data.length > MAX_BYTES) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n    const dataLength = length * this.coder.encodedLength;\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + dataLength);\n\n    if (!this.#hasNestedOption && dataBytes.length !== dataLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec byte data size.`);\n    }\n\n    let newOffset = offsetAndLength;\n    const chunks = [];\n    for (let i = 0; i < length; i++) {\n      const [decoded, optionOffset] = this.coder.decode(data, newOffset);\n      chunks.push(decoded);\n      newOffset = optionOffset;\n    }\n\n    return [chunks, newOffset];\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BytesLike } from '@fuel-ts/interfaces';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport { AbiCoder } from './AbiCoder';\nimport { FunctionFragment } from './FunctionFragment';\nimport type { InputValue } from './encoding/coders/AbstractCoder';\nimport type { JsonAbi, JsonAbiConfigurable } from './types/JsonAbi';\nimport { type EncodingVersion } from './utils/constants';\nimport { findTypeById, getEncodingVersion } from './utils/json-abi';\n\nexport class Interface<TAbi extends JsonAbi = JsonAbi> {\n  readonly functions!: Record<string, FunctionFragment>;\n  readonly configurables: Record<string, JsonAbiConfigurable>;\n  readonly jsonAbi: TAbi;\n  readonly encoding: EncodingVersion;\n\n  constructor(jsonAbi: TAbi) {\n    this.jsonAbi = jsonAbi;\n    this.encoding = getEncodingVersion(jsonAbi.encoding);\n\n    this.functions = Object.fromEntries(\n      this.jsonAbi.functions.map((x) => [x.name, new FunctionFragment(this.jsonAbi, x.name)])\n    );\n\n    this.configurables = Object.fromEntries(this.jsonAbi.configurables.map((x) => [x.name, x]));\n  }\n\n  /**\n   * Returns function fragment for a dynamic input.\n   * @param nameOrSignatureOrSelector - name (e.g. 'transfer'), signature (e.g. 'transfer(address,uint256)') or selector (e.g. '0x00000000a9059cbb') of the function fragment\n   */\n  getFunction(nameOrSignatureOrSelector: string): FunctionFragment {\n    const fn = Object.values<FunctionFragment>(this.functions).find(\n      (f) =>\n        f.name === nameOrSignatureOrSelector ||\n        f.signature === nameOrSignatureOrSelector ||\n        f.selector === nameOrSignatureOrSelector\n    );\n\n    if (fn !== undefined) {\n      return fn;\n    }\n\n    throw new FuelError(\n      ErrorCode.FUNCTION_NOT_FOUND,\n      `function ${nameOrSignatureOrSelector} not found: ${JSON.stringify(fn)}.`\n    );\n  }\n\n  decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    return fragment.decodeArguments(data);\n  }\n\n  encodeFunctionData(\n    functionFragment: FunctionFragment | string,\n    values: Array<InputValue>\n  ): Uint8Array {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    return fragment.encodeArguments(values);\n  }\n\n  // Decode the result of a function call\n  decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    return fragment.decodeOutput(data);\n  }\n\n  decodeLog(data: BytesLike, logId: string): any {\n    const loggedType = this.jsonAbi.loggedTypes.find((type) => type.logId === logId);\n    if (!loggedType) {\n      throw new FuelError(\n        ErrorCode.LOG_TYPE_NOT_FOUND,\n        `Log type with logId '${logId}' doesn't exist in the ABI.`\n      );\n    }\n\n    return AbiCoder.decode(this.jsonAbi, loggedType.loggedType, arrayify(data), 0, {\n      encoding: this.encoding,\n    });\n  }\n\n  encodeConfigurable(name: string, value: InputValue) {\n    const configurable = this.jsonAbi.configurables.find((c) => c.name === name);\n    if (!configurable) {\n      throw new FuelError(\n        ErrorCode.CONFIGURABLE_NOT_FOUND,\n        `A configurable with the '${name}' was not found in the ABI.`\n      );\n    }\n\n    return AbiCoder.encode(this.jsonAbi, configurable.configurableType, value, {\n      encoding: this.encoding,\n    });\n  }\n\n  getTypeById(typeId: number) {\n    return findTypeById(this.jsonAbi, typeId);\n  }\n}\n","import { FuelError, ErrorCode } from '@fuel-ts/errors';\n\nimport type { JsonAbi, JsonAbiArgument } from './types/JsonAbi';\nimport { arrayRegEx, enumRegEx, genericRegEx, stringRegEx, structRegEx } from './utils/constants';\nimport { findTypeById } from './utils/json-abi';\n\nexport class ResolvedAbiType {\n  readonly abi: JsonAbi;\n  name: string;\n  readonly type: string;\n  readonly originalTypeArguments: readonly JsonAbiArgument[] | null;\n  readonly components: readonly ResolvedAbiType[] | null;\n\n  constructor(abi: JsonAbi, argument: JsonAbiArgument) {\n    this.abi = abi;\n\n    this.name = argument.name;\n\n    const jsonABIType = findTypeById(abi, argument.type);\n\n    if (jsonABIType.type.length > 256) {\n      throw new FuelError(\n        ErrorCode.INVALID_COMPONENT,\n        `The provided ABI type is too long: ${jsonABIType.type}.`\n      );\n    }\n\n    this.type = jsonABIType.type;\n    this.originalTypeArguments = argument.typeArguments;\n    this.components = ResolvedAbiType.getResolvedGenericComponents(\n      abi,\n      argument,\n      jsonABIType.components,\n      jsonABIType.typeParameters ??\n        ResolvedAbiType.getImplicitGenericTypeParameters(abi, jsonABIType.components)\n    );\n  }\n\n  private static getResolvedGenericComponents(\n    abi: JsonAbi,\n    arg: JsonAbiArgument,\n    components: readonly JsonAbiArgument[] | null,\n    typeParameters: readonly number[] | null\n  ) {\n    if (components === null) {\n      return null;\n    }\n    if (typeParameters === null || typeParameters.length === 0) {\n      return components.map((c) => new ResolvedAbiType(abi, c));\n    }\n\n    const typeParametersAndArgsMap = typeParameters.reduce(\n      (obj, typeParameter, typeParameterIndex) => {\n        const o: Record<number, JsonAbiArgument> = { ...obj };\n        o[typeParameter] = structuredClone(\n          arg.typeArguments?.[typeParameterIndex]\n        ) as JsonAbiArgument;\n        return o;\n      },\n      {} as Record<number, JsonAbiArgument>\n    );\n\n    const resolvedComponents = this.resolveGenericArgTypes(\n      abi,\n      components,\n      typeParametersAndArgsMap\n    );\n\n    return resolvedComponents.map((c) => new ResolvedAbiType(abi, c));\n  }\n\n  private static resolveGenericArgTypes(\n    abi: JsonAbi,\n    args: readonly JsonAbiArgument[],\n    typeParametersAndArgsMap: Record<number, JsonAbiArgument>\n  ): readonly JsonAbiArgument[] {\n    return args.map((arg) => {\n      if (typeParametersAndArgsMap[arg.type] !== undefined) {\n        return {\n          ...typeParametersAndArgsMap[arg.type],\n          name: arg.name,\n        };\n      }\n\n      if (arg.typeArguments) {\n        return {\n          ...structuredClone(arg),\n          typeArguments: this.resolveGenericArgTypes(\n            abi,\n            arg.typeArguments,\n            typeParametersAndArgsMap\n          ),\n        };\n      }\n\n      const argType = findTypeById(abi, arg.type);\n      const implicitTypeParameters = this.getImplicitGenericTypeParameters(abi, argType.components);\n\n      if (implicitTypeParameters && implicitTypeParameters.length > 0) {\n        return {\n          ...structuredClone(arg),\n          typeArguments: implicitTypeParameters.map((itp) => typeParametersAndArgsMap[itp]),\n        };\n      }\n\n      return arg;\n    });\n  }\n\n  private static getImplicitGenericTypeParameters(\n    abi: JsonAbi,\n    args: readonly JsonAbiArgument[] | null,\n    implicitGenericParametersParam?: number[]\n  ) {\n    if (!Array.isArray(args)) {\n      return null;\n    }\n\n    const implicitGenericParameters: number[] = implicitGenericParametersParam ?? [];\n\n    args.forEach((a) => {\n      const argType = findTypeById(abi, a.type);\n\n      if (genericRegEx.test(argType.type)) {\n        implicitGenericParameters.push(argType.typeId);\n        return;\n      }\n\n      if (!Array.isArray(a.typeArguments)) {\n        return;\n      }\n      this.getImplicitGenericTypeParameters(abi, a.typeArguments, implicitGenericParameters);\n    });\n\n    return implicitGenericParameters.length > 0 ? implicitGenericParameters : null;\n  }\n\n  getSignature(): string {\n    const prefix = this.getArgSignaturePrefix();\n    const content = this.getArgSignatureContent();\n\n    return `${prefix}${content}`;\n  }\n\n  private getArgSignaturePrefix(): string {\n    const structMatch = structRegEx.test(this.type);\n    if (structMatch) {\n      return 's';\n    }\n\n    const arrayMatch = arrayRegEx.test(this.type);\n    if (arrayMatch) {\n      return 'a';\n    }\n\n    const enumMatch = enumRegEx.test(this.type);\n    if (enumMatch) {\n      return 'e';\n    }\n\n    return '';\n  }\n\n  private getArgSignatureContent(): string {\n    if (this.type === 'raw untyped ptr') {\n      return 'rawptr';\n    }\n\n    if (this.type === 'raw untyped slice') {\n      return 'rawslice';\n    }\n\n    const strMatch = stringRegEx.exec(this.type)?.groups;\n    if (strMatch) {\n      return `str[${strMatch.length}]`;\n    }\n\n    if (this.components === null) {\n      return this.type;\n    }\n\n    const arrayMatch = arrayRegEx.exec(this.type)?.groups;\n\n    if (arrayMatch) {\n      return `[${this.components[0].getSignature()};${arrayMatch.length}]`;\n    }\n\n    const typeArgumentsSignature =\n      this.originalTypeArguments !== null\n        ? `<${this.originalTypeArguments\n            .map((a) => new ResolvedAbiType(this.abi, a).getSignature())\n            .join(',')}>`\n        : '';\n\n    const componentsSignature = `(${this.components.map((c) => c.getSignature()).join(',')})`;\n\n    return `${typeArgumentsSignature}${componentsSignature}`;\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { ResolvedAbiType } from '../ResolvedAbiType';\nimport type { JsonAbi, JsonAbiArgument, JsonAbiFunction, JsonAbiType } from '../types/JsonAbi';\n\nimport { ENCODING_V1, type EncodingVersion } from './constants';\n\n/**\n * Asserts that the encoding version is supported by the ABI coder.\n *\n * @param encoding - the encoding version to check\n * @returns the encoding version\n * @throws FuelError if the encoding version is not supported\n */\nexport const getEncodingVersion = (encoding?: string): EncodingVersion => {\n  switch (encoding) {\n    case undefined:\n    case ENCODING_V1:\n      return ENCODING_V1;\n\n    default:\n      throw new FuelError(\n        ErrorCode.UNSUPPORTED_ENCODING_VERSION,\n        `Encoding version '${encoding}' is unsupported.`\n      );\n  }\n};\n\n/**\n * Find a function by name in the ABI.\n *\n * @param abi - the JsonAbi object\n * @param name - the name of the function to find\n * @returns the JsonAbi function object\n */\nexport const findFunctionByName = (abi: JsonAbi, name: string): JsonAbiFunction => {\n  const fn = abi.functions.find((f) => f.name === name);\n  if (!fn) {\n    throw new FuelError(\n      ErrorCode.FUNCTION_NOT_FOUND,\n      `Function with name '${name}' doesn't exist in the ABI`\n    );\n  }\n  return fn;\n};\n\n/**\n * Find a type by its typeId in the ABI.\n *\n * @param abi - the JsonAbi object\n * @param typeId - the typeId of the type to find\n * @returns the JsonAbi type object\n */\nexport const findTypeById = (abi: JsonAbi, typeId: number): JsonAbiType => {\n  const type = abi.types.find((t) => t.typeId === typeId);\n  if (!type) {\n    throw new FuelError(\n      ErrorCode.TYPE_NOT_FOUND,\n      `Type with typeId '${typeId}' doesn't exist in the ABI.`\n    );\n  }\n  return type;\n};\n\n/**\n * Find all non-empty inputs in a list of inputs.\n * i.e. all inputs that are not of the type '()'.\n *\n * @param abi - the JsonAbi object\n * @param inputs - the list of inputs to filter\n * @returns the list of non-empty inputs\n */\nexport const findNonEmptyInputs = (\n  abi: JsonAbi,\n  inputs: readonly JsonAbiArgument[]\n): JsonAbiArgument[] => inputs.filter((input) => findTypeById(abi, input.type).type !== '()');\n\n/**\n * Find the vector buffer argument in a list of components.\n *\n * @param components - the list of components to search\n * @returns the vector buffer argument\n */\nexport const findVectorBufferArgument = (\n  components: readonly ResolvedAbiType[]\n): JsonAbiArgument => {\n  const bufferComponent = components.find((c) => c.name === 'buf');\n  const bufferTypeArgument = bufferComponent?.originalTypeArguments?.[0];\n  if (!bufferComponent || !bufferTypeArgument) {\n    throw new FuelError(\n      ErrorCode.INVALID_COMPONENT,\n      `The Vec type provided is missing or has a malformed 'buf' component.`\n    );\n  }\n  return bufferTypeArgument;\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { GetCoderFn } from '../../types/GetCoder';\nimport type { EncodingVersion } from '../../utils/constants';\nimport { ENCODING_V1 } from '../../utils/constants';\n\nimport { getCoder as getCoderV1 } from './getCoderV1';\n\n/**\n * Retrieves the appropriate encoding function for a given encoding version.\n *\n * @param encoding - the version to provide a strategy for.\n * @throws for an unsupported encoding version.\n * @returns the appropriate encoding strategy.\n */\nexport function getCoderForEncoding(encoding: EncodingVersion = ENCODING_V1): GetCoderFn {\n  switch (encoding) {\n    case ENCODING_V1:\n      return getCoderV1;\n    default:\n      throw new FuelError(\n        ErrorCode.UNSUPPORTED_ENCODING_VERSION,\n        `Encoding version ${encoding} is unsupported.`\n      );\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport { ResolvedAbiType } from '../../ResolvedAbiType';\nimport type { EncodingOptions } from '../../types/EncodingOptions';\nimport type { GetCoderFn } from '../../types/GetCoder';\nimport {\n  B256_CODER_TYPE,\n  B512_CODER_TYPE,\n  BOOL_CODER_TYPE,\n  BYTES_CODER_TYPE,\n  ENCODING_V1,\n  OPTION_CODER_TYPE,\n  RAW_PTR_CODER_TYPE,\n  RAW_SLICE_CODER_TYPE,\n  STD_STRING_CODER_TYPE,\n  STR_SLICE_CODER_TYPE,\n  U16_CODER_TYPE,\n  U256_CODER_TYPE,\n  U32_CODER_TYPE,\n  U64_CODER_TYPE,\n  U8_CODER_TYPE,\n  VEC_CODER_TYPE,\n  arrayRegEx,\n  enumRegEx,\n  stringRegEx,\n  structRegEx,\n  tupleRegEx,\n} from '../../utils/constants';\nimport { findVectorBufferArgument } from '../../utils/json-abi';\nimport type { Coder } from '../coders/AbstractCoder';\nimport { ArrayCoder } from '../coders/ArrayCoder';\nimport { B256Coder } from '../coders/B256Coder';\nimport { B512Coder } from '../coders/B512Coder';\nimport { BigNumberCoder } from '../coders/BigNumberCoder';\nimport { BooleanCoder } from '../coders/BooleanCoder';\nimport { ByteCoder } from '../coders/ByteCoder';\nimport { EnumCoder } from '../coders/EnumCoder';\nimport { NumberCoder } from '../coders/NumberCoder';\nimport { OptionCoder } from '../coders/OptionCoder';\nimport { RawSliceCoder } from '../coders/RawSliceCoder';\nimport { StdStringCoder } from '../coders/StdStringCoder';\nimport { StrSliceCoder } from '../coders/StrSliceCoder';\nimport { StringCoder } from '../coders/StringCoder';\nimport { StructCoder } from '../coders/StructCoder';\nimport { TupleCoder } from '../coders/TupleCoder';\nimport { VecCoder } from '../coders/VecCoder';\n\nimport { getCoders } from './getCoders';\n\n/**\n * Retrieves coders that adhere to the v0 spec.\n *\n * @param resolvedAbiType - the resolved type to return a coder for.\n * @param options - options to be utilized during the encoding process.\n * @returns the coder for a given type.\n */\nexport const getCoder: GetCoderFn = (\n  resolvedAbiType: ResolvedAbiType,\n  _options?: EncodingOptions\n): Coder => {\n  switch (resolvedAbiType.type) {\n    case U8_CODER_TYPE:\n    case U16_CODER_TYPE:\n    case U32_CODER_TYPE:\n      return new NumberCoder(resolvedAbiType.type);\n    case U64_CODER_TYPE:\n    case RAW_PTR_CODER_TYPE:\n      return new BigNumberCoder('u64');\n    case U256_CODER_TYPE:\n      return new BigNumberCoder('u256');\n    case RAW_SLICE_CODER_TYPE:\n      return new RawSliceCoder();\n    case BOOL_CODER_TYPE:\n      return new BooleanCoder();\n    case B256_CODER_TYPE:\n      return new B256Coder();\n    case B512_CODER_TYPE:\n      return new B512Coder();\n    case BYTES_CODER_TYPE:\n      return new ByteCoder();\n    case STD_STRING_CODER_TYPE:\n      return new StdStringCoder();\n    case STR_SLICE_CODER_TYPE:\n      return new StrSliceCoder();\n    default:\n      break;\n  }\n\n  const stringMatch = stringRegEx.exec(resolvedAbiType.type)?.groups;\n  if (stringMatch) {\n    const length = parseInt(stringMatch.length, 10);\n\n    return new StringCoder(length);\n  }\n\n  // ABI types underneath MUST have components by definition\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const components = resolvedAbiType.components!;\n\n  const arrayMatch = arrayRegEx.exec(resolvedAbiType.type)?.groups;\n\n  if (arrayMatch) {\n    const length = parseInt(arrayMatch.length, 10);\n    const arg = components[0];\n    if (!arg) {\n      throw new FuelError(\n        ErrorCode.INVALID_COMPONENT,\n        `The provided Array type is missing an item of 'component'.`\n      );\n    }\n\n    const arrayElementCoder = getCoder(arg);\n    return new ArrayCoder(arrayElementCoder as Coder, length);\n  }\n\n  if (resolvedAbiType.type === VEC_CODER_TYPE) {\n    const arg = findVectorBufferArgument(components);\n    const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);\n\n    const itemCoder = getCoder(argType, { encoding: ENCODING_V1 });\n    return new VecCoder(itemCoder as Coder);\n  }\n\n  const structMatch = structRegEx.exec(resolvedAbiType.type)?.groups;\n  if (structMatch) {\n    const coders = getCoders(components, { getCoder });\n    return new StructCoder(structMatch.name, coders);\n  }\n\n  const enumMatch = enumRegEx.exec(resolvedAbiType.type)?.groups;\n  if (enumMatch) {\n    const coders = getCoders(components, { getCoder });\n\n    const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;\n    if (isOptionEnum) {\n      return new OptionCoder(enumMatch.name, coders);\n    }\n    return new EnumCoder(enumMatch.name, coders);\n  }\n\n  const tupleMatch = tupleRegEx.exec(resolvedAbiType.type)?.groups;\n  if (tupleMatch) {\n    const coders = components.map((component) => getCoder(component, { encoding: ENCODING_V1 }));\n    return new TupleCoder(coders as Coder[]);\n  }\n\n  throw new FuelError(\n    ErrorCode.CODER_NOT_FOUND,\n    `Coder not found: ${JSON.stringify(resolvedAbiType)}.`\n  );\n};\n","import type { ResolvedAbiType } from '../../ResolvedAbiType';\nimport type { EncodingOptions } from '../../types/EncodingOptions';\nimport type { GetCoderFn } from '../../types/GetCoder';\nimport type { Coder } from '../coders/AbstractCoder';\n\n/**\n * @param components - types array to create coders for.\n * @param options - options - options to be utilized during the encoding process.\n * @returns an object containing types and an appropriate coder.\n */\nexport function getCoders(\n  components: readonly ResolvedAbiType[],\n  options: EncodingOptions & { getCoder: GetCoderFn }\n) {\n  const { getCoder } = options;\n  return components.reduce((obj, component) => {\n    const o: Record<string, Coder> = obj;\n\n    o[component.name] = getCoder(component, options);\n    return o;\n  }, {});\n}\n","import { ResolvedAbiType } from './ResolvedAbiType';\nimport type { DecodedValue, InputValue, Coder } from './encoding/coders/AbstractCoder';\nimport { getCoderForEncoding } from './encoding/strategies/getCoderForEncoding';\nimport type { EncodingOptions } from './types/EncodingOptions';\nimport type { JsonAbi, JsonAbiArgument } from './types/JsonAbi';\n\nexport abstract class AbiCoder {\n  static getCoder(\n    abi: JsonAbi,\n    argument: JsonAbiArgument,\n    options: EncodingOptions = {\n      padToWordSize: false,\n    }\n  ): Coder {\n    const resolvedAbiType = new ResolvedAbiType(abi, argument);\n    return getCoderForEncoding(options.encoding)(resolvedAbiType, options);\n  }\n\n  static encode(\n    abi: JsonAbi,\n    argument: JsonAbiArgument,\n    value: InputValue,\n    options?: EncodingOptions\n  ) {\n    return this.getCoder(abi, argument, options).encode(value);\n  }\n\n  static decode(\n    abi: JsonAbi,\n    argument: JsonAbiArgument,\n    data: Uint8Array,\n    offset: number,\n    options?: EncodingOptions\n  ): [DecodedValue | undefined, number] {\n    return this.getCoder(abi, argument, options).decode(data, offset) as [\n      DecodedValue | undefined,\n      number,\n    ];\n  }\n}\n","import { bufferFromString } from '@fuel-ts/crypto';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { sha256 } from '@fuel-ts/hasher';\nimport type { BytesLike } from '@fuel-ts/interfaces';\nimport { bn } from '@fuel-ts/math';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport { AbiCoder } from './AbiCoder';\nimport { ResolvedAbiType } from './ResolvedAbiType';\nimport type { DecodedValue, InputValue } from './encoding/coders/AbstractCoder';\nimport { StdStringCoder } from './encoding/coders/StdStringCoder';\nimport { TupleCoder } from './encoding/coders/TupleCoder';\nimport type {\n  JsonAbi,\n  JsonAbiArgument,\n  JsonAbiFunction,\n  JsonAbiFunctionAttribute,\n} from './types/JsonAbi';\nimport type { EncodingVersion } from './utils/constants';\nimport { OPTION_CODER_TYPE } from './utils/constants';\nimport {\n  findFunctionByName,\n  findNonEmptyInputs,\n  findTypeById,\n  getEncodingVersion,\n} from './utils/json-abi';\n\nexport class FunctionFragment<\n  TAbi extends JsonAbi = JsonAbi,\n  FnName extends TAbi['functions'][number]['name'] = string,\n> {\n  readonly signature: string;\n  readonly selector: string;\n  readonly selectorBytes: Uint8Array;\n  readonly encoding: EncodingVersion;\n  readonly name: string;\n  readonly jsonFn: JsonAbiFunction;\n  readonly attributes: readonly JsonAbiFunctionAttribute[];\n\n  private readonly jsonAbi: JsonAbi;\n\n  constructor(jsonAbi: JsonAbi, name: FnName) {\n    this.jsonAbi = jsonAbi;\n    this.jsonFn = findFunctionByName(this.jsonAbi, name);\n\n    this.name = name;\n    this.signature = FunctionFragment.getSignature(this.jsonAbi, this.jsonFn);\n    this.selector = FunctionFragment.getFunctionSelector(this.signature);\n    this.selectorBytes = new StdStringCoder().encode(name);\n    this.encoding = getEncodingVersion(jsonAbi.encoding);\n\n    this.attributes = this.jsonFn.attributes ?? [];\n  }\n\n  private static getSignature(abi: JsonAbi, fn: JsonAbiFunction): string {\n    const inputsSignatures = fn.inputs.map((input) =>\n      new ResolvedAbiType(abi, input).getSignature()\n    );\n    return `${fn.name}(${inputsSignatures.join(',')})`;\n  }\n\n  private static getFunctionSelector(functionSignature: string) {\n    const hashedFunctionSignature = sha256(bufferFromString(functionSignature, 'utf-8'));\n    // get first 4 bytes of signature + 0x prefix. then left-pad it to 8 bytes using toHex(8)\n    return bn(hashedFunctionSignature.slice(0, 10)).toHex(8);\n  }\n\n  encodeArguments(values: InputValue[]): Uint8Array {\n    FunctionFragment.verifyArgsAndInputsAlign(values, this.jsonFn.inputs, this.jsonAbi);\n\n    const shallowCopyValues = values.slice();\n    const nonEmptyInputs = findNonEmptyInputs(this.jsonAbi, this.jsonFn.inputs);\n\n    if (Array.isArray(values) && nonEmptyInputs.length !== values.length) {\n      shallowCopyValues.length = this.jsonFn.inputs.length;\n      shallowCopyValues.fill(undefined as unknown as InputValue, values.length);\n    }\n\n    const coders = nonEmptyInputs.map((t) =>\n      AbiCoder.getCoder(this.jsonAbi, t, {\n        encoding: this.encoding,\n      })\n    );\n\n    return new TupleCoder(coders).encode(shallowCopyValues);\n  }\n\n  private static verifyArgsAndInputsAlign(\n    args: InputValue[],\n    inputs: readonly JsonAbiArgument[],\n    abi: JsonAbi\n  ) {\n    if (args.length === inputs.length) {\n      return;\n    }\n\n    const inputTypes = inputs.map((input) => findTypeById(abi, input.type));\n    const optionalInputs = inputTypes.filter(\n      (x) => x.type === OPTION_CODER_TYPE || x.type === '()'\n    );\n    if (optionalInputs.length === inputTypes.length) {\n      return;\n    }\n    if (inputTypes.length - optionalInputs.length === args.length) {\n      return;\n    }\n\n    const errorMsg = `Mismatch between provided arguments and expected ABI inputs. Provided ${\n      args.length\n    } arguments, but expected ${inputs.length - optionalInputs.length} (excluding ${\n      optionalInputs.length\n    } optional inputs).`;\n\n    throw new FuelError(ErrorCode.ABI_TYPES_AND_VALUES_MISMATCH, errorMsg);\n  }\n\n  decodeArguments(data: BytesLike) {\n    const bytes = arrayify(data);\n    const nonEmptyInputs = findNonEmptyInputs(this.jsonAbi, this.jsonFn.inputs);\n\n    if (nonEmptyInputs.length === 0) {\n      // The VM is current return 0x0000000000000000, but we should treat it as undefined / void\n      if (bytes.length === 0) {\n        return undefined;\n      }\n\n      throw new FuelError(\n        ErrorCode.DECODE_ERROR,\n        `Types/values length mismatch during decode. ${JSON.stringify({\n          count: {\n            types: this.jsonFn.inputs.length,\n            nonEmptyInputs: nonEmptyInputs.length,\n            values: bytes.length,\n          },\n          value: {\n            args: this.jsonFn.inputs,\n            nonEmptyInputs,\n            values: bytes,\n          },\n        })}`\n      );\n    }\n\n    const result = nonEmptyInputs.reduce(\n      (obj: { decoded: unknown[]; offset: number }, input) => {\n        const coder = AbiCoder.getCoder(this.jsonAbi, input, { encoding: this.encoding });\n        const [decodedValue, decodedValueByteSize] = coder.decode(bytes, obj.offset);\n\n        return {\n          decoded: [...obj.decoded, decodedValue],\n          offset: obj.offset + decodedValueByteSize,\n        };\n      },\n      { decoded: [], offset: 0 }\n    );\n\n    return result.decoded;\n  }\n\n  decodeOutput(data: BytesLike): [DecodedValue | undefined, number] {\n    const outputAbiType = findTypeById(this.jsonAbi, this.jsonFn.output.type);\n    if (outputAbiType.type === '()') {\n      return [undefined, 0];\n    }\n\n    const bytes = arrayify(data);\n    const coder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output, {\n      encoding: this.encoding,\n    });\n\n    return coder.decode(bytes, 0) as [DecodedValue | undefined, number];\n  }\n\n  /**\n   * Checks if the function is read-only i.e. it only reads from storage, does not write to it.\n   *\n   * @returns True if the function is read-only or pure, false otherwise.\n   */\n  isReadOnly(): boolean {\n    const storageAttribute = this.attributes.find((attr) => attr.name === 'storage');\n    return !storageAttribute?.arguments.includes('write');\n  }\n}\n"],"mappings":"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","names":["ErrorCode","FuelError","FuelError","ErrorCode","ErrorCode","FuelError","bn","toHex","arrayify","arrayify","FuelError","ErrorCode","bn","toHex","ErrorCode","FuelError","bn","FuelError","ErrorCode","bn","ErrorCode","FuelError","bn","toBytes","FuelError","ErrorCode","toBytes","bn","ErrorCode","FuelError","bn","FuelError","ErrorCode","bn","ErrorCode","FuelError","concat","concat","FuelError","ErrorCode","ErrorCode","FuelError","toNumber","toBytes","FuelError","ErrorCode","toBytes","toNumber","ErrorCode","FuelError","bn","FuelError","ErrorCode","bn","ErrorCode","FuelError","bn","FuelError","ErrorCode","bn","ErrorCode","FuelError","bn","toUtf8Bytes","toUtf8String","toUtf8Bytes","FuelError","ErrorCode","bn","toUtf8String","ErrorCode","FuelError","toUtf8Bytes","toUtf8String","FuelError","ErrorCode","toUtf8Bytes","toUtf8String","ErrorCode","FuelError","FuelError","ErrorCode","ErrorCode","FuelError","concatBytes","FuelError","ErrorCode","concatBytes","ErrorCode","FuelError","bn","concatBytes","FuelError","ErrorCode","concatBytes","bn","ErrorCode","FuelError","arrayify","FuelError","ErrorCode","ErrorCode","FuelError","FuelError","ErrorCode","FuelError","ErrorCode","ErrorCode","FuelError","ErrorCode","FuelError","getCoder","FuelError","ErrorCode","FuelError","ErrorCode","ErrorCode","FuelError","bn","arrayify","bn","FuelError","ErrorCode","arrayify","FuelError","ErrorCode","arrayify"]}