var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/contract-factory.ts
import { Interface } from "@fuel-ts/abi-coder";
import { CreateTransactionRequest } from "@fuel-ts/account";
import { randomBytes } from "@fuel-ts/crypto";
import { ErrorCode, FuelError } from "@fuel-ts/errors";
import { Contract } from "@fuel-ts/program";
import { arrayify as arrayify2, isDefined } from "@fuel-ts/utils";

// src/util.ts
var util_exports = {};
__export(util_exports, {
  getContractId: () => getContractId,
  getContractRoot: () => getContractRoot,
  getContractStorageRoot: () => getContractStorageRoot,
  hexlifyWithPrefix: () => hexlifyWithPrefix
});
import { sha256 } from "@fuel-ts/hasher";
import { calcRoot, SparseMerkleTree } from "@fuel-ts/merkle";
import { chunkAndPadBytes, hexlify, concat, arrayify } from "@fuel-ts/utils";
var getContractRoot = (bytecode) => {
  const chunkSize = 16 * 1024;
  const bytes = arrayify(bytecode);
  const chunks = chunkAndPadBytes(bytes, chunkSize);
  return calcRoot(chunks.map((c) => hexlify(c)));
};
var getContractStorageRoot = (storageSlots) => {
  const tree = new SparseMerkleTree();
  storageSlots.forEach(({ key, value }) => tree.update(sha256(key), value));
  return tree.root;
};
var getContractId = (bytecode, salt, stateRoot) => {
  const root = getContractRoot(arrayify(bytecode));
  const contractId = sha256(concat(["0x4655454C", salt, root, stateRoot]));
  return contractId;
};
var hexlifyWithPrefix = (value) => hexlify(value.startsWith("0x") ? value : `0x${value}`);

// src/contract-factory.ts
var ContractFactory = class {
  bytecode;
  interface;
  provider;
  account;
  /**
   * Create a ContractFactory instance.
   *
   * @param bytecode - The bytecode of the contract.
   * @param abi - The contract's ABI (Application Binary Interface).
   * @param accountOrProvider - An account or provider to be associated with the factory.
   */
  constructor(bytecode, abi, accountOrProvider = null) {
    this.bytecode = arrayify2(bytecode);
    if (abi instanceof Interface) {
      this.interface = abi;
    } else {
      this.interface = new Interface(abi);
    }
    if (accountOrProvider && "provider" in accountOrProvider) {
      this.provider = accountOrProvider.provider;
      this.account = accountOrProvider;
    } else {
      this.provider = accountOrProvider;
      this.account = null;
    }
  }
  /**
   * Connect the factory to a provider.
   *
   * @param provider - The provider to be associated with the factory.
   * @returns A new ContractFactory instance.
   */
  connect(provider) {
    return new ContractFactory(this.bytecode, this.interface, provider);
  }
  /**
   * Create a transaction request to deploy a contract with the specified options.
   *
   * @param deployContractOptions - Options for deploying the contract.
   * @returns The CreateTransactionRequest object for deploying the contract.
   */
  createTransactionRequest(deployContractOptions) {
    const storageSlots = deployContractOptions?.storageSlots?.map(({ key, value }) => ({
      key: hexlifyWithPrefix(key),
      value: hexlifyWithPrefix(value)
    })).sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));
    const options = {
      salt: randomBytes(32),
      ...deployContractOptions,
      storageSlots: storageSlots || []
    };
    if (!this.provider) {
      throw new FuelError(
        ErrorCode.MISSING_PROVIDER,
        "Cannot create transaction request without provider"
      );
    }
    const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);
    const contractId = getContractId(this.bytecode, options.salt, stateRoot);
    const transactionRequest = new CreateTransactionRequest({
      bytecodeWitnessIndex: 0,
      witnesses: [this.bytecode],
      ...options
    });
    transactionRequest.addContractCreatedOutput(contractId, stateRoot);
    return {
      contractId,
      transactionRequest
    };
  }
  /**
   * Deploy a contract with the specified options.
   *
   * @param deployContractOptions - Options for deploying the contract.
   * @returns A promise that resolves to the deployed contract instance.
   */
  async deployContract(deployContractOptions = {}) {
    if (!this.account) {
      throw new FuelError(ErrorCode.ACCOUNT_REQUIRED, "Cannot deploy Contract without account.");
    }
    const { configurableConstants } = deployContractOptions;
    if (configurableConstants) {
      this.setConfigurableConstants(configurableConstants);
    }
    const { contractId, transactionRequest } = this.createTransactionRequest(deployContractOptions);
    const txCost = await this.account.provider.getTransactionCost(transactionRequest);
    const { maxFee: setMaxFee } = deployContractOptions;
    if (isDefined(setMaxFee) && txCost.maxFee.gt(setMaxFee)) {
      throw new FuelError(
        ErrorCode.MAX_FEE_TOO_LOW,
        `Max fee '${deployContractOptions.maxFee}' is lower than the required: '${txCost.maxFee}'.`
      );
    }
    transactionRequest.maxFee = txCost.maxFee;
    await this.account.fund(transactionRequest, txCost);
    await this.account.sendTransaction(transactionRequest, {
      awaitExecution: true
    });
    return new Contract(contractId, this.interface, this.account);
  }
  /**
   * Set configurable constants of the contract with the specified values.
   *
   * @param configurableConstants - An object containing configurable names and their values.
   */
  setConfigurableConstants(configurableConstants) {
    try {
      const hasConfigurable = Object.keys(this.interface.configurables).length;
      if (!hasConfigurable) {
        throw new Error("Contract does not have configurables to be set");
      }
      Object.entries(configurableConstants).forEach(([key, value]) => {
        if (!this.interface.configurables[key]) {
          throw new Error(`Contract does not have a configurable named: '${key}'`);
        }
        const { offset } = this.interface.configurables[key];
        const encoded = this.interface.encodeConfigurable(key, value);
        const bytes = arrayify2(this.bytecode);
        bytes.set(encoded, offset);
        this.bytecode = bytes;
      });
    } catch (err) {
      throw new FuelError(
        ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,
        `Error setting configurable constants on contract: ${err.message}.`
      );
    }
  }
};
export {
  ContractFactory,
  util_exports as ContractUtils
};
//# sourceMappingURL=index.mjs.map