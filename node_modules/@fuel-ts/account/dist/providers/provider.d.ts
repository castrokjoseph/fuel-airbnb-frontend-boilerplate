/// <reference types="web" />
import type { AbstractAccount, AbstractAddress, BytesLike } from '@fuel-ts/interfaces';
import { BN } from '@fuel-ts/math';
import type { Transaction } from '@fuel-ts/transactions';
import { getSdk as getOperationsSdk } from './__generated__/operations';
import type { GqlConsensusParametersVersion, GqlContractParameters as ContractParameters, GqlDryRunFailureStatusFragment, GqlDryRunSuccessStatusFragment, GqlFeeParameters as FeeParameters, GqlGasCosts as GasCosts, GqlGetBlocksQueryVariables, GqlMessage, GqlPredicateParameters as PredicateParameters, GqlRelayedTransactionFailed, GqlScriptParameters as ScriptParameters, GqlTxParameters as TxParameters } from './__generated__/operations';
import type { Coin } from './coin';
import type { CoinQuantity, CoinQuantityLike } from './coin-quantity';
import { MemoryCache } from './memory-cache';
import type { Message, MessageProof, MessageStatus } from './message';
import type { ExcludeResourcesOption, Resource } from './resource';
import type { TransactionRequestLike, TransactionRequest, TransactionRequestInput, ScriptTransactionRequest } from './transaction-request';
import type { TransactionResultReceipt } from './transaction-response';
import { TransactionResponse } from './transaction-response';
import type { RetryOptions } from './utils/auto-retry-fetch';
export type DryRunFailureStatusFragment = GqlDryRunFailureStatusFragment;
export type DryRunSuccessStatusFragment = GqlDryRunSuccessStatusFragment;
export type DryRunStatus = DryRunFailureStatusFragment | DryRunSuccessStatusFragment;
export type CallResult = {
    receipts: TransactionResultReceipt[];
    dryRunStatus?: DryRunStatus;
};
export type EstimateTxDependenciesReturns = CallResult & {
    outputVariables: number;
    missingContractIds: string[];
};
/**
 * A Fuel block
 */
export type Block = {
    id: string;
    height: BN;
    time: string;
    transactionIds: string[];
};
/**
 * Deployed Contract bytecode and contract id
 */
export type ContractResult = {
    id: string;
    bytecode: string;
};
type ModifyStringToBN<T> = {
    [P in keyof T]: P extends 'version' ? T[P] : T[P] extends string ? BN : T[P];
};
export { GasCosts, FeeParameters, ContractParameters, PredicateParameters, ScriptParameters, TxParameters, };
export type ConsensusParameters = {
    version: GqlConsensusParametersVersion;
    chainId: BN;
    baseAssetId: string;
    feeParameters: ModifyStringToBN<FeeParameters>;
    contractParameters: ModifyStringToBN<ContractParameters>;
    predicateParameters: ModifyStringToBN<PredicateParameters>;
    scriptParameters: ModifyStringToBN<ScriptParameters>;
    txParameters: ModifyStringToBN<TxParameters>;
    gasCosts: GasCosts;
};
/**
 * Chain information
 */
export type ChainInfo = {
    name: string;
    baseChainHeight: BN;
    consensusParameters: ConsensusParameters;
    latestBlock: {
        id: string;
        height: BN;
        time: string;
        transactions: Array<{
            id: string;
        }>;
    };
};
/**
 * Node information
 */
export type NodeInfo = {
    utxoValidation: boolean;
    vmBacktrace: boolean;
    maxTx: BN;
    maxDepth: BN;
    nodeVersion: string;
};
export type NodeInfoAndConsensusParameters = {
    nodeVersion: string;
    gasPerByte: BN;
    gasPriceFactor: BN;
    maxGasPerTx: BN;
};
export type TransactionCost = {
    gasPrice: BN;
    gasUsed: BN;
    minGas: BN;
    minFee: BN;
    maxFee: BN;
    maxGas: BN;
    receipts: TransactionResultReceipt[];
    outputVariables: number;
    missingContractIds: string[];
    estimatedPredicates: TransactionRequestInput[];
    requiredQuantities: CoinQuantity[];
    addedSignatures: number;
    dryRunStatus?: DryRunStatus;
    updateMaxFee?: boolean;
};
/**
 * @hidden
 *
 * Cursor pagination arguments
 *
 * https://relay.dev/graphql/connections.htm#sec-Arguments
 */
export type CursorPaginationArgs = {
    /** Forward pagination limit */
    first?: number | null;
    /** Forward pagination cursor */
    after?: string | null;
    /** Backward pagination limit  */
    last?: number | null;
    /** Backward pagination cursor */
    before?: string | null;
};
export type ProviderOptions = {
    /**
     * Custom fetch function to use for making requests.
     */
    fetch?: (url: string, requestInit?: RequestInit, providerOptions?: Omit<ProviderOptions, 'fetch'>) => Promise<Response>;
    /**
     * Timeout [ms] after which every request will be aborted.
     */
    timeout?: number;
    /**
     * Cache UTXOs for the given time [ms].
     */
    cacheUtxo?: number;
    /**
     * Retry options to use when fetching data from the node.
     */
    retryOptions?: RetryOptions;
    /**
     * Middleware to modify the request before it is sent.
     * This can be used to add headers, modify the body, etc.
     */
    requestMiddleware?: (request: RequestInit) => RequestInit | Promise<RequestInit>;
};
/**
 * UTXO validation params
 */
export type UTXOValidationParams = {
    utxoValidation?: boolean;
};
/**
 * Transaction estimation params
 */
export type EstimateTransactionParams = {
    /**
     * Estimate the transaction dependencies.
     */
    estimateTxDependencies?: boolean;
};
export type TransactionCostParams = EstimateTransactionParams & {
    /**
     * The account that will provide the resources for the transaction.
     */
    resourcesOwner?: AbstractAccount;
    /**
     * The quantities to forward to the contract.
     */
    quantitiesToContract?: CoinQuantity[];
    /**
     * A callback to sign the transaction.
     *
     * @param request - The transaction request to sign.
     * @returns A promise that resolves to the signed transaction request.
     */
    signatureCallback?: (request: ScriptTransactionRequest) => Promise<ScriptTransactionRequest>;
};
/**
 * Provider Call transaction params
 */
export type ProviderCallParams = UTXOValidationParams & EstimateTransactionParams;
/**
 * Provider Send transaction params
 */
export type ProviderSendTxParams = EstimateTransactionParams & {
    /**
     * By default, the promise will resolve immediately after the transaction is submitted.
     *
     * If set to true, the promise will resolve only when the transaction changes status
     * from `SubmittedStatus` to one of `SuccessStatus`, `FailureStatus` or `SqueezedOutStatus`.
     */
    awaitExecution?: boolean;
};
/**
 * A provider for connecting to a node
 */
export default class Provider {
    #private;
    url: string;
    operations: ReturnType<typeof getOperationsSdk>;
    cache?: MemoryCache;
    /** @hidden */
    static clearChainAndNodeCaches(): void;
    /** @hidden */
    private static chainInfoCache;
    /** @hidden */
    private static nodeInfoCache;
    options: ProviderOptions;
    /**
     * @hidden
     */
    private static getFetchFn;
    /**
     * Constructor to initialize a Provider.
     *
     * @param url - GraphQL endpoint of the Fuel node
     * @param options - Additional options for the provider
     * @hidden
     */
    protected constructor(url: string, options?: ProviderOptions);
    /**
     * Creates a new instance of the Provider class. This is the recommended way to initialize a Provider.
     *
     * @param url - GraphQL endpoint of the Fuel node
     * @param options - Additional options for the provider
     *
     * @returns A promise that resolves to a Provider instance.
     */
    static create(url: string, options?: ProviderOptions): Promise<Provider>;
    /**
     * Returns the cached chainInfo for the current URL.
     *
     * @returns the chain information configuration.
     */
    getChain(): ChainInfo;
    /**
     * Returns the cached nodeInfo for the current URL.
     *
     * @returns the node information configuration.
     */
    getNode(): NodeInfo;
    /**
     * Returns some helpful parameters related to gas fees.
     */
    getGasConfig(): {
        maxGasPerTx: BN;
        maxGasPerPredicate: BN;
        gasPriceFactor: BN;
        gasPerByte: BN;
        gasCosts: GasCosts;
    };
    /**
     * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
     *
     * @param url - The URL to connect to.
     * @param options - Additional options for the provider.
     */
    connect(url: string, options?: ProviderOptions): Promise<void>;
    /**
     * Return the chain and node information.
     *
     * @returns A promise that resolves to the Chain and NodeInfo.
     */
    fetchChainAndNodeInfo(): Promise<{
        chain: ChainInfo;
        nodeInfo: NodeInfo;
    }>;
    /**
     * @hidden
     */
    private static ensureClientVersionIsSupported;
    /**
     * Create GraphQL client and set operations.
     *
     * @returns The operation SDK object
     * @hidden
     */
    private createOperations;
    /**
     * Returns the version of the connected node.
     *
     * @returns A promise that resolves to the version string.
     */
    getVersion(): Promise<string>;
    /**
     * Returns the latest block number.
     *
     * @returns A promise that resolves to the latest block number.
     */
    getBlockNumber(): Promise<BN>;
    /**
     * Returns the node information for the current provider network.
     *
     * @returns a promise that resolves to the node information.
     */
    fetchNode(): Promise<NodeInfo>;
    /**
     * Returns the chain information for the current provider network.
     *
     * @returns a promise that resolves to the chain information.
     */
    fetchChain(): Promise<ChainInfo>;
    /**
     * Returns the chain ID for the current provider network.
     *
     * @returns A promise that resolves to the chain ID number.
     */
    getChainId(): number;
    /**
     * Returns the base asset ID for the current provider network.
     *
     * @returns the base asset ID.
     */
    getBaseAssetId(): string;
    /**
     * Submits a transaction to the chain to be executed.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param sendTransactionParams - The provider send transaction parameters (optional).
     * @returns A promise that resolves to the transaction response object.
     */
    sendTransaction(transactionRequestLike: TransactionRequestLike, { estimateTxDependencies, awaitExecution }?: ProviderSendTxParams): Promise<TransactionResponse>;
    /**
     * Executes a transaction without actually submitting it to the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param sendTransactionParams - The provider call parameters (optional).
     * @returns A promise that resolves to the call result object.
     */
    call(transactionRequestLike: TransactionRequestLike, { utxoValidation, estimateTxDependencies }?: ProviderCallParams): Promise<CallResult>;
    /**
     * Verifies whether enough gas is available to complete transaction.
     *
     * @template T - The type of the transaction request object.
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise that resolves to the estimated transaction request object.
     */
    estimatePredicates<T extends TransactionRequest>(transactionRequest: T): Promise<T>;
    /**
     * Will dryRun a transaction and check for missing dependencies.
     *
     * If there are missing variable outputs,
     * `addVariableOutputs` is called on the transaction.
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise that resolves to the estimate transaction dependencies.
     */
    estimateTxDependencies(transactionRequest: TransactionRequest): Promise<EstimateTxDependenciesReturns>;
    /**
     * Dry runs multiple transactions and checks for missing dependencies in batches.
     *
     * Transactions are dry run in batches. After each dry run, transactions requiring
     * further modifications are identified. The method iteratively updates these transactions
     * and performs subsequent dry runs until all dependencies for each transaction are satisfied.
     *
     * @param transactionRequests - Array of transaction request objects.
     * @returns A promise that resolves to an array of results for each transaction.
     */
    estimateMultipleTxDependencies(transactionRequests: TransactionRequest[]): Promise<EstimateTxDependenciesReturns[]>;
    /**
     * Dry runs multiple transactions.
     *
     * @param transactionRequests - Array of transaction request objects.
     * @param sendTransactionParams - The provider call parameters (optional).
     *
     * @returns A promise that resolves to an array of results for each transaction call.
     */
    dryRunMultipleTransactions(transactionRequests: TransactionRequest[], { utxoValidation, estimateTxDependencies }?: ProviderCallParams): Promise<CallResult[]>;
    /**
     * Estimates the transaction gas and fee based on the provided transaction request.
     * @param transactionRequest - The transaction request object.
     * @returns An object containing the estimated minimum gas, minimum fee, maximum gas, and maximum fee.
     */
    estimateTxGasAndFee(params: {
        transactionRequest: TransactionRequest;
        gasPrice?: BN;
    }): Promise<{
        minGas: BN;
        minFee: BN;
        maxGas: BN;
        maxFee: BN;
        gasPrice: BN;
        gasLimit: BN;
    }>;
    /**
     * Executes a signed transaction without applying the states changes
     * on the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added
     *
     * @param transactionRequestLike - The transaction request object.
     * @param estimateTxParams - The estimate transaction params (optional).
     * @returns A promise that resolves to the call result object.
     */
    simulate(transactionRequestLike: TransactionRequestLike, { estimateTxDependencies }?: EstimateTransactionParams): Promise<CallResult>;
    /**
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the the transaction.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param transactionCostParams - The transaction cost parameters (optional).
     *
     * @returns A promise that resolves to the transaction cost object.
     */
    getTransactionCost(transactionRequestLike: TransactionRequestLike, { resourcesOwner, signatureCallback, quantitiesToContract }?: TransactionCostParams): Promise<TransactionCost>;
    /**
     * Get the required quantities and associated resources for a transaction.
     *
     * @param owner - address to add resources from.
     * @param transactionRequestLike - transaction request to populate resources for.
     * @param quantitiesToContract - quantities for the contract (optional).
     *
     * @returns a promise resolving to the required quantities for the transaction.
     */
    getResourcesForTransaction(owner: string | AbstractAddress, transactionRequestLike: TransactionRequestLike, quantitiesToContract?: CoinQuantity[]): Promise<{
        gasPrice: BN;
        gasUsed: BN;
        minGas: BN;
        minFee: BN;
        maxFee: BN;
        maxGas: BN;
        receipts: TransactionResultReceipt[];
        outputVariables: number;
        missingContractIds: string[];
        estimatedPredicates: TransactionRequestInput[];
        addedSignatures: number;
        dryRunStatus?: DryRunStatus | undefined;
        updateMaxFee?: boolean | undefined;
        resources: Resource[];
        requiredQuantities: CoinQuantity[];
    }>;
    /**
     * Returns coins for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get (optional).
     * @param paginationArgs - Pagination arguments (optional).
     *
     * @returns A promise that resolves to the coins.
     */
    getCoins(owner: string | AbstractAddress, assetId?: BytesLike, paginationArgs?: CursorPaginationArgs): Promise<Coin[]>;
    /**
     * Returns resources for the given owner satisfying the spend query.
     *
     * @param owner - The address to get resources for.
     * @param quantities - The coin quantities to get.
     * @param excludedIds - IDs of excluded resources from the selection (optional).
     * @returns A promise that resolves to the resources.
     */
    getResourcesToSpend(owner: string | AbstractAddress, quantities: CoinQuantityLike[], excludedIds?: ExcludeResourcesOption): Promise<Resource[]>;
    /**
     * Returns block matching the given ID or height.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block or null.
     */
    getBlock(idOrHeight: string | number | 'latest'): Promise<Block | null>;
    /**
     * Returns all the blocks matching the given parameters.
     *
     * @param params - The parameters to query blocks.
     * @returns A promise that resolves to the blocks.
     */
    getBlocks(params: GqlGetBlocksQueryVariables): Promise<Block[]>;
    /**
     * Returns block matching the given ID or type, including transaction data.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block.
     */
    getBlockWithTransactions(
    /** ID or height of the block */
    idOrHeight: string | number | 'latest'): Promise<(Block & {
        transactions: Transaction[];
    }) | null>;
    /**
     * Get transaction with the given ID.
     *
     * @param transactionId - ID of the transaction.
     * @returns A promise that resolves to the transaction.
     */
    getTransaction<TTransactionType = void>(transactionId: string): Promise<Transaction<TTransactionType> | null>;
    /**
     * Get deployed contract with the given ID.
     *
     * @param contractId - ID of the contract.
     * @returns A promise that resolves to the contract.
     */
    getContract(contractId: string): Promise<ContractResult | null>;
    /**
     * Returns the balance for the given contract for the given asset ID.
     *
     * @param contractId - The contract ID to get the balance for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    getContractBalance(
    /** The contract ID to get the balance for */
    contractId: string | AbstractAddress, 
    /** The asset ID of coins to get */
    assetId: BytesLike): Promise<BN>;
    /**
     * Returns the balance for the given owner for the given asset ID.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    getBalance(
    /** The address to get coins for */
    owner: string | AbstractAddress, 
    /** The asset ID of coins to get */
    assetId: BytesLike): Promise<BN>;
    /**
     * Returns balances for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param paginationArgs - Pagination arguments (optional).
     * @returns A promise that resolves to the balances.
     */
    getBalances(owner: string | AbstractAddress, paginationArgs?: CursorPaginationArgs): Promise<CoinQuantity[]>;
    /**
     * Returns message for the given address.
     *
     * @param address - The address to get message from.
     * @param paginationArgs - Pagination arguments (optional).
     * @returns A promise that resolves to the messages.
     */
    getMessages(address: string | AbstractAddress, paginationArgs?: CursorPaginationArgs): Promise<Message[]>;
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param transactionId - The transaction to get message from.
     * @param messageId - The message id from MessageOut receipt.
     * @param commitBlockId - The commit block id (optional).
     * @param commitBlockHeight - The commit block height (optional).
     * @returns A promise that resolves to the message proof.
     */
    getMessageProof(transactionId: string, nonce: string, commitBlockId?: string, commitBlockHeight?: BN): Promise<MessageProof | null>;
    /**
     * Get the latest gas price from the node.
     *
     * @returns A promise that resolves to the latest gas price.
     */
    getLatestGasPrice(): Promise<BN>;
    /**
     * Returns the estimate gas price for the given block horizon.
     *
     * @param blockHorizon - The block horizon to estimate gas price for.
     * @returns A promise that resolves to the estimated gas price.
     */
    estimateGasPrice(blockHorizon: number): Promise<BN>;
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param nonce - The nonce of the message to get status from.
     * @returns A promise that resolves to the message status
     */
    getMessageStatus(
    /** The nonce of the message to get status from */
    nonce: string): Promise<MessageStatus>;
    /**
     * Lets you produce blocks with custom timestamps and the block number of the last block produced.
     *
     * @param amount - The amount of blocks to produce.
     * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block (optional).
     * @returns A promise that resolves to the block number of the last produced block.
     */
    produceBlocks(amount: number, startTime?: number): Promise<BN>;
    /**
     * Get the transaction response for the given transaction ID.
     *
     * @param transactionId - The transaction ID to get the response for.
     * @returns A promise that resolves to the transaction response.
     */
    getTransactionResponse(transactionId: string): Promise<TransactionResponse>;
    /**
     * Returns Message for given nonce.
     *
     * @param nonce - The nonce of the message to retrieve.
     * @returns A promise that resolves to the Message object or null.
     */
    getMessageByNonce(nonce: string): Promise<GqlMessage | null>;
    /**
     * Get the relayed transaction for the given transaction ID.
     *
     * @param relayedTransactionId - The relayed transaction ID to get the response for.
     * @returns A promise that resolves to the relayed transaction.
     */
    getRelayedTransactionStatus(relayedTransactionId: string): Promise<GqlRelayedTransactionFailed | null>;
    /**
     * @hidden
     */
    private extractDryRunError;
}
//# sourceMappingURL=provider.d.ts.map