{"version":3,"sources":["../src/index.ts","../src/utils.ts","../src/functions/invocation-scope.ts","../src/functions/base-invocation-scope.ts","../src/contract-call-script.ts","../src/instruction-set.ts","../src/script-request.ts","../src/functions/invocation-results.ts","../src/functions/multicall-scope.ts","../src/contract.ts"],"sourcesContent":["export * from './types';\nexport * from './utils';\nexport { FunctionInvocationScope } from './functions/invocation-scope';\nexport { MultiCallInvocationScope } from './functions/multicall-scope';\nexport {\n  InvocationResult,\n  FunctionInvocationResult,\n  InvocationCallResult,\n} from './functions/invocation-results';\nexport { default as Contract } from './contract';\nexport { ScriptRequest } from './script-request';\nexport { InstructionSet } from './instruction-set';\n","import type { JsonAbisFromAllCalls } from '@fuel-ts/account';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractContract } from '@fuel-ts/interfaces';\n\nimport type { InvocationScopeLike } from './types';\n\n/**\n * @hidden\n *\n * Generic assert function to avoid undesirable errors\n */\nexport function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) {\n    throw new FuelError(ErrorCode.TRANSACTION_ERROR, message);\n  }\n}\n\n/**\n * @hidden\n *\n * Gets the ABI from an array of InvocationScopeLike.\n */\nexport function getAbisFromAllCalls(\n  functionScopes: Array<InvocationScopeLike>\n): JsonAbisFromAllCalls {\n  return functionScopes.reduce((acc, funcScope, i) => {\n    const { program, externalAbis } = funcScope.getCallConfig();\n\n    if (i === 0) {\n      acc.main = program.interface.jsonAbi;\n      acc.otherContractsAbis = {};\n    } else {\n      acc.otherContractsAbis[(<AbstractContract>program).id.toB256()] = program.interface.jsonAbi;\n    }\n\n    acc.otherContractsAbis = { ...acc.otherContractsAbis, ...externalAbis };\n\n    return acc;\n  }, {} as JsonAbisFromAllCalls);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { FunctionFragment } from '@fuel-ts/abi-coder';\nimport type { CoinQuantity } from '@fuel-ts/account';\nimport { coinQuantityfy } from '@fuel-ts/account';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractProgram } from '@fuel-ts/interfaces';\n\nimport type { CallConfig, CallParams } from '../types';\n\nimport { BaseInvocationScope } from './base-invocation-scope';\n\n/**\n * Represents a scope for invoking a function.\n *\n * @template TArgs - The type of the function arguments.\n * @template TReturn - The type of the return value.\n */\nexport class FunctionInvocationScope<\n  TArgs extends Array<any> = Array<any>,\n  TReturn = any,\n> extends BaseInvocationScope<TReturn> {\n  protected func: FunctionFragment;\n  private callParameters?: CallParams;\n  private forward?: CoinQuantity;\n  protected args: TArgs;\n\n  /**\n   * Constructs an instance of FunctionInvocationScope.\n   *\n   * @param program - The program.\n   * @param func - The function fragment.\n   * @param args - The arguments.\n   */\n  constructor(program: AbstractProgram, func: FunctionFragment, args: TArgs) {\n    super(program, false);\n    this.func = func;\n    this.args = args || [];\n    this.setArguments(...args);\n    super.addCall(this);\n  }\n\n  /**\n   * Gets the call configuration.\n   *\n   * @returns The call configuration.\n   */\n  getCallConfig(): CallConfig<TArgs> {\n    return {\n      func: this.func,\n      program: this.program,\n      callParameters: this.callParameters,\n      txParameters: this.txParameters,\n      forward: this.forward,\n      args: this.args,\n      externalAbis: this.externalAbis,\n    };\n  }\n\n  /**\n   * Sets the arguments for the function invocation.\n   *\n   * @param args - The arguments.\n   * @returns The instance of FunctionInvocationScope.\n   */\n  setArguments(...args: TArgs) {\n    this.args = args || [];\n    return this;\n  }\n\n  /**\n   * Sets the call parameters for the function invocation.\n   *\n   * @param callParams - The call parameters.\n   * @returns The instance of FunctionInvocationScope.\n   * @throws If the function is not payable and forward is set.\n   */\n  callParams(callParams: CallParams) {\n    if (!this.hasCallParamsGasLimit && callParams?.gasLimit !== undefined) {\n      this.hasCallParamsGasLimit = true;\n    }\n    this.callParameters = callParams;\n\n    if (callParams?.forward) {\n      if (!this.func.attributes.find((attr) => attr.name === 'payable')) {\n        throw new FuelError(\n          ErrorCode.TRANSACTION_ERROR,\n          `The target function ${this.func.name} cannot accept forwarded funds as it's not marked as 'payable'.`\n        );\n      }\n\n      this.forward = coinQuantityfy(callParams.forward);\n    }\n\n    // Update transaction script with new forward params\n    this.setArguments(...this.args);\n\n    // Update required coins\n    this.updateRequiredCoins();\n\n    return this;\n  }\n}\n","/* eslint-disable no-param-reassign */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { InputValue, JsonAbi } from '@fuel-ts/abi-coder';\nimport type { Provider, CoinQuantity, CallResult, Account, TransferParams } from '@fuel-ts/account';\nimport { ScriptTransactionRequest } from '@fuel-ts/account';\nimport { Address } from '@fuel-ts/address';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractAccount, AbstractContract, AbstractProgram } from '@fuel-ts/interfaces';\nimport type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport { InputType, TransactionType } from '@fuel-ts/transactions';\nimport { isDefined } from '@fuel-ts/utils';\nimport * as asm from '@fuels/vm-asm';\nimport { clone } from 'ramda';\n\nimport { getContractCallScript } from '../contract-call-script';\nimport type { ContractCall, InvocationScopeLike, TxParams } from '../types';\nimport { assert, getAbisFromAllCalls } from '../utils';\n\nimport { InvocationCallResult, FunctionInvocationResult } from './invocation-results';\n\n/**\n * Creates a contract call object based on the provided invocation scope.\n *\n * @param funcScope - The invocation scope containing the necessary information for the contract call.\n * @returns The contract call object.\n */\nfunction createContractCall(funcScope: InvocationScopeLike): ContractCall {\n  const { program, args, forward, func, callParameters, externalAbis } = funcScope.getCallConfig();\n  const data = func.encodeArguments(args as Array<InputValue>);\n\n  return {\n    contractId: (program as AbstractContract).id,\n    fnSelector: func.selector,\n    fnSelectorBytes: func.selectorBytes,\n    encoding: func.encoding,\n    data,\n    assetId: forward?.assetId,\n    amount: forward?.amount,\n    gas: callParameters?.gasLimit,\n    externalContractsAbis: externalAbis,\n  };\n}\n\n/**\n * Base class for managing invocation scopes and preparing transactions.\n */\nexport class BaseInvocationScope<TReturn = any> {\n  protected transactionRequest: ScriptTransactionRequest;\n  protected program: AbstractProgram;\n  protected functionInvocationScopes: Array<InvocationScopeLike> = [];\n  protected txParameters?: TxParams;\n  protected requiredCoins: CoinQuantity[] = [];\n  protected isMultiCall: boolean = false;\n  protected hasCallParamsGasLimit: boolean = false; // flag to check if any of the callParams has gasLimit set\n  protected externalAbis: Record<string, JsonAbi> = {};\n  private addSignersCallback?: (\n    txRequest: ScriptTransactionRequest\n  ) => Promise<ScriptTransactionRequest>;\n\n  /**\n   * Constructs an instance of BaseInvocationScope.\n   *\n   * @param program - The abstract program to be invoked.\n   * @param isMultiCall - A flag indicating whether the invocation is a multi-call.\n   */\n  constructor(program: AbstractProgram, isMultiCall: boolean) {\n    this.program = program;\n    this.isMultiCall = isMultiCall;\n    this.transactionRequest = new ScriptTransactionRequest();\n  }\n\n  /**\n   * Getter for the contract calls.\n   *\n   * @returns An array of contract calls.\n   */\n  protected get calls() {\n    const provider = this.getProvider();\n    const consensusParams = provider.getChain();\n    // TODO: Remove this error since it is already handled on Provider class\n    if (!consensusParams) {\n      throw new FuelError(\n        FuelError.CODES.CHAIN_INFO_CACHE_EMPTY,\n        'Provider chain info cache is empty. Please make sure to initialize the `Provider` properly by running `await Provider.create()``'\n      );\n    }\n    return this.functionInvocationScopes.map((funcScope) => createContractCall(funcScope));\n  }\n\n  /**\n   * Updates the script request with the current contract calls.\n   */\n  protected updateScriptRequest() {\n    const provider = this.getProvider();\n    const {\n      consensusParameters: {\n        txParameters: { maxInputs },\n      },\n    } = provider.getChain();\n    const contractCallScript = getContractCallScript(this.functionInvocationScopes, maxInputs);\n    this.transactionRequest.setScript(contractCallScript, this.calls);\n  }\n\n  /**\n   * Updates the transaction request with the current input/output.\n   */\n  protected updateContractInputAndOutput() {\n    const calls = this.calls;\n    calls.forEach((c) => {\n      if (c.contractId) {\n        this.transactionRequest.addContractInputAndOutput(c.contractId);\n      }\n      if (c.externalContractsAbis) {\n        Object.keys(c.externalContractsAbis).forEach((contractId) =>\n          this.transactionRequest.addContractInputAndOutput(Address.fromB256(contractId))\n        );\n      }\n    });\n  }\n\n  /**\n   * Gets the required coins for the transaction.\n   *\n   * @returns An array of required coin quantities.\n   */\n  protected getRequiredCoins(): Array<CoinQuantity> {\n    const forwardingAssets = this.calls\n      .map((call) => ({\n        assetId: String(call.assetId),\n        amount: bn(call.amount || 0),\n      }))\n      .filter(({ assetId, amount }) => assetId && !bn(amount).isZero());\n    return forwardingAssets;\n  }\n\n  /**\n   * Updates the required coins for the transaction.\n   */\n  protected updateRequiredCoins() {\n    const assets = this.getRequiredCoins();\n    const reduceForwardCoins = (\n      requiredCoins: Map<any, CoinQuantity>,\n      { assetId, amount }: CoinQuantity\n    ) => {\n      const currentAmount = requiredCoins.get(assetId)?.amount || bn(0);\n\n      return requiredCoins.set(assetId, {\n        assetId: String(assetId),\n        amount: currentAmount.add(amount),\n      });\n    };\n    this.requiredCoins = Array.from(\n      assets.reduce(reduceForwardCoins, new Map<any, CoinQuantity>()).values()\n    );\n  }\n\n  /**\n   * Adds a single call to the invocation scope.\n   *\n   * @param funcScope - The function scope to add.\n   * @returns The current instance of the class.\n   */\n  protected addCall(funcScope: InvocationScopeLike) {\n    this.addCalls([funcScope]);\n    return this;\n  }\n\n  /**\n   * Adds multiple calls to the invocation scope.\n   *\n   * @param funcScopes - An array of function scopes to add.\n   * @returns The current instance of the class.\n   */\n  protected addCalls(funcScopes: Array<InvocationScopeLike>) {\n    this.functionInvocationScopes.push(...funcScopes);\n    this.updateContractInputAndOutput();\n    this.updateRequiredCoins();\n    return this;\n  }\n\n  /**\n   * Prepares the transaction by updating the script request, required coins, and checking the gas limit.\n   */\n  protected async prepareTransaction() {\n    // @ts-expect-error Property 'initWasm' does exist on type and is defined\n    await asm.initWasm();\n\n    // Update request scripts before call\n    this.updateScriptRequest();\n\n    // Update required coins before call\n    this.updateRequiredCoins();\n\n    // Check if gasLimit is less than the\n    // sum of all call gasLimits\n    this.checkGasLimitTotal();\n\n    if (this.transactionRequest.type === TransactionType.Script) {\n      this.transactionRequest.abis = getAbisFromAllCalls(this.functionInvocationScopes);\n    }\n  }\n\n  /**\n   * Checks if the total gas limit is within the acceptable range.\n   */\n  protected checkGasLimitTotal() {\n    const gasLimitOnCalls = this.calls.reduce((total, call) => total.add(call.gas || 0), bn(0));\n\n    if (this.transactionRequest.gasLimit.eq(0)) {\n      this.transactionRequest.gasLimit = gasLimitOnCalls;\n    } else if (gasLimitOnCalls.gt(this.transactionRequest.gasLimit)) {\n      throw new FuelError(\n        ErrorCode.TRANSACTION_ERROR,\n        \"Transaction's gasLimit must be equal to or greater than the combined forwarded gas of all calls.\"\n      );\n    }\n  }\n\n  /**\n   * Gets the transaction cost ny dry running the transaction.\n   *\n   * @param options - Optional transaction cost options.\n   * @returns The transaction cost details.\n   */\n  async getTransactionCost() {\n    const provider = this.getProvider();\n\n    const request = await this.getTransactionRequest();\n    const txCost = await provider.getTransactionCost(request, {\n      resourcesOwner: this.program.account as AbstractAccount,\n      quantitiesToContract: this.getRequiredCoins(),\n      signatureCallback: this.addSignersCallback,\n    });\n\n    return txCost;\n  }\n\n  /**\n   * Funds the transaction with the required coins.\n   *\n   * @returns The current instance of the class.\n   */\n  async fundWithRequiredCoins() {\n    let transactionRequest = await this.getTransactionRequest();\n    transactionRequest = clone(transactionRequest);\n\n    const txCost = await this.getTransactionCost();\n    const { gasUsed, missingContractIds, outputVariables, maxFee } = txCost;\n    this.setDefaultTxParams(transactionRequest, gasUsed, maxFee);\n    // Clean coin inputs before add new coins to the request\n    transactionRequest.inputs = transactionRequest.inputs.filter((i) => i.type !== InputType.Coin);\n\n    // Adding missing contract ids\n    missingContractIds.forEach((contractId) => {\n      transactionRequest.addContractInputAndOutput(Address.fromString(contractId));\n    });\n\n    // Adding required number of OutputVariables\n    transactionRequest.addVariableOutputs(outputVariables);\n\n    await this.program.account?.fund(transactionRequest, txCost);\n\n    if (this.addSignersCallback) {\n      await this.addSignersCallback(transactionRequest);\n    }\n    return transactionRequest;\n  }\n\n  /**\n   * Sets the transaction parameters.\n   *\n   * @param txParams - The transaction parameters to set.\n   * @returns The current instance of the class.\n   */\n  txParams(txParams: TxParams) {\n    this.txParameters = txParams;\n    const request = this.transactionRequest;\n\n    request.tip = bn(txParams.tip || request.tip);\n    request.gasLimit = bn(txParams.gasLimit || request.gasLimit);\n    request.maxFee = txParams.maxFee ? bn(txParams.maxFee) : request.maxFee;\n    request.witnessLimit = txParams.witnessLimit ? bn(txParams.witnessLimit) : request.witnessLimit;\n    request.maturity = txParams.maturity || request.maturity;\n\n    request.addVariableOutputs(this.txParameters?.variableOutputs || 0);\n\n    return this;\n  }\n\n  /**\n   * Adds contracts to the invocation scope.\n   *\n   * @param contracts - An array of contracts to add.\n   * @returns The current instance of the class.\n   */\n  addContracts(contracts: Array<AbstractContract>) {\n    contracts.forEach((contract) => {\n      this.transactionRequest.addContractInputAndOutput(contract.id);\n      this.externalAbis[contract.id.toB256()] = contract.interface.jsonAbi;\n    });\n    return this;\n  }\n\n  /**\n   * Adds an asset transfer to an Account on the contract call transaction request.\n   *\n   * @param transferParams - The object representing the transfer to be made.\n   * @returns The current instance of the class.\n   */\n  addTransfer(transferParams: TransferParams) {\n    const { amount, destination, assetId } = transferParams;\n    const baseAssetId = this.getProvider().getBaseAssetId();\n    this.transactionRequest = this.transactionRequest.addCoinOutput(\n      Address.fromAddressOrString(destination),\n      amount,\n      assetId || baseAssetId\n    );\n\n    return this;\n  }\n\n  /**\n   * Adds multiple transfers to the contract call transaction request.\n   *\n   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.\n   * @returns The current instance of the class.\n   */\n  addBatchTransfer(transferParams: TransferParams[]) {\n    const baseAssetId = this.getProvider().getBaseAssetId();\n    transferParams.forEach(({ destination, amount, assetId }) => {\n      this.transactionRequest = this.transactionRequest.addCoinOutput(\n        Address.fromAddressOrString(destination),\n        amount,\n        assetId || baseAssetId\n      );\n    });\n\n    return this;\n  }\n\n  addSigners(signers: Account | Account[]) {\n    this.addSignersCallback = async (transactionRequest) =>\n      transactionRequest.addAccountWitnesses(signers);\n\n    return this;\n  }\n\n  /**\n   * Prepares and returns the transaction request object.\n   *\n   * @returns The prepared transaction request.\n   */\n  async getTransactionRequest(): Promise<ScriptTransactionRequest> {\n    await this.prepareTransaction();\n    return this.transactionRequest;\n  }\n\n  /**\n   * Submits a transaction.\n   *\n   * @returns The result of the function invocation.\n   */\n  async call<T = TReturn>(): Promise<FunctionInvocationResult<T>> {\n    assert(this.program.account, 'Wallet is required!');\n\n    const transactionRequest = await this.fundWithRequiredCoins();\n\n    const response = await this.program.account.sendTransaction(transactionRequest, {\n      awaitExecution: true,\n      estimateTxDependencies: false,\n    });\n\n    return FunctionInvocationResult.build<T>(\n      this.functionInvocationScopes,\n      response,\n      this.isMultiCall,\n      this.program as AbstractContract\n    );\n  }\n\n  /**\n   * Simulates a transaction.\n   *\n   * @returns The result of the invocation call.\n   */\n  async simulate<T = TReturn>(): Promise<InvocationCallResult<T>> {\n    assert(this.program.account, 'Wallet is required!');\n\n    if (!('populateTransactionWitnessesSignature' in this.program.account)) {\n      throw new FuelError(\n        ErrorCode.ABI_MAIN_METHOD_MISSING,\n        'An unlocked wallet is required to simulate a contract call.'\n      );\n    }\n    const transactionRequest = await this.fundWithRequiredCoins();\n\n    const result = await this.program.account.simulateTransaction(transactionRequest, {\n      estimateTxDependencies: false,\n    });\n\n    return InvocationCallResult.build<T>(this.functionInvocationScopes, result, this.isMultiCall);\n  }\n\n  /**\n   * Executes a transaction in dry run mode.\n   *\n   * @returns The result of the invocation call.\n   */\n  async dryRun<T = TReturn>(): Promise<InvocationCallResult<T>> {\n    const { receipts } = await this.getTransactionCost();\n\n    const callResult: CallResult = {\n      receipts,\n    };\n\n    return InvocationCallResult.build<T>(\n      this.functionInvocationScopes,\n      callResult,\n      this.isMultiCall\n    );\n  }\n\n  async get<T = TReturn>(): Promise<InvocationCallResult<T>> {\n    const { receipts } = await this.getTransactionCost();\n\n    const callResult: CallResult = {\n      receipts,\n    };\n\n    return InvocationCallResult.build<T>(\n      this.functionInvocationScopes,\n      callResult,\n      this.isMultiCall\n    );\n  }\n\n  getProvider(): Provider {\n    const provider = <Provider>this.program.provider;\n\n    return provider;\n  }\n\n  /**\n   * Obtains the ID of a transaction.\n   *\n   * @param chainId - the chainId to use to hash the transaction with\n   * @returns the ID of the transaction.\n   */\n  async getTransactionId(chainId?: number): Promise<string> {\n    const chainIdToHash = chainId ?? (await this.getProvider().getChainId());\n\n    const transactionRequest = await this.getTransactionRequest();\n    return transactionRequest.getTransactionId(chainIdToHash);\n  }\n\n  /**\n   * In case the gasLimit is *not* set by the user, this method sets a default value.\n   */\n  private setDefaultTxParams(\n    transactionRequest: ScriptTransactionRequest,\n    gasUsed: BN,\n    maxFee: BN\n  ) {\n    const gasLimitSpecified = isDefined(this.txParameters?.gasLimit) || this.hasCallParamsGasLimit;\n    const maxFeeSpecified = isDefined(this.txParameters?.maxFee);\n\n    const { gasLimit: setGasLimit, maxFee: setMaxFee } = transactionRequest;\n\n    if (!gasLimitSpecified) {\n      transactionRequest.gasLimit = gasUsed;\n    } else if (setGasLimit.lt(gasUsed)) {\n      throw new FuelError(\n        ErrorCode.GAS_LIMIT_TOO_LOW,\n        `Gas limit '${setGasLimit}' is lower than the required: '${gasUsed}'.`\n      );\n    }\n\n    if (!maxFeeSpecified) {\n      transactionRequest.maxFee = maxFee;\n    } else if (maxFee.gt(setMaxFee)) {\n      throw new FuelError(\n        ErrorCode.MAX_FEE_TOO_LOW,\n        `Max fee '${setMaxFee}' is lower than the required: '${maxFee}'.`\n      );\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  WORD_SIZE,\n  B256Coder,\n  ASSET_ID_LEN,\n  BigNumberCoder,\n  CONTRACT_ID_LEN,\n} from '@fuel-ts/abi-coder';\nimport type {\n  CallResult,\n  TransactionResultCallReceipt,\n  TransactionResultReturnDataReceipt,\n  TransactionResultReturnReceipt,\n} from '@fuel-ts/account';\nimport { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { BN } from '@fuel-ts/math';\nimport { bn, toNumber } from '@fuel-ts/math';\nimport { ReceiptType } from '@fuel-ts/transactions';\nimport { concat, arrayify } from '@fuel-ts/utils';\nimport * as asm from '@fuels/vm-asm';\n\nimport { InstructionSet } from './instruction-set';\nimport type { EncodedScriptCall, ScriptResult } from './script-request';\nimport { decodeCallResult, ScriptRequest, calculateScriptDataBaseOffset } from './script-request';\nimport type { ContractCall, InvocationScopeLike } from './types';\n\ntype CallOpcodeParamsOffset = {\n  callDataOffset: number;\n  gasForwardedOffset: number;\n  amountOffset: number;\n  assetIdOffset: number;\n};\n\nconst DEFAULT_OPCODE_PARAMS: CallOpcodeParamsOffset = {\n  assetIdOffset: 0,\n  amountOffset: 0,\n  gasForwardedOffset: 0,\n  callDataOffset: 0,\n};\n\n// During a script execution, this script's contract id is the **null** contract id\nconst SCRIPT_WRAPPER_CONTRACT_ID = ZeroBytes32;\n\n// Returns the VM instructions for calling a contract method\n// We use the [`Opcode`] to call a contract: [`CALL`](Opcode::CALL)\n// pointing at the following registers:\n//\n// 0x10 Script data offset\n// 0x11 Coin amount\n// 0x12 Asset ID\n// 0x13 Gas forwarded\n//\n// These are arbitrary non-reserved registers, no special meaning\nconst getSingleCallInstructions = ({\n  callDataOffset,\n  gasForwardedOffset,\n  amountOffset,\n  assetIdOffset,\n}: CallOpcodeParamsOffset): InstructionSet => {\n  const inst = new InstructionSet(\n    asm.movi(0x10, callDataOffset),\n    asm.movi(0x11, amountOffset),\n    asm.lw(0x11, 0x11, 0),\n    asm.movi(0x12, assetIdOffset)\n  );\n\n  if (gasForwardedOffset) {\n    inst.push(\n      asm.movi(0x13, gasForwardedOffset),\n      asm.lw(0x13, 0x13, 0),\n      asm.call(0x10, 0x11, 0x12, 0x13)\n    );\n  } else {\n    inst.push(asm.call(0x10, 0x11, 0x12, asm.RegId.cgas().to_u8()));\n  }\n\n  return inst;\n};\n// Given a list of contract calls, create the actual opcodes used to call the contract\nfunction getInstructions(offsets: CallOpcodeParamsOffset[]): Uint8Array {\n  if (!offsets.length) {\n    return new Uint8Array();\n  }\n\n  const multiCallInstructions = new InstructionSet();\n  for (let i = 0; i < offsets.length; i += 1) {\n    multiCallInstructions.extend(getSingleCallInstructions(offsets[i]).entries());\n  }\n\n  multiCallInstructions.push(asm.ret(0x01));\n  return multiCallInstructions.toBytes();\n}\n\ntype ReturnReceipt = TransactionResultReturnReceipt | TransactionResultReturnDataReceipt;\n\nconst isReturnType = (type: ReturnReceipt['type']) =>\n  type === ReceiptType.Return || type === ReceiptType.ReturnData;\n\nconst getMainCallReceipt = (\n  receipts: TransactionResultCallReceipt[],\n  contractId: string\n): TransactionResultCallReceipt | undefined =>\n  receipts.find(\n    ({ type, from, to }) =>\n      type === ReceiptType.Call && from === SCRIPT_WRAPPER_CONTRACT_ID && to === contractId\n  );\n\nconst scriptResultDecoder = (contractId: AbstractAddress) => (result: ScriptResult) => {\n  if (toNumber(result.code) !== 0) {\n    throw new FuelError(ErrorCode.SCRIPT_REVERTED, `Transaction reverted.`);\n  }\n\n  const mainCallResult = getMainCallReceipt(\n    result.receipts as TransactionResultCallReceipt[],\n    contractId.toB256()\n  );\n  const mainCallInstructionStart = bn(mainCallResult?.is);\n\n  const receipts = result.receipts as ReturnReceipt[];\n  return receipts\n    .filter(({ type }) => isReturnType(type))\n    .flatMap((receipt: ReturnReceipt) => {\n      if (!mainCallInstructionStart.eq(bn(receipt.is))) {\n        return [];\n      }\n      if (receipt.type === ReceiptType.Return) {\n        return [new BigNumberCoder('u64').encode((receipt as TransactionResultReturnReceipt).val)];\n      }\n      if (receipt.type === ReceiptType.ReturnData) {\n        const encodedScriptReturn = arrayify(receipt.data);\n\n        return [encodedScriptReturn];\n      }\n\n      return [new Uint8Array()];\n    });\n};\n\nexport const decodeContractCallScriptResult = (\n  callResult: CallResult,\n  contractId: AbstractAddress,\n  logs: Array<any> = []\n): Uint8Array[] => decodeCallResult(callResult, scriptResultDecoder(contractId), logs);\n\nconst getCallInstructionsLength = (contractCalls: ContractCall[]): number =>\n  contractCalls.reduce(\n    (sum, call) => {\n      const offset: CallOpcodeParamsOffset = { ...DEFAULT_OPCODE_PARAMS };\n      if (call.gas) {\n        offset.gasForwardedOffset = 1;\n      }\n\n      return sum + getSingleCallInstructions(offset).byteLength();\n    },\n    asm.Instruction.size() // placeholder for single RET instruction which is added later\n  );\n\nexport const getContractCallScript = (\n  functionScopes: InvocationScopeLike[],\n  maxInputs: BN\n): ScriptRequest<ContractCall[], Uint8Array[]> =>\n  new ScriptRequest<ContractCall[], Uint8Array[]>(\n    // Script to call the contract, start with stub size matching length of calls\n    getInstructions(new Array(functionScopes.length).fill(DEFAULT_OPCODE_PARAMS)),\n    (contractCalls): EncodedScriptCall => {\n      const TOTAL_CALLS = contractCalls.length;\n\n      if (TOTAL_CALLS === 0) {\n        return { data: new Uint8Array(), script: new Uint8Array() };\n      }\n\n      // Get total data offset AFTER all scripts\n      const callInstructionsLength = getCallInstructionsLength(contractCalls);\n\n      // Pad length\n      const paddingLength = (8 - (callInstructionsLength % 8)) % 8;\n      const paddedInstructionsLength = callInstructionsLength + paddingLength;\n\n      // Base offset\n      const dataOffset =\n        calculateScriptDataBaseOffset(maxInputs.toNumber()) + paddedInstructionsLength;\n\n      // The data for each call is ordered into segments\n      const paramOffsets: CallOpcodeParamsOffset[] = [];\n      // the data about the contract output\n      let segmentOffset = dataOffset;\n\n      const scriptData: Uint8Array[] = [];\n      for (let i = 0; i < TOTAL_CALLS; i += 1) {\n        const call = contractCalls[i];\n\n        const amountOffset = segmentOffset;\n        const assetIdOffset = amountOffset + WORD_SIZE;\n        const callDataOffset = assetIdOffset + ASSET_ID_LEN;\n        const encodedSelectorOffset = callDataOffset + CONTRACT_ID_LEN + WORD_SIZE + WORD_SIZE;\n        const encodedArgsOffset = encodedSelectorOffset + call.fnSelectorBytes.byteLength;\n        const encodedArgs = arrayify(call.data);\n        let gasForwardedOffset = 0;\n\n        // 1. Amount\n        scriptData.push(new BigNumberCoder('u64').encode(call.amount || 0));\n        // 2. Asset ID\n        scriptData.push(new B256Coder().encode(call.assetId?.toString() || ZeroBytes32));\n        // 3. Contract ID\n        scriptData.push(call.contractId.toBytes());\n        // 4. Function selector offset\n        scriptData.push(new BigNumberCoder('u64').encode(encodedSelectorOffset));\n        // 5. Encoded argument offset\n        scriptData.push(new BigNumberCoder('u64').encode(encodedArgsOffset));\n        // 6. Encoded function selector\n        scriptData.push(call.fnSelectorBytes);\n        // 7. Encoded arguments\n        scriptData.push(encodedArgs);\n\n        // 8. Gas to be forwarded\n        if (call.gas) {\n          scriptData.push(new BigNumberCoder('u64').encode(call.gas));\n          gasForwardedOffset = encodedArgsOffset + encodedArgs.byteLength;\n        }\n\n        const callParamOffsets: CallOpcodeParamsOffset = {\n          amountOffset,\n          assetIdOffset,\n          gasForwardedOffset,\n          callDataOffset,\n        };\n\n        // store param offsets for asm instructions later\n        paramOffsets.push(callParamOffsets);\n        segmentOffset = dataOffset + concat(scriptData).byteLength;\n      }\n\n      // get asm instructions\n      const script = getInstructions(paramOffsets);\n      const finalScriptData = concat(scriptData);\n      return { data: finalScriptData, script };\n    },\n    () => [new Uint8Array()]\n  );\n","import { concat, hexlify } from '@fuel-ts/utils';\nimport type * as asm from '@fuels/vm-asm';\n\n/**\n * A wrapper around fuel-asm to make dynamic instructions and convert to different formats\n */\nexport class InstructionSet {\n  #operations: asm.Instruction[];\n\n  constructor(...args: asm.Instruction[]) {\n    this.#operations = args || [];\n  }\n\n  entries(): asm.Instruction[] {\n    return this.#operations;\n  }\n\n  push(...args: asm.Instruction[]) {\n    this.#operations.push(...args);\n  }\n\n  concat(ops: asm.Instruction[]): asm.Instruction[] {\n    return this.#operations.concat(ops);\n  }\n\n  extend(ops: asm.Instruction[]) {\n    this.#operations.push(...ops);\n  }\n\n  toBytes(): Uint8Array {\n    return concat(\n      this.#operations.reduce((instructions, line) => {\n        instructions.push(line.to_bytes());\n        return instructions;\n      }, [] as Uint8Array[])\n    );\n  }\n\n  toHex(): string {\n    return hexlify(this.toBytes());\n  }\n\n  toString() {\n    return `Program:\\n${JSON.stringify(this.#operations, null, 2)}`;\n  }\n\n  byteLength() {\n    return this.toBytes().byteLength;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  ASSET_ID_LEN,\n  CONTRACT_ID_LEN,\n  SCRIPT_FIXED_SIZE,\n  WORD_SIZE,\n  calculateVmTxMemory,\n} from '@fuel-ts/abi-coder';\nimport type {\n  TransactionResultReturnDataReceipt,\n  TransactionResultRevertReceipt,\n  CallResult,\n  TransactionResultReceipt,\n  TransactionResultReturnReceipt,\n  TransactionResultScriptResultReceipt,\n  DryRunFailureStatusFragment,\n} from '@fuel-ts/account';\nimport { extractTxError } from '@fuel-ts/account';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BytesLike } from '@fuel-ts/interfaces';\nimport type { BN } from '@fuel-ts/math';\nimport type { ReceiptScriptResult } from '@fuel-ts/transactions';\nimport { ReceiptType } from '@fuel-ts/transactions';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport type { CallConfig } from './types';\n\nexport const calculateScriptDataBaseOffset = (maxInputs: number) =>\n  SCRIPT_FIXED_SIZE + calculateVmTxMemory({ maxInputs });\nexport const POINTER_DATA_OFFSET =\n  WORD_SIZE + ASSET_ID_LEN + CONTRACT_ID_LEN + WORD_SIZE + WORD_SIZE;\n/**\n * Represents a script result, containing information about the script execution.\n */\nexport type ScriptResult = {\n  code: BN;\n  gasUsed: BN;\n  receipts: TransactionResultReceipt[];\n  scriptResultReceipt: TransactionResultScriptResultReceipt;\n  returnReceipt:\n    | TransactionResultReturnReceipt\n    | TransactionResultReturnDataReceipt\n    | TransactionResultRevertReceipt;\n  callResult: CallResult;\n};\n\n/**\n * Converts a CallResult to a ScriptResult by extracting relevant information.\n *\n * @param callResult - The CallResult from the script call.\n * @returns The converted ScriptResult.\n */\nfunction callResultToScriptResult(callResult: CallResult): ScriptResult {\n  const receipts = [...callResult.receipts];\n\n  let scriptResultReceipt: ReceiptScriptResult | undefined;\n  let returnReceipt:\n    | TransactionResultReturnReceipt\n    | TransactionResultReturnDataReceipt\n    | TransactionResultRevertReceipt\n    | undefined;\n\n  receipts.forEach((receipt) => {\n    if (receipt.type === ReceiptType.ScriptResult) {\n      scriptResultReceipt = receipt;\n    } else if (\n      receipt.type === ReceiptType.Return ||\n      receipt.type === ReceiptType.ReturnData ||\n      receipt.type === ReceiptType.Revert\n    ) {\n      returnReceipt = receipt;\n    }\n  });\n\n  if (!scriptResultReceipt || !returnReceipt) {\n    throw new FuelError(ErrorCode.SCRIPT_REVERTED, `Transaction reverted.`);\n  }\n\n  const scriptResult: ScriptResult = {\n    code: scriptResultReceipt.result,\n    gasUsed: scriptResultReceipt.gasUsed,\n    receipts,\n    scriptResultReceipt,\n    returnReceipt,\n    callResult,\n  };\n\n  return scriptResult;\n}\n\n/**\n * Decodes a CallResult using the provided decoder function.\n *\n * @param callResult - The CallResult to decode.\n * @param decoder - The decoding function to apply on the ScriptResult.\n * @param logs - Optional logs associated with the decoding.\n * @returns The decoded result.\n * @throws Throws an error if decoding fails.\n */\nexport function decodeCallResult<TResult>(\n  callResult: CallResult,\n  decoder: (scriptResult: ScriptResult) => TResult,\n  logs: Array<any> = []\n): TResult {\n  try {\n    const scriptResult = callResultToScriptResult(callResult);\n    return decoder(scriptResult);\n  } catch (error) {\n    if ((<FuelError>error).code === ErrorCode.SCRIPT_REVERTED) {\n      const statusReason = (<DryRunFailureStatusFragment>callResult?.dryRunStatus)?.reason;\n      throw extractTxError({\n        logs,\n        receipts: callResult.receipts,\n        statusReason,\n      });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Converts a CallResult to an invocation result based on the provided call configuration.\n *\n * @param callResult - The CallResult from the script call.\n * @param call - The call configuration.\n * @param logs - Optional logs associated with the decoding.\n * @returns The decoded invocation result.\n */\nexport function callResultToInvocationResult<TReturn>(\n  callResult: CallResult,\n  call: CallConfig,\n  logs?: unknown[]\n): TReturn {\n  return decodeCallResult(\n    callResult,\n    (scriptResult: ScriptResult) => {\n      if (scriptResult.returnReceipt.type === ReceiptType.Revert) {\n        throw new FuelError(\n          ErrorCode.SCRIPT_REVERTED,\n          `Script Reverted. Logs: ${JSON.stringify(logs)}`\n        );\n      }\n\n      if (\n        scriptResult.returnReceipt.type !== ReceiptType.Return &&\n        scriptResult.returnReceipt.type !== ReceiptType.ReturnData\n      ) {\n        const { type } = scriptResult.returnReceipt;\n        throw new FuelError(\n          ErrorCode.SCRIPT_REVERTED,\n          `Script Return Type [${type}] Invalid. Logs: ${JSON.stringify({\n            logs,\n            receipt: scriptResult.returnReceipt,\n          })}`\n        );\n      }\n\n      let value;\n      if (scriptResult.returnReceipt.type === ReceiptType.Return) {\n        value = scriptResult.returnReceipt.val;\n      }\n      if (scriptResult.returnReceipt.type === ReceiptType.ReturnData) {\n        const decoded = call.func.decodeOutput(scriptResult.returnReceipt.data);\n        value = decoded[0];\n      }\n\n      return value as TReturn;\n    },\n    logs\n  );\n}\n\nexport type EncodedScriptCall = Uint8Array | { data: Uint8Array; script: Uint8Array };\n\n/**\n * `ScriptRequest` provides functionality to encode and decode script data and results.\n *\n * @template TData - Type of the script data.\n * @template TResult - Type of the script result.\n */\nexport class ScriptRequest<TData = void, TResult = void> {\n  /**\n   * The bytes of the script.\n   */\n  bytes: Uint8Array;\n\n  /**\n   * A function to encode the script data.\n   */\n  scriptDataEncoder: (data: TData) => EncodedScriptCall;\n\n  /**\n   * A function to decode the script result.\n   */\n  scriptResultDecoder: (scriptResult: ScriptResult) => TResult;\n\n  /**\n   * Creates an instance of the ScriptRequest class.\n   *\n   * @param bytes - The bytes of the script.\n   * @param scriptDataEncoder - The script data encoder function.\n   * @param scriptResultDecoder - The script result decoder function.\n   */\n  constructor(\n    bytes: BytesLike,\n    scriptDataEncoder: (data: TData) => EncodedScriptCall,\n    scriptResultDecoder: (scriptResult: ScriptResult) => TResult\n  ) {\n    this.bytes = arrayify(bytes);\n    this.scriptDataEncoder = scriptDataEncoder;\n    this.scriptResultDecoder = scriptResultDecoder;\n  }\n\n  /**\n   * Gets the script data offset for the given bytes.\n   *\n   * @param byteLength - The byte length of the script.\n   * @param maxInputs - The maxInputs value from the chain's consensus params.\n   * @returns The script data offset.\n   */\n  static getScriptDataOffsetWithScriptBytes(byteLength: number, maxInputs: number): number {\n    const scriptDataBaseOffset = calculateVmTxMemory({ maxInputs }) + SCRIPT_FIXED_SIZE;\n    return scriptDataBaseOffset + byteLength;\n  }\n\n  /**\n   * Gets the script data offset.\n   *\n   * @param maxInputs - The maxInputs value from the chain's consensus params.\n   * @returns The script data offset.\n   */\n  getScriptDataOffset(maxInputs: number) {\n    return ScriptRequest.getScriptDataOffsetWithScriptBytes(this.bytes.length, maxInputs);\n  }\n\n  /**\n   * Encodes the data for a script call.\n   *\n   * @param data - The script data.\n   * @returns The encoded data.\n   */\n  encodeScriptData(data: TData): Uint8Array {\n    const callScript = this.scriptDataEncoder(data);\n    // if Uint8Array\n    if (ArrayBuffer.isView(callScript)) {\n      return callScript;\n    }\n\n    // object\n    this.bytes = arrayify(callScript.script);\n    return callScript.data;\n  }\n\n  /**\n   * Decodes the result of a script call.\n   *\n   * @param callResult - The CallResult from the script call.\n   * @param logs - Optional logs associated with the decoding.\n   * @returns The decoded result.\n   */\n  decodeCallResult(callResult: CallResult, logs: Array<any> = []): TResult {\n    return decodeCallResult(callResult, this.scriptResultDecoder, logs);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable max-classes-per-file */\nimport type {\n  CallResult,\n  JsonAbisFromAllCalls,\n  TransactionResponse,\n  TransactionResult,\n  TransactionResultReceipt,\n} from '@fuel-ts/account';\nimport { getDecodedLogs } from '@fuel-ts/account';\nimport type { AbstractContract, AbstractProgram } from '@fuel-ts/interfaces';\nimport type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { ReceiptScriptResult } from '@fuel-ts/transactions';\nimport { ReceiptType } from '@fuel-ts/transactions';\n\nimport { decodeContractCallScriptResult } from '../contract-call-script';\nimport { callResultToInvocationResult } from '../script-request';\nimport type { CallConfig, InvocationScopeLike } from '../types';\nimport { getAbisFromAllCalls } from '../utils';\n\n/**\n * Calculates the gas usage from a CallResult.\n *\n * @param callResult - The CallResult containing receipt data.\n * @returns The gas usage.\n */\nfunction getGasUsage(callResult: CallResult) {\n  const scriptResult = callResult.receipts.find((r) => r.type === ReceiptType.ScriptResult) as\n    | ReceiptScriptResult\n    | undefined;\n  return scriptResult?.gasUsed || bn(0);\n}\n\n/**\n * Represents the result of a function invocation, with decoded logs and gas usage.\n *\n * @template T - The type of the returned value.\n */\nexport class InvocationResult<T = any> {\n  readonly functionScopes: Array<InvocationScopeLike>;\n  readonly isMultiCall: boolean;\n  readonly gasUsed: BN;\n  readonly value: T;\n\n  /**\n   * Constructs an instance of InvocationResult.\n   *\n   * @param funcScopes - The function scopes.\n   * @param callResult - The call result.\n   * @param isMultiCall - Whether it's a multi-call.\n   */\n  constructor(\n    funcScopes: InvocationScopeLike | Array<InvocationScopeLike>,\n    callResult: CallResult,\n    isMultiCall: boolean\n  ) {\n    this.functionScopes = Array.isArray(funcScopes) ? funcScopes : [funcScopes];\n    this.isMultiCall = isMultiCall;\n    this.value = this.getDecodedValue(callResult);\n    this.gasUsed = getGasUsage(callResult);\n  }\n\n  /**\n   * Gets the first call config.\n   *\n   * @returns The first call config.\n   */\n  private getFirstCallConfig(): CallConfig | undefined {\n    if (!this.functionScopes[0]) {\n      return undefined;\n    }\n\n    return this.functionScopes[0].getCallConfig();\n  }\n\n  /**\n   * Gets the ABI from all calls.\n   *\n   * @returns The ABIs from all calls.\n   */\n\n  getAbiFromAllCalls(): JsonAbisFromAllCalls {\n    return getAbisFromAllCalls(this.functionScopes);\n  }\n\n  /**\n   * Decodes the value from the call result.\n   *\n   * @param callResult - The call result.\n   * @returns The decoded value.\n   */\n  protected getDecodedValue(callResult: CallResult) {\n    const logs = this.getDecodedLogs(callResult.receipts);\n    const callConfig = this.getFirstCallConfig();\n    if (this.functionScopes.length === 1 && callConfig && 'bytes' in callConfig.program) {\n      return callResultToInvocationResult<T>(callResult, callConfig, logs);\n    }\n\n    const encodedResults = decodeContractCallScriptResult(\n      callResult,\n      (callConfig?.program as AbstractContract).id,\n      logs\n    );\n    const returnValues = encodedResults.map((encodedResult, i) => {\n      const { func } = this.functionScopes[i].getCallConfig();\n      return func.decodeOutput(encodedResult)?.[0];\n    });\n    return (this.isMultiCall ? returnValues : returnValues?.[0]) as T;\n  }\n\n  /**\n   * Decodes the logs from the receipts.\n   *\n   * @param receipts - The transaction result receipts.\n   * @returns The decoded logs.\n   */\n  protected getDecodedLogs(receipts: Array<TransactionResultReceipt>) {\n    const mainCallConfig = this.getFirstCallConfig();\n    if (!mainCallConfig) {\n      return [];\n    }\n\n    const { main, otherContractsAbis } = this.getAbiFromAllCalls();\n\n    return getDecodedLogs(receipts, main, otherContractsAbis);\n  }\n}\n\n/**\n * Represents the result of a function invocation with transaction details.\n *\n * @template T - The type of the returned value.\n * @template TTransactionType - The type of the transaction.\n */\nexport class FunctionInvocationResult<\n  T = any,\n  TTransactionType = void,\n> extends InvocationResult<T> {\n  readonly transactionId: string;\n  readonly transactionResponse: TransactionResponse;\n  readonly transactionResult: TransactionResult<TTransactionType>;\n  readonly program: AbstractProgram;\n  readonly logs!: Array<any>;\n\n  /**\n   * Constructs an instance of FunctionInvocationResult.\n   *\n   * @param funcScopes - The function scopes.\n   * @param transactionResponse - The transaction response.\n   * @param transactionResult - The transaction result.\n   * @param program - The program.\n   * @param isMultiCall - Whether it's a multi-call.\n   */\n  constructor(\n    funcScopes: InvocationScopeLike | Array<InvocationScopeLike>,\n    transactionResponse: TransactionResponse,\n    transactionResult: TransactionResult<TTransactionType>,\n    program: AbstractProgram,\n    isMultiCall: boolean\n  ) {\n    super(funcScopes, transactionResult, isMultiCall);\n    this.transactionResponse = transactionResponse;\n    this.transactionResult = transactionResult;\n    this.transactionId = this.transactionResponse.id;\n    this.program = program;\n    this.logs = this.getDecodedLogs(transactionResult.receipts);\n  }\n\n  /**\n   * Builds an instance of FunctionInvocationResult.\n   *\n   * @param funcScope - The function scope.\n   * @param transactionResponse - The transaction response.\n   * @param isMultiCall - Whether it's a multi-call.\n   * @param program - The program.\n   * @returns The function invocation result.\n   */\n  static async build<T, TTransactionType = void>(\n    funcScope: InvocationScopeLike | Array<InvocationScopeLike>,\n    transactionResponse: TransactionResponse,\n    isMultiCall: boolean,\n    program: AbstractProgram\n  ) {\n    const txResult = await transactionResponse.waitForResult<TTransactionType>();\n    const fnResult = new FunctionInvocationResult<T, TTransactionType>(\n      funcScope,\n      transactionResponse,\n      txResult,\n      program,\n      isMultiCall\n    );\n    return fnResult;\n  }\n}\n\n/**\n * Represents the result of an invocation call.\n *\n * @template T - The type of the returned value.\n */\nexport class InvocationCallResult<T = any> extends InvocationResult<T> {\n  readonly callResult: CallResult;\n\n  /**\n   * Constructs an instance of InvocationCallResult.\n   *\n   * @param funcScopes - The function scopes.\n   * @param callResult - The call result.\n   * @param isMultiCall - Whether it's a multi-call.\n   */\n  constructor(\n    funcScopes: InvocationScopeLike | Array<InvocationScopeLike>,\n    callResult: CallResult,\n    isMultiCall: boolean\n  ) {\n    super(funcScopes, callResult, isMultiCall);\n    this.callResult = callResult;\n  }\n\n  /**\n   * Builds an instance of InvocationCallResult.\n   *\n   * @param funcScopes - The function scopes.\n   * @param callResult - The call result.\n   * @param isMultiCall - Whether it's a multi-call.\n   * @returns The invocation call result.\n   */\n  static async build<T>(\n    funcScopes: InvocationScopeLike | Array<InvocationScopeLike>,\n    callResult: CallResult,\n    isMultiCall: boolean\n  ) {\n    const fnResult = await new InvocationCallResult<T>(funcScopes, callResult, isMultiCall);\n    return fnResult;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { AbstractContract } from '@fuel-ts/interfaces';\n\nimport { BaseInvocationScope } from './base-invocation-scope';\nimport type { FunctionInvocationScope } from './invocation-scope';\n\n/**\n * Represents a scope for invoking multiple calls.\n *\n * @template TReturn - The type of the return value.\n */\nexport class MultiCallInvocationScope<TReturn = any> extends BaseInvocationScope<TReturn> {\n  /**\n   * Constructs an instance of MultiCallInvocationScope.\n   *\n   * @param contract - The contract.\n   * @param funcScopes - An array of function invocation scopes.\n   */\n  constructor(contract: AbstractContract, funcScopes: Array<FunctionInvocationScope>) {\n    super(contract, true);\n    this.addCalls(funcScopes);\n  }\n\n  /**\n   * Adds a single function invocation scope to the multi-call invocation scope.\n   *\n   * @param funcScope - The function invocation scope.\n   * @returns The instance of MultiCallInvocationScope.\n   */\n  addCall(funcScope: FunctionInvocationScope) {\n    return super.addCalls([funcScope]);\n  }\n\n  /**\n   * Adds multiple function invocation scopes to the multi-call invocation scope.\n   *\n   * @param funcScopes - An array of function invocation scopes.\n   * @returns The instance of MultiCallInvocationScope.\n   */\n  addCalls(funcScopes: Array<FunctionInvocationScope>) {\n    return super.addCalls(funcScopes);\n  }\n}\n","import type { FunctionFragment, JsonAbi } from '@fuel-ts/abi-coder';\nimport { Interface } from '@fuel-ts/abi-coder';\nimport type { Account, Provider } from '@fuel-ts/account';\nimport { Address } from '@fuel-ts/address';\nimport type { AbstractAddress, AbstractContract, BytesLike } from '@fuel-ts/interfaces';\n\nimport { FunctionInvocationScope } from './functions/invocation-scope';\nimport { MultiCallInvocationScope } from './functions/multicall-scope';\nimport type { InvokeFunction, InvokeFunctions } from './types';\n\n/**\n * `Contract` provides a way to interact with the contract program type.\n */\nexport default class Contract implements AbstractContract {\n  /**\n   * The unique contract identifier.\n   */\n  id!: AbstractAddress;\n\n  /**\n   * The provider for interacting with the contract.\n   */\n  provider!: Provider;\n\n  /**\n   * The contract's ABI interface.\n   */\n  interface!: Interface;\n\n  /**\n   * The account associated with the contract, if available.\n   */\n  account!: Account | null;\n\n  /**\n   * A collection of functions available on the contract.\n   */\n  functions: InvokeFunctions = {};\n\n  /**\n   * Creates an instance of the Contract class.\n   *\n   * @param id - The contract's address.\n   * @param abi - The contract's ABI (JSON ABI or Interface instance).\n   * @param accountOrProvider - The account or provider for interaction.\n   */\n  constructor(\n    id: string | AbstractAddress,\n    abi: JsonAbi | Interface,\n    accountOrProvider: Account | Provider\n  ) {\n    this.interface = abi instanceof Interface ? abi : new Interface(abi);\n    this.id = Address.fromAddressOrString(id);\n\n    /**\n      Instead of using `instanceof` to compare classes, we instead check\n      if `accountOrProvider` have a `provider` property inside. If yes,\n      than we assume it's a Wallet.\n\n      This approach is safer than using `instanceof` because it\n      there might be different versions and bundles of the library.\n\n      The same is done at:\n        - ./contract-factory.ts\n\n      @see ContractFactory\n    */\n    if (accountOrProvider && 'provider' in accountOrProvider) {\n      this.provider = accountOrProvider.provider;\n      this.account = accountOrProvider;\n    } else {\n      this.provider = accountOrProvider;\n      this.account = null;\n    }\n\n    Object.keys(this.interface.functions).forEach((name) => {\n      const fragment = this.interface.getFunction(name);\n      Object.defineProperty(this.functions, fragment.name, {\n        value: this.buildFunction(fragment),\n        writable: false,\n      });\n    });\n  }\n\n  /**\n   * Build a function invocation scope for the provided function fragment.\n   *\n   * @param func - The function fragment to build a scope for.\n   * @returns A function that creates a FunctionInvocationScope.\n   */\n  buildFunction(func: FunctionFragment) {\n    return (() => {\n      const funcInvocationScopeCreator = (...args: Array<unknown>) =>\n        new FunctionInvocationScope(this, func, args);\n\n      Object.defineProperty(funcInvocationScopeCreator, 'isReadOnly', {\n        value: () => func.isReadOnly(),\n        writable: false,\n      });\n\n      return funcInvocationScopeCreator;\n    })() as InvokeFunction;\n  }\n\n  /**\n   * Create a multi-call invocation scope for the provided function invocation scopes.\n   *\n   * @param calls - An array of FunctionInvocationScopes to execute in a batch.\n   * @returns A MultiCallInvocationScope instance.\n   */\n  multiCall(calls: Array<FunctionInvocationScope>) {\n    return new MultiCallInvocationScope(this, calls);\n  }\n\n  /**\n   * Get the balance for a given asset ID for this contract.\n   *\n   * @param assetId - The specified asset ID.\n   * @returns The balance of the contract for the specified asset.\n   */\n  // #region contract-balance-1\n  getBalance(assetId: BytesLike) {\n    return this.provider.getContractBalance(this.id, assetId);\n  }\n  // #endregion contract-balance-1\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACCA,oBAAqC;AAU9B,SAAS,OAAO,WAAoB,SAAoC;AAC7E,MAAI,CAAC,WAAW;AACd,UAAM,IAAI,wBAAU,wBAAU,mBAAmB,OAAO;AAAA,EAC1D;AACF;AAOO,SAAS,oBACd,gBACsB;AACtB,SAAO,eAAe,OAAO,CAAC,KAAK,WAAW,MAAM;AAClD,UAAM,EAAE,SAAS,aAAa,IAAI,UAAU,cAAc;AAE1D,QAAI,MAAM,GAAG;AACX,UAAI,OAAO,QAAQ,UAAU;AAC7B,UAAI,qBAAqB,CAAC;AAAA,IAC5B,OAAO;AACL,UAAI,mBAAsC,QAAS,GAAG,OAAO,CAAC,IAAI,QAAQ,UAAU;AAAA,IACtF;AAEA,QAAI,qBAAqB,EAAE,GAAG,IAAI,oBAAoB,GAAG,aAAa;AAEtE,WAAO;AAAA,EACT,GAAG,CAAC,CAAyB;AAC/B;;;ACpCA,IAAAA,kBAA+B;AAC/B,IAAAC,iBAAqC;;;ACArC,IAAAC,kBAAyC;AACzC,qBAAwB;AACxB,IAAAC,iBAAqC;AAGrC,IAAAC,eAAmB;AACnB,IAAAC,uBAA2C;AAC3C,IAAAC,gBAA0B;AAC1B,IAAAC,OAAqB;AACrB,mBAAsB;;;ACZtB,IAAAC,oBAMO;AAOP,qBAA4B;AAC5B,IAAAC,iBAAqC;AAGrC,kBAA6B;AAC7B,IAAAC,uBAA4B;AAC5B,IAAAC,gBAAiC;AACjC,UAAqB;;;ACrBrB,mBAAgC;AAMzB,IAAM,iBAAN,MAAqB;AAAA,EAC1B;AAAA,EAEA,eAAe,MAAyB;AACtC,SAAK,cAAc,QAAQ,CAAC;AAAA,EAC9B;AAAA,EAEA,UAA6B;AAC3B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,QAAQ,MAAyB;AAC/B,SAAK,YAAY,KAAK,GAAG,IAAI;AAAA,EAC/B;AAAA,EAEA,OAAO,KAA2C;AAChD,WAAO,KAAK,YAAY,OAAO,GAAG;AAAA,EACpC;AAAA,EAEA,OAAO,KAAwB;AAC7B,SAAK,YAAY,KAAK,GAAG,GAAG;AAAA,EAC9B;AAAA,EAEA,UAAsB;AACpB,eAAO;AAAA,MACL,KAAK,YAAY,OAAO,CAAC,cAAc,SAAS;AAC9C,qBAAa,KAAK,KAAK,SAAS,CAAC;AACjC,eAAO;AAAA,MACT,GAAG,CAAC,CAAiB;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,QAAgB;AACd,eAAO,sBAAQ,KAAK,QAAQ,CAAC;AAAA,EAC/B;AAAA,EAEA,WAAW;AACT,WAAO;AAAA,EAAa,KAAK,UAAU,KAAK,aAAa,MAAM,CAAC;AAAA,EAC9D;AAAA,EAEA,aAAa;AACX,WAAO,KAAK,QAAQ,EAAE;AAAA,EACxB;AACF;;;AChDA,uBAMO;AAUP,qBAA+B;AAC/B,IAAAC,iBAAqC;AAIrC,0BAA4B;AAC5B,IAAAC,gBAAyB;AAIlB,IAAM,gCAAgC,CAAC,cAC5C,yCAAoB,sCAAoB,EAAE,UAAU,CAAC;AAChD,IAAM,sBACX,6BAAY,gCAAe,mCAAkB,6BAAY;AAsB3D,SAAS,yBAAyB,YAAsC;AACtE,QAAM,WAAW,CAAC,GAAG,WAAW,QAAQ;AAExC,MAAI;AACJ,MAAI;AAMJ,WAAS,QAAQ,CAAC,YAAY;AAC5B,QAAI,QAAQ,SAAS,gCAAY,cAAc;AAC7C,4BAAsB;AAAA,IACxB,WACE,QAAQ,SAAS,gCAAY,UAC7B,QAAQ,SAAS,gCAAY,cAC7B,QAAQ,SAAS,gCAAY,QAC7B;AACA,sBAAgB;AAAA,IAClB;AAAA,EACF,CAAC;AAED,MAAI,CAAC,uBAAuB,CAAC,eAAe;AAC1C,UAAM,IAAI,yBAAU,yBAAU,iBAAiB,uBAAuB;AAAA,EACxE;AAEA,QAAM,eAA6B;AAAA,IACjC,MAAM,oBAAoB;AAAA,IAC1B,SAAS,oBAAoB;AAAA,IAC7B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AACT;AAWO,SAAS,iBACd,YACA,SACA,OAAmB,CAAC,GACX;AACT,MAAI;AACF,UAAM,eAAe,yBAAyB,UAAU;AACxD,WAAO,QAAQ,YAAY;AAAA,EAC7B,SAAS,OAAP;AACA,QAAgB,MAAO,SAAS,yBAAU,iBAAiB;AACzD,YAAM,eAA6C,YAAY,cAAe;AAC9E,gBAAM,+BAAe;AAAA,QACnB;AAAA,QACA,UAAU,WAAW;AAAA,QACrB;AAAA,MACF,CAAC;AAAA,IACH;AAEA,UAAM;AAAA,EACR;AACF;AAUO,SAAS,6BACd,YACAC,OACA,MACS;AACT,SAAO;AAAA,IACL;AAAA,IACA,CAAC,iBAA+B;AAC9B,UAAI,aAAa,cAAc,SAAS,gCAAY,QAAQ;AAC1D,cAAM,IAAI;AAAA,UACR,yBAAU;AAAA,UACV,0BAA0B,KAAK,UAAU,IAAI;AAAA,QAC/C;AAAA,MACF;AAEA,UACE,aAAa,cAAc,SAAS,gCAAY,UAChD,aAAa,cAAc,SAAS,gCAAY,YAChD;AACA,cAAM,EAAE,KAAK,IAAI,aAAa;AAC9B,cAAM,IAAI;AAAA,UACR,yBAAU;AAAA,UACV,uBAAuB,wBAAwB,KAAK,UAAU;AAAA,YAC5D;AAAA,YACA,SAAS,aAAa;AAAA,UACxB,CAAC;AAAA,QACH;AAAA,MACF;AAEA,UAAI;AACJ,UAAI,aAAa,cAAc,SAAS,gCAAY,QAAQ;AAC1D,gBAAQ,aAAa,cAAc;AAAA,MACrC;AACA,UAAI,aAAa,cAAc,SAAS,gCAAY,YAAY;AAC9D,cAAM,UAAUA,MAAK,KAAK,aAAa,aAAa,cAAc,IAAI;AACtE,gBAAQ,QAAQ,CAAC;AAAA,MACnB;AAEA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,EACF;AACF;AAUO,IAAM,gBAAN,MAAkD;AAAA;AAAA;AAAA;AAAA,EAIvD;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,YACE,OACA,mBACAC,sBACA;AACA,SAAK,YAAQ,wBAAS,KAAK;AAC3B,SAAK,oBAAoB;AACzB,SAAK,sBAAsBA;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,mCAAmC,YAAoB,WAA2B;AACvF,UAAM,2BAAuB,sCAAoB,EAAE,UAAU,CAAC,IAAI;AAClE,WAAO,uBAAuB;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,oBAAoB,WAAmB;AACrC,WAAO,cAAc,mCAAmC,KAAK,MAAM,QAAQ,SAAS;AAAA,EACtF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,iBAAiB,MAAyB;AACxC,UAAM,aAAa,KAAK,kBAAkB,IAAI;AAE9C,QAAI,YAAY,OAAO,UAAU,GAAG;AAClC,aAAO;AAAA,IACT;AAGA,SAAK,YAAQ,wBAAS,WAAW,MAAM;AACvC,WAAO,WAAW;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,iBAAiB,YAAwB,OAAmB,CAAC,GAAY;AACvE,WAAO,iBAAiB,YAAY,KAAK,qBAAqB,IAAI;AAAA,EACpE;AACF;;;AFrOA,IAAM,wBAAgD;AAAA,EACpD,eAAe;AAAA,EACf,cAAc;AAAA,EACd,oBAAoB;AAAA,EACpB,gBAAgB;AAClB;AAGA,IAAM,6BAA6B;AAYnC,IAAM,4BAA4B,CAAC;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAA8C;AAC5C,QAAM,OAAO,IAAI;AAAA,IACX,SAAK,IAAM,cAAc;AAAA,IACzB,SAAK,IAAM,YAAY;AAAA,IACvB,OAAG,IAAM,IAAM,CAAC;AAAA,IAChB,SAAK,IAAM,aAAa;AAAA,EAC9B;AAEA,MAAI,oBAAoB;AACtB,SAAK;AAAA,MACC,SAAK,IAAM,kBAAkB;AAAA,MAC7B,OAAG,IAAM,IAAM,CAAC;AAAA,MAChB,SAAK,IAAM,IAAM,IAAM,EAAI;AAAA,IACjC;AAAA,EACF,OAAO;AACL,SAAK,KAAS,SAAK,IAAM,IAAM,IAAU,UAAM,KAAK,EAAE,MAAM,CAAC,CAAC;AAAA,EAChE;AAEA,SAAO;AACT;AAEA,SAAS,gBAAgB,SAA+C;AACtE,MAAI,CAAC,QAAQ,QAAQ;AACnB,WAAO,IAAI,WAAW;AAAA,EACxB;AAEA,QAAM,wBAAwB,IAAI,eAAe;AACjD,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK,GAAG;AAC1C,0BAAsB,OAAO,0BAA0B,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC;AAAA,EAC9E;AAEA,wBAAsB,KAAS,QAAI,CAAI,CAAC;AACxC,SAAO,sBAAsB,QAAQ;AACvC;AAIA,IAAM,eAAe,CAAC,SACpB,SAAS,iCAAY,UAAU,SAAS,iCAAY;AAEtD,IAAM,qBAAqB,CACzB,UACA,eAEA,SAAS;AAAA,EACP,CAAC,EAAE,MAAM,MAAM,GAAG,MAChB,SAAS,iCAAY,QAAQ,SAAS,8BAA8B,OAAO;AAC/E;AAEF,IAAM,sBAAsB,CAAC,eAAgC,CAAC,WAAyB;AACrF,UAAI,sBAAS,OAAO,IAAI,MAAM,GAAG;AAC/B,UAAM,IAAI,yBAAU,yBAAU,iBAAiB,uBAAuB;AAAA,EACxE;AAEA,QAAM,iBAAiB;AAAA,IACrB,OAAO;AAAA,IACP,WAAW,OAAO;AAAA,EACpB;AACA,QAAM,+BAA2B,gBAAG,gBAAgB,EAAE;AAEtD,QAAM,WAAW,OAAO;AACxB,SAAO,SACJ,OAAO,CAAC,EAAE,KAAK,MAAM,aAAa,IAAI,CAAC,EACvC,QAAQ,CAAC,YAA2B;AACnC,QAAI,CAAC,yBAAyB,OAAG,gBAAG,QAAQ,EAAE,CAAC,GAAG;AAChD,aAAO,CAAC;AAAA,IACV;AACA,QAAI,QAAQ,SAAS,iCAAY,QAAQ;AACvC,aAAO,CAAC,IAAI,iCAAe,KAAK,EAAE,OAAQ,QAA2C,GAAG,CAAC;AAAA,IAC3F;AACA,QAAI,QAAQ,SAAS,iCAAY,YAAY;AAC3C,YAAM,0BAAsB,wBAAS,QAAQ,IAAI;AAEjD,aAAO,CAAC,mBAAmB;AAAA,IAC7B;AAEA,WAAO,CAAC,IAAI,WAAW,CAAC;AAAA,EAC1B,CAAC;AACL;AAEO,IAAM,iCAAiC,CAC5C,YACA,YACA,OAAmB,CAAC,MACH,iBAAiB,YAAY,oBAAoB,UAAU,GAAG,IAAI;AAErF,IAAM,4BAA4B,CAAC,kBACjC,cAAc;AAAA,EACZ,CAAC,KAAKC,UAAS;AACb,UAAM,SAAiC,EAAE,GAAG,sBAAsB;AAClE,QAAIA,MAAK,KAAK;AACZ,aAAO,qBAAqB;AAAA,IAC9B;AAEA,WAAO,MAAM,0BAA0B,MAAM,EAAE,WAAW;AAAA,EAC5D;AAAA,EACI,gBAAY,KAAK;AAAA;AACvB;AAEK,IAAM,wBAAwB,CACnC,gBACA,cAEA,IAAI;AAAA;AAAA,EAEF,gBAAgB,IAAI,MAAM,eAAe,MAAM,EAAE,KAAK,qBAAqB,CAAC;AAAA,EAC5E,CAAC,kBAAqC;AACpC,UAAM,cAAc,cAAc;AAElC,QAAI,gBAAgB,GAAG;AACrB,aAAO,EAAE,MAAM,IAAI,WAAW,GAAG,QAAQ,IAAI,WAAW,EAAE;AAAA,IAC5D;AAGA,UAAM,yBAAyB,0BAA0B,aAAa;AAGtE,UAAM,iBAAiB,IAAK,yBAAyB,KAAM;AAC3D,UAAM,2BAA2B,yBAAyB;AAG1D,UAAM,aACJ,8BAA8B,UAAU,SAAS,CAAC,IAAI;AAGxD,UAAM,eAAyC,CAAC;AAEhD,QAAI,gBAAgB;AAEpB,UAAM,aAA2B,CAAC;AAClC,aAAS,IAAI,GAAG,IAAI,aAAa,KAAK,GAAG;AACvC,YAAMA,QAAO,cAAc,CAAC;AAE5B,YAAM,eAAe;AACrB,YAAM,gBAAgB,eAAe;AACrC,YAAM,iBAAiB,gBAAgB;AACvC,YAAM,wBAAwB,iBAAiB,oCAAkB,8BAAY;AAC7E,YAAM,oBAAoB,wBAAwBA,MAAK,gBAAgB;AACvE,YAAM,kBAAc,wBAASA,MAAK,IAAI;AACtC,UAAI,qBAAqB;AAGzB,iBAAW,KAAK,IAAI,iCAAe,KAAK,EAAE,OAAOA,MAAK,UAAU,CAAC,CAAC;AAElE,iBAAW,KAAK,IAAI,4BAAU,EAAE,OAAOA,MAAK,SAAS,SAAS,KAAK,0BAAW,CAAC;AAE/E,iBAAW,KAAKA,MAAK,WAAW,QAAQ,CAAC;AAEzC,iBAAW,KAAK,IAAI,iCAAe,KAAK,EAAE,OAAO,qBAAqB,CAAC;AAEvE,iBAAW,KAAK,IAAI,iCAAe,KAAK,EAAE,OAAO,iBAAiB,CAAC;AAEnE,iBAAW,KAAKA,MAAK,eAAe;AAEpC,iBAAW,KAAK,WAAW;AAG3B,UAAIA,MAAK,KAAK;AACZ,mBAAW,KAAK,IAAI,iCAAe,KAAK,EAAE,OAAOA,MAAK,GAAG,CAAC;AAC1D,6BAAqB,oBAAoB,YAAY;AAAA,MACvD;AAEA,YAAM,mBAA2C;AAAA,QAC/C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAGA,mBAAa,KAAK,gBAAgB;AAClC,sBAAgB,iBAAa,sBAAO,UAAU,EAAE;AAAA,IAClD;AAGA,UAAM,SAAS,gBAAgB,YAAY;AAC3C,UAAM,sBAAkB,sBAAO,UAAU;AACzC,WAAO,EAAE,MAAM,iBAAiB,OAAO;AAAA,EACzC;AAAA,EACA,MAAM,CAAC,IAAI,WAAW,CAAC;AACzB;;;AGvOF,IAAAC,kBAA+B;AAG/B,IAAAC,eAAmB;AAEnB,IAAAC,uBAA4B;AAa5B,SAAS,YAAY,YAAwB;AAC3C,QAAM,eAAe,WAAW,SAAS,KAAK,CAAC,MAAM,EAAE,SAAS,iCAAY,YAAY;AAGxF,SAAO,cAAc,eAAW,iBAAG,CAAC;AACtC;AAOO,IAAM,mBAAN,MAAgC;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAST,YACE,YACA,YACA,aACA;AACA,SAAK,iBAAiB,MAAM,QAAQ,UAAU,IAAI,aAAa,CAAC,UAAU;AAC1E,SAAK,cAAc;AACnB,SAAK,QAAQ,KAAK,gBAAgB,UAAU;AAC5C,SAAK,UAAU,YAAY,UAAU;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,qBAA6C;AACnD,QAAI,CAAC,KAAK,eAAe,CAAC,GAAG;AAC3B,aAAO;AAAA,IACT;AAEA,WAAO,KAAK,eAAe,CAAC,EAAE,cAAc;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,qBAA2C;AACzC,WAAO,oBAAoB,KAAK,cAAc;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQU,gBAAgB,YAAwB;AAChD,UAAM,OAAO,KAAK,eAAe,WAAW,QAAQ;AACpD,UAAM,aAAa,KAAK,mBAAmB;AAC3C,QAAI,KAAK,eAAe,WAAW,KAAK,cAAc,WAAW,WAAW,SAAS;AACnF,aAAO,6BAAgC,YAAY,YAAY,IAAI;AAAA,IACrE;AAEA,UAAM,iBAAiB;AAAA,MACrB;AAAA,OACC,YAAY,SAA6B;AAAA,MAC1C;AAAA,IACF;AACA,UAAM,eAAe,eAAe,IAAI,CAAC,eAAe,MAAM;AAC5D,YAAM,EAAE,KAAK,IAAI,KAAK,eAAe,CAAC,EAAE,cAAc;AACtD,aAAO,KAAK,aAAa,aAAa,IAAI,CAAC;AAAA,IAC7C,CAAC;AACD,WAAQ,KAAK,cAAc,eAAe,eAAe,CAAC;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQU,eAAe,UAA2C;AAClE,UAAM,iBAAiB,KAAK,mBAAmB;AAC/C,QAAI,CAAC,gBAAgB;AACnB,aAAO,CAAC;AAAA,IACV;AAEA,UAAM,EAAE,MAAM,mBAAmB,IAAI,KAAK,mBAAmB;AAE7D,eAAO,gCAAe,UAAU,MAAM,kBAAkB;AAAA,EAC1D;AACF;AAQO,IAAM,2BAAN,cAGG,iBAAoB;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWT,YACE,YACA,qBACA,mBACA,SACA,aACA;AACA,UAAM,YAAY,mBAAmB,WAAW;AAChD,SAAK,sBAAsB;AAC3B,SAAK,oBAAoB;AACzB,SAAK,gBAAgB,KAAK,oBAAoB;AAC9C,SAAK,UAAU;AACf,SAAK,OAAO,KAAK,eAAe,kBAAkB,QAAQ;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,aAAa,MACX,WACA,qBACA,aACA,SACA;AACA,UAAM,WAAW,MAAM,oBAAoB,cAAgC;AAC3E,UAAM,WAAW,IAAI;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACF;AAOO,IAAM,uBAAN,cAA4C,iBAAoB;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAST,YACE,YACA,YACA,aACA;AACA,UAAM,YAAY,YAAY,WAAW;AACzC,SAAK,aAAa;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,aAAa,MACX,YACA,YACA,aACA;AACA,UAAM,WAAW,MAAM,IAAI,qBAAwB,YAAY,YAAY,WAAW;AACtF,WAAO;AAAA,EACT;AACF;;;AJjNA,SAAS,mBAAmB,WAA8C;AACxE,QAAM,EAAE,SAAS,MAAM,SAAS,MAAM,gBAAgB,aAAa,IAAI,UAAU,cAAc;AAC/F,QAAM,OAAO,KAAK,gBAAgB,IAAyB;AAE3D,SAAO;AAAA,IACL,YAAa,QAA6B;AAAA,IAC1C,YAAY,KAAK;AAAA,IACjB,iBAAiB,KAAK;AAAA,IACtB,UAAU,KAAK;AAAA,IACf;AAAA,IACA,SAAS,SAAS;AAAA,IAClB,QAAQ,SAAS;AAAA,IACjB,KAAK,gBAAgB;AAAA,IACrB,uBAAuB;AAAA,EACzB;AACF;AAKO,IAAM,sBAAN,MAAyC;AAAA,EACpC;AAAA,EACA;AAAA,EACA,2BAAuD,CAAC;AAAA,EACxD;AAAA,EACA,gBAAgC,CAAC;AAAA,EACjC,cAAuB;AAAA,EACvB,wBAAiC;AAAA;AAAA,EACjC,eAAwC,CAAC;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUR,YAAY,SAA0B,aAAsB;AAC1D,SAAK,UAAU;AACf,SAAK,cAAc;AACnB,SAAK,qBAAqB,IAAI,yCAAyB;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAc,QAAQ;AACpB,UAAM,WAAW,KAAK,YAAY;AAClC,UAAM,kBAAkB,SAAS,SAAS;AAE1C,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAI;AAAA,QACR,yBAAU,MAAM;AAAA,QAChB;AAAA,MACF;AAAA,IACF;AACA,WAAO,KAAK,yBAAyB,IAAI,CAAC,cAAc,mBAAmB,SAAS,CAAC;AAAA,EACvF;AAAA;AAAA;AAAA;AAAA,EAKU,sBAAsB;AAC9B,UAAM,WAAW,KAAK,YAAY;AAClC,UAAM;AAAA,MACJ,qBAAqB;AAAA,QACnB,cAAc,EAAE,UAAU;AAAA,MAC5B;AAAA,IACF,IAAI,SAAS,SAAS;AACtB,UAAM,qBAAqB,sBAAsB,KAAK,0BAA0B,SAAS;AACzF,SAAK,mBAAmB,UAAU,oBAAoB,KAAK,KAAK;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA,EAKU,+BAA+B;AACvC,UAAM,QAAQ,KAAK;AACnB,UAAM,QAAQ,CAAC,MAAM;AACnB,UAAI,EAAE,YAAY;AAChB,aAAK,mBAAmB,0BAA0B,EAAE,UAAU;AAAA,MAChE;AACA,UAAI,EAAE,uBAAuB;AAC3B,eAAO,KAAK,EAAE,qBAAqB,EAAE;AAAA,UAAQ,CAAC,eAC5C,KAAK,mBAAmB,0BAA0B,uBAAQ,SAAS,UAAU,CAAC;AAAA,QAChF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,mBAAwC;AAChD,UAAM,mBAAmB,KAAK,MAC3B,IAAI,CAACC,WAAU;AAAA,MACd,SAAS,OAAOA,MAAK,OAAO;AAAA,MAC5B,YAAQ,iBAAGA,MAAK,UAAU,CAAC;AAAA,IAC7B,EAAE,EACD,OAAO,CAAC,EAAE,SAAS,OAAO,MAAM,WAAW,KAAC,iBAAG,MAAM,EAAE,OAAO,CAAC;AAClE,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKU,sBAAsB;AAC9B,UAAM,SAAS,KAAK,iBAAiB;AACrC,UAAM,qBAAqB,CACzB,eACA,EAAE,SAAS,OAAO,MACf;AACH,YAAM,gBAAgB,cAAc,IAAI,OAAO,GAAG,cAAU,iBAAG,CAAC;AAEhE,aAAO,cAAc,IAAI,SAAS;AAAA,QAChC,SAAS,OAAO,OAAO;AAAA,QACvB,QAAQ,cAAc,IAAI,MAAM;AAAA,MAClC,CAAC;AAAA,IACH;AACA,SAAK,gBAAgB,MAAM;AAAA,MACzB,OAAO,OAAO,oBAAoB,oBAAI,IAAuB,CAAC,EAAE,OAAO;AAAA,IACzE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQU,QAAQ,WAAgC;AAChD,SAAK,SAAS,CAAC,SAAS,CAAC;AACzB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQU,SAAS,YAAwC;AACzD,SAAK,yBAAyB,KAAK,GAAG,UAAU;AAChD,SAAK,6BAA6B;AAClC,SAAK,oBAAoB;AACzB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAgB,qBAAqB;AAEnC,UAAU,cAAS;AAGnB,SAAK,oBAAoB;AAGzB,SAAK,oBAAoB;AAIzB,SAAK,mBAAmB;AAExB,QAAI,KAAK,mBAAmB,SAAS,qCAAgB,QAAQ;AAC3D,WAAK,mBAAmB,OAAO,oBAAoB,KAAK,wBAAwB;AAAA,IAClF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKU,qBAAqB;AAC7B,UAAM,kBAAkB,KAAK,MAAM,OAAO,CAAC,OAAOA,UAAS,MAAM,IAAIA,MAAK,OAAO,CAAC,OAAG,iBAAG,CAAC,CAAC;AAE1F,QAAI,KAAK,mBAAmB,SAAS,GAAG,CAAC,GAAG;AAC1C,WAAK,mBAAmB,WAAW;AAAA,IACrC,WAAW,gBAAgB,GAAG,KAAK,mBAAmB,QAAQ,GAAG;AAC/D,YAAM,IAAI;AAAA,QACR,yBAAU;AAAA,QACV;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,qBAAqB;AACzB,UAAM,WAAW,KAAK,YAAY;AAElC,UAAM,UAAU,MAAM,KAAK,sBAAsB;AACjD,UAAM,SAAS,MAAM,SAAS,mBAAmB,SAAS;AAAA,MACxD,gBAAgB,KAAK,QAAQ;AAAA,MAC7B,sBAAsB,KAAK,iBAAiB;AAAA,MAC5C,mBAAmB,KAAK;AAAA,IAC1B,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,wBAAwB;AAC5B,QAAI,qBAAqB,MAAM,KAAK,sBAAsB;AAC1D,6BAAqB,oBAAM,kBAAkB;AAE7C,UAAM,SAAS,MAAM,KAAK,mBAAmB;AAC7C,UAAM,EAAE,SAAS,oBAAoB,iBAAiB,OAAO,IAAI;AACjE,SAAK,mBAAmB,oBAAoB,SAAS,MAAM;AAE3D,uBAAmB,SAAS,mBAAmB,OAAO,OAAO,CAAC,MAAM,EAAE,SAAS,+BAAU,IAAI;AAG7F,uBAAmB,QAAQ,CAAC,eAAe;AACzC,yBAAmB,0BAA0B,uBAAQ,WAAW,UAAU,CAAC;AAAA,IAC7E,CAAC;AAGD,uBAAmB,mBAAmB,eAAe;AAErD,UAAM,KAAK,QAAQ,SAAS,KAAK,oBAAoB,MAAM;AAE3D,QAAI,KAAK,oBAAoB;AAC3B,YAAM,KAAK,mBAAmB,kBAAkB;AAAA,IAClD;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,SAAS,UAAoB;AAC3B,SAAK,eAAe;AACpB,UAAM,UAAU,KAAK;AAErB,YAAQ,UAAM,iBAAG,SAAS,OAAO,QAAQ,GAAG;AAC5C,YAAQ,eAAW,iBAAG,SAAS,YAAY,QAAQ,QAAQ;AAC3D,YAAQ,SAAS,SAAS,aAAS,iBAAG,SAAS,MAAM,IAAI,QAAQ;AACjE,YAAQ,eAAe,SAAS,mBAAe,iBAAG,SAAS,YAAY,IAAI,QAAQ;AACnF,YAAQ,WAAW,SAAS,YAAY,QAAQ;AAEhD,YAAQ,mBAAmB,KAAK,cAAc,mBAAmB,CAAC;AAElE,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAa,WAAoC;AAC/C,cAAU,QAAQ,CAAC,aAAa;AAC9B,WAAK,mBAAmB,0BAA0B,SAAS,EAAE;AAC7D,WAAK,aAAa,SAAS,GAAG,OAAO,CAAC,IAAI,SAAS,UAAU;AAAA,IAC/D,CAAC;AACD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY,gBAAgC;AAC1C,UAAM,EAAE,QAAQ,aAAa,QAAQ,IAAI;AACzC,UAAM,cAAc,KAAK,YAAY,EAAE,eAAe;AACtD,SAAK,qBAAqB,KAAK,mBAAmB;AAAA,MAChD,uBAAQ,oBAAoB,WAAW;AAAA,MACvC;AAAA,MACA,WAAW;AAAA,IACb;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,iBAAiB,gBAAkC;AACjD,UAAM,cAAc,KAAK,YAAY,EAAE,eAAe;AACtD,mBAAe,QAAQ,CAAC,EAAE,aAAa,QAAQ,QAAQ,MAAM;AAC3D,WAAK,qBAAqB,KAAK,mBAAmB;AAAA,QAChD,uBAAQ,oBAAoB,WAAW;AAAA,QACvC;AAAA,QACA,WAAW;AAAA,MACb;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEA,WAAW,SAA8B;AACvC,SAAK,qBAAqB,OAAO,uBAC/B,mBAAmB,oBAAoB,OAAO;AAEhD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,wBAA2D;AAC/D,UAAM,KAAK,mBAAmB;AAC9B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,OAA0D;AAC9D,WAAO,KAAK,QAAQ,SAAS,qBAAqB;AAElD,UAAM,qBAAqB,MAAM,KAAK,sBAAsB;AAE5D,UAAM,WAAW,MAAM,KAAK,QAAQ,QAAQ,gBAAgB,oBAAoB;AAAA,MAC9E,gBAAgB;AAAA,MAChB,wBAAwB;AAAA,IAC1B,CAAC;AAED,WAAO,yBAAyB;AAAA,MAC9B,KAAK;AAAA,MACL;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAA0D;AAC9D,WAAO,KAAK,QAAQ,SAAS,qBAAqB;AAElD,QAAI,EAAE,2CAA2C,KAAK,QAAQ,UAAU;AACtE,YAAM,IAAI;AAAA,QACR,yBAAU;AAAA,QACV;AAAA,MACF;AAAA,IACF;AACA,UAAM,qBAAqB,MAAM,KAAK,sBAAsB;AAE5D,UAAM,SAAS,MAAM,KAAK,QAAQ,QAAQ,oBAAoB,oBAAoB;AAAA,MAChF,wBAAwB;AAAA,IAC1B,CAAC;AAED,WAAO,qBAAqB,MAAS,KAAK,0BAA0B,QAAQ,KAAK,WAAW;AAAA,EAC9F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,SAAwD;AAC5D,UAAM,EAAE,SAAS,IAAI,MAAM,KAAK,mBAAmB;AAEnD,UAAM,aAAyB;AAAA,MAC7B;AAAA,IACF;AAEA,WAAO,qBAAqB;AAAA,MAC1B,KAAK;AAAA,MACL;AAAA,MACA,KAAK;AAAA,IACP;AAAA,EACF;AAAA,EAEA,MAAM,MAAqD;AACzD,UAAM,EAAE,SAAS,IAAI,MAAM,KAAK,mBAAmB;AAEnD,UAAM,aAAyB;AAAA,MAC7B;AAAA,IACF;AAEA,WAAO,qBAAqB;AAAA,MAC1B,KAAK;AAAA,MACL;AAAA,MACA,KAAK;AAAA,IACP;AAAA,EACF;AAAA,EAEA,cAAwB;AACtB,UAAM,WAAqB,KAAK,QAAQ;AAExC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,iBAAiB,SAAmC;AACxD,UAAM,gBAAgB,WAAY,MAAM,KAAK,YAAY,EAAE,WAAW;AAEtE,UAAM,qBAAqB,MAAM,KAAK,sBAAsB;AAC5D,WAAO,mBAAmB,iBAAiB,aAAa;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKQ,mBACN,oBACA,SACA,QACA;AACA,UAAM,wBAAoB,yBAAU,KAAK,cAAc,QAAQ,KAAK,KAAK;AACzE,UAAM,sBAAkB,yBAAU,KAAK,cAAc,MAAM;AAE3D,UAAM,EAAE,UAAU,aAAa,QAAQ,UAAU,IAAI;AAErD,QAAI,CAAC,mBAAmB;AACtB,yBAAmB,WAAW;AAAA,IAChC,WAAW,YAAY,GAAG,OAAO,GAAG;AAClC,YAAM,IAAI;AAAA,QACR,yBAAU;AAAA,QACV,cAAc,6CAA6C;AAAA,MAC7D;AAAA,IACF;AAEA,QAAI,CAAC,iBAAiB;AACpB,yBAAmB,SAAS;AAAA,IAC9B,WAAW,OAAO,GAAG,SAAS,GAAG;AAC/B,YAAM,IAAI;AAAA,QACR,yBAAU;AAAA,QACV,YAAY,2CAA2C;AAAA,MACzD;AAAA,IACF;AAAA,EACF;AACF;;;ADtdO,IAAM,0BAAN,cAGG,oBAA6B;AAAA,EAC3B;AAAA,EACF;AAAA,EACA;AAAA,EACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASV,YAAY,SAA0B,MAAwB,MAAa;AACzE,UAAM,SAAS,KAAK;AACpB,SAAK,OAAO;AACZ,SAAK,OAAO,QAAQ,CAAC;AACrB,SAAK,aAAa,GAAG,IAAI;AACzB,UAAM,QAAQ,IAAI;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAmC;AACjC,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,SAAS,KAAK;AAAA,MACd,gBAAgB,KAAK;AAAA,MACrB,cAAc,KAAK;AAAA,MACnB,SAAS,KAAK;AAAA,MACd,MAAM,KAAK;AAAA,MACX,cAAc,KAAK;AAAA,IACrB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,gBAAgB,MAAa;AAC3B,SAAK,OAAO,QAAQ,CAAC;AACrB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,WAAW,YAAwB;AACjC,QAAI,CAAC,KAAK,yBAAyB,YAAY,aAAa,QAAW;AACrE,WAAK,wBAAwB;AAAA,IAC/B;AACA,SAAK,iBAAiB;AAEtB,QAAI,YAAY,SAAS;AACvB,UAAI,CAAC,KAAK,KAAK,WAAW,KAAK,CAAC,SAAS,KAAK,SAAS,SAAS,GAAG;AACjE,cAAM,IAAI;AAAA,UACR,yBAAU;AAAA,UACV,uBAAuB,KAAK,KAAK;AAAA,QACnC;AAAA,MACF;AAEA,WAAK,cAAU,gCAAe,WAAW,OAAO;AAAA,IAClD;AAGA,SAAK,aAAa,GAAG,KAAK,IAAI;AAG9B,SAAK,oBAAoB;AAEzB,WAAO;AAAA,EACT;AACF;;;AM1FO,IAAM,2BAAN,cAAsD,oBAA6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOxF,YAAY,UAA4B,YAA4C;AAClF,UAAM,UAAU,IAAI;AACpB,SAAK,SAAS,UAAU;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,QAAQ,WAAoC;AAC1C,WAAO,MAAM,SAAS,CAAC,SAAS,CAAC;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,SAAS,YAA4C;AACnD,WAAO,MAAM,SAAS,UAAU;AAAA,EAClC;AACF;;;ACzCA,IAAAC,oBAA0B;AAE1B,IAAAC,kBAAwB;AAUxB,IAAqB,WAArB,MAA0D;AAAA;AAAA;AAAA;AAAA,EAIxD;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKA,YAA6B,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS9B,YACE,IACA,KACA,mBACA;AACA,SAAK,YAAY,eAAe,8BAAY,MAAM,IAAI,4BAAU,GAAG;AACnE,SAAK,KAAK,wBAAQ,oBAAoB,EAAE;AAexC,QAAI,qBAAqB,cAAc,mBAAmB;AACxD,WAAK,WAAW,kBAAkB;AAClC,WAAK,UAAU;AAAA,IACjB,OAAO;AACL,WAAK,WAAW;AAChB,WAAK,UAAU;AAAA,IACjB;AAEA,WAAO,KAAK,KAAK,UAAU,SAAS,EAAE,QAAQ,CAAC,SAAS;AACtD,YAAM,WAAW,KAAK,UAAU,YAAY,IAAI;AAChD,aAAO,eAAe,KAAK,WAAW,SAAS,MAAM;AAAA,QACnD,OAAO,KAAK,cAAc,QAAQ;AAAA,QAClC,UAAU;AAAA,MACZ,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,cAAc,MAAwB;AACpC,YAAQ,MAAM;AACZ,YAAM,6BAA6B,IAAI,SACrC,IAAI,wBAAwB,MAAM,MAAM,IAAI;AAE9C,aAAO,eAAe,4BAA4B,cAAc;AAAA,QAC9D,OAAO,MAAM,KAAK,WAAW;AAAA,QAC7B,UAAU;AAAA,MACZ,CAAC;AAED,aAAO;AAAA,IACT,GAAG;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU,OAAuC;AAC/C,WAAO,IAAI,yBAAyB,MAAM,KAAK;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,WAAW,SAAoB;AAC7B,WAAO,KAAK,SAAS,mBAAmB,KAAK,IAAI,OAAO;AAAA,EAC1D;AAAA;AAEF;","names":["import_account","import_errors","import_account","import_errors","import_math","import_transactions","import_utils","asm","import_abi_coder","import_errors","import_transactions","import_utils","import_errors","import_utils","call","scriptResultDecoder","call","import_account","import_math","import_transactions","call","import_abi_coder","import_address"]}